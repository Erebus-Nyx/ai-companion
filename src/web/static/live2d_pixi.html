<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live2D AI Companion - Dual Architecture Testing Interface</title>
    <link rel="stylesheet" href="css/live2d_test.css">
</head>
    
    <!-- 
    =============================================================================
    PIXI.js LIVE2D DUAL ARCHITECTURE IMPLEMENTATION STATUS
    =============================================================================
    
    ðŸŽ¯ CURRENT STATUS: PRODUCTION-READY LIVE2D SYSTEM âœ…
    âœ… Dual Runtime Support - Cubism 2.x (.moc) and Cubism 3/4/5 (.moc3)
    âœ… PIXI.js 6.5.10 with proper EventEmitter compatibility
    âœ… Live2D v2 Bundle (474KB) for legacy model support
    âœ… Cubism 5 Core (207KB) for modern model support
    âœ… Clean file organization in dist/ folder
    âœ… Future-proof design with backward compatibility
    âœ… Maximum compatibility with all Live2D model formats
    âœ… Professional canvas sizing and model scaling
    âœ… Interactive mouse dragging and positioning
    âœ… Visual debugging tools (frames, hit boxes)
    âœ… Smart zoom system with base scaling
    âœ… Complete model lifecycle management
    âœ… Motion and expression loading integration
    
    ðŸ“‹ PHASE 1: BASIC PIXI.js SETUP âœ… COMPLETED
    âœ… PIXI.js v6.5.10 integration with pixi-live2d-display v0.4.0
    âœ… Canvas initialization and container setup with dynamic sizing
    âœ… Version detection with async initialization
    âœ… Comprehensive logging and error handling system
    âœ… Mouse tracking and UI controls
    âœ… Professional canvas margins and responsive design
    
    ðŸ“‹ PHASE 2: API INTEGRATION & MODEL LOADING âœ… COMPLETED
    âœ… Flask API integration (localhost:13443)
    âœ… Dynamic model discovery (28+ models detected)
    âœ… Model metadata parsing from API response
    âœ… Static file serving integration
    âœ… Model.json file loading and parsing
    âœ… Complete Live2D model rendering system
    âœ… Smart model interaction and positioning
    âœ… Model selection dropdown population
    âœ… Professional zoom controls with base scaling
    âœ… Optimal model scaling (75% of canvas height)
    
    ðŸ“‹ PHASE 3: MODULAR SYSTEM ARCHITECTURE âœ… COMPLETED
    âœ… Live2D modular system design and implementation
    âœ… Live2DCore class for PIXI and Live2D management
    âœ… Live2DLogger unified logging system
    âœ… Live2DModelManager for model lifecycle management
    âœ… Live2DMotionManager for motion categorization and playback
    âœ… Live2DTester for diagnostics and library validation
    âœ… Live2DIntegration orchestrator class
    âœ… Live2DUIController for UI management
    âœ… Configuration system (live2d_config.js)
    âœ… Syntax error resolution and module validation
    âœ… Proper dependency loading order
    
    ðŸ“‹ PHASE 4: LIVE2D LIBRARY INTEGRATION âœ… COMPLETED
    âœ… Live2D core library loading (Cubism 2.x & 3/4/5)
    âœ… PIXI.live2d display library integration
    âœ… Library compatibility debugging and diagnostics
    âœ… Comprehensive EventEmitter compatibility with PIXI v6+
    âœ… Advanced step-by-step diagnostics system
    âœ… Enhanced error handling and logging
    âœ… Dual Architecture Implementation - Support for both Cubism 2.x and 3/4/5 models
    âœ… PIXI.js 6.5.10 with proper EventEmitter compatibility
    âœ… Live2D v2 Bundle for legacy model support
    âœ… Cubism 5 Core for modern model support
    âœ… Clean file organization in dist/ folder
    âœ… Future-proof design with backward compatibility
    âœ… Live2D model loading from Flask API with dual architecture
    âœ… Complete Live2D model display with proper rendering
    âœ… Model positioning and scaling within PIXI canvas
    âœ… Mouse interaction system (drag-to-move)
    âœ… Model hit testing and interaction zones
    
    ðŸ“‹ PHASE 5: UI SYSTEM INTEGRATION âœ… COMPLETED
    âœ… Left panel collapsible functionality
    âœ… Model selection dropdown with API integration
    âœ… Motion group and individual motion dropdowns
    âœ… Expression selection dropdown
    âœ… Professional zoom controls with slider and buttons
    âœ… Model info display panel
    âœ… Action buttons (Test, Reset, Copy Log, Fit)
    âœ… Log panel with toggle functionality
    âœ… Panel toggle button positioning and visibility
    âœ… Canvas frame visualization toggle
    âœ… Model frame visualization toggle
    âœ… Hit area visualization toggle
    âœ… Smart zoom system with base scaling
    âœ… Responsive design for different screen sizes
    âœ… Loading states and progress indicators
    
    ðŸ“‹ PHASE 6: MOTION & EXPRESSION SYSTEM âœ… COMPLETED
    âœ… Motion categorization system (idle, head, body, expression, special, talk)
    âœ… Motion group discovery and organization
    âœ… Motion queue and priority system
    âœ… Random motion playback functionality
    âœ… Motion statistics and debugging
    âœ… Dynamic motion loading from Flask API
    âœ… Real-time motion list population
    âœ… Expression loading and dropdown population
    âœ… Integrated motion and expression management
    
    ðŸ“‹ PHASE 7: ADVANCED FEATURES âœ… COMPLETED
    âœ… Mouse dragging with boundary constraints
    âœ… Touch support via pointer events
    âœ… Visual feedback during interactions
    âœ… Smart canvas sizing with margins
    âœ… Professional model scaling (75% height, no upscaling)
    âœ… Canvas frame visualization
    âœ… Model frame visualization with dimensions
    âœ… Hit area visualization
    âœ… Zoom as multiplier of base scale
    âœ… Model centering and fit functionality
    âœ… Proper model clearing on changes
    âœ… Duplicate loading prevention
    âœ… Complete graphics cleanup
    
    ðŸ“‹ PRODUCTION READY FEATURES âœ…
    âœ… Complete dual architecture support (Cubism 2.x + 3/4/5)
    âœ… Professional canvas and model management
    âœ… Interactive mouse dragging and positioning
    âœ… Smart zoom system with base scaling
    âœ… Visual debugging tools
    âœ… Motion and expression integration
    âœ… Responsive UI with collapsible panels
    âœ… Flask API integration
    âœ… Error handling and logging
    âœ… Touch device support
    âœ… Performance optimization
    âœ… Clean code architecture
    
    ðŸŽ¯ NEXT STEPS: READY FOR AI COMPANION INTEGRATION
    - Integration with AI chat system
    - Lipsync animation during TTS
    - Emotion-based expression changes
    - Voice activity detection integration
    - Real-time conversation interactions
    âŒ Expression loading and application
    âŒ Motion/expression state synchronization
    âŒ Motion blending and transitions
    âŒ Custom motion triggers and events
    
    ðŸ“‹ PHASE 7: ADVANCED LIVE2D FEATURES ðŸ”„ PLANNED
    âŒ Proper Live2D model rendering (not texture atlas)
    âŒ Model canvas sizing similar to Live2D Viewer Web
    âŒ Eye tracking and mouse following
    âŒ Breathing animation system
    âŒ Lip sync integration (if available)
    âŒ Physics simulation integration
    âŒ Custom shader effects
    âŒ Model switching animations
    âŒ Performance optimization
    âŒ Memory management and cleanup
    
    ðŸ“‹ PHASE 8: TESTING & VALIDATION ðŸ”„ PLANNED
    âœ… Basic diagnostics system
    âœ… Library validation and compatibility testing
    âœ… Syntax validation for all modules
    âŒ Comprehensive automated testing
    âŒ Performance benchmarking
    âŒ Cross-browser compatibility testing
    âŒ Mobile device support
    âŒ Error recovery and graceful degradation
    âŒ Memory leak detection and prevention
    âŒ Load testing with multiple models
    âŒ API endpoint testing and validation
    
    ðŸ“‹ PHASE 9: PRODUCTION FEATURES ðŸ”„ PLANNED
    âŒ Configuration management system enhancement
    âŒ Model caching and preloading
    âŒ Background loading and streaming
    âŒ Quality settings and performance modes
    âŒ Export functionality (screenshots, recordings)
    âŒ Analytics and usage tracking
    âŒ Accessibility features
    âŒ Internationalization support
    âŒ User preferences and settings persistence
    âŒ Keyboard shortcuts and hotkeys
    
    ðŸ“‹ PHASE 10: DYNAMIC MODEL LOADING & COMPRESSION ðŸ”„ PLANNED
    âŒ Live2D Viewer Web style model loading from multiple formats
    âŒ Support for ZIP compressed model files
    âŒ Support for JSON model definition files
    âŒ Support for MOC/MOC3 model files
    âŒ Support for CAN3 model files (current format)
    âŒ Automatic format detection and loading
    âŒ Model compression and space optimization
    âŒ Streaming model loading for large files
    âŒ Model caching and preloading system
    âŒ Model format converter utility
    âŒ Asset bundling and optimization
    âŒ Progressive model loading with fallbacks
    
    ðŸ“‹ PHASE 11: FLASK BACKEND INTEGRATION ðŸ”„ PLANNED
    âŒ Flask API endpoint verification and testing
    âŒ Model discovery API enhancement
    âŒ Motion/expression API endpoint completion
    âŒ WebSocket integration for real-time updates
    âŒ Model streaming and partial loading
    âŒ Asset optimization and compression
    âŒ CDN integration for model assets
    âŒ Database integration for model metadata
    
    =============================================================================
    CURRENT STATUS: Phase 4 Complete - Dual Architecture Implementation
    NEXT PRIORITY: Test dual architecture with actual model loading
    ARCHITECTURE ACHIEVEMENTS:
    - âœ… Dual Runtime Support Complete (Cubism 2.x + 3/4/5)
    - âœ… PIXI.js 6.5.10 with EventEmitter compatibility
    - âœ… Clean file organization in dist/ folder
    - âœ… Future-proof design with backward compatibility
    REMAINING WORK:
    - Fix Live2D model display to show actual models, not atlas maps
    - Test dual architecture with both .moc and .moc3 models
    - Panel toggle functionality needs fixing
    - Log panel visibility behavior needs work
    - API integration needs testing and validation
    =============================================================================
    -->
</head>
<body>
    <div class="app-container">
        <!-- Navigation Icons (Top Right) -->
        <nav class="nav-icons" id="navIcons">
            <button class="nav-icon" onclick="openChat()" title="Chat" data-tooltip="Chat">
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"/>
                </svg>
            </button>
            <button class="nav-icon" onclick="openPeople()" title="People" data-tooltip="People">
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                    <circle cx="9" cy="7" r="4"/>
                    <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                    <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                </svg>
            </button>
            <button class="nav-icon" onclick="openSettings()" title="Settings" data-tooltip="Settings">
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="3"/>
                    <path d="M12 1v6m0 6v6m11-7h-6m-6 0H1"/>
                </svg>
            </button>
            <div class="nav-divider"></div>
            <button class="nav-icon" onclick="toggleFullscreen()" title="Fullscreen" data-tooltip="Fullscreen">
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
                </svg>
            </button>
            <button class="nav-icon" onclick="toggleHelp()" title="Help" data-tooltip="Help">
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
                    <point cx="12" cy="17"/>
                </svg>
            </button>
        </nav>
        
        <!-- Chat Window -->
        <div class="chat-window" id="chatWindow">
            <div class="chat-header">
                <span class="chat-title">Chat</span>
                <div class="window-controls">
                    <button class="control-btn" onclick="toggleChatSnap()" title="Toggle Snap">ðŸ“Œ</button>
                    <button class="close-btn" onclick="closeChat()">Ã—</button>
                </div>
            </div>
            <div class="chat-content">
                <div class="chat-messages" id="chatMessages">
                    <!-- Chat messages will be populated here -->
                </div>
                <div class="chat-input-container">
                    <input type="text" class="chat-input" id="chatInput" placeholder="Type a message..." onkeypress="handleChatKeyPress(event)">
                    <button class="send-btn" onclick="sendMessage()">Send</button>
                </div>
            </div>
        </div>
        
        <!-- People Panel (Right Side) -->
        <div class="people-panel" id="peoplePanel">
            <div class="people-header">
                <span class="people-title">People</span>
                <div class="window-controls">
                    <button class="control-btn" onclick="togglePeopleSnap()" title="Toggle Snap">ðŸ“Œ</button>
                    <button class="close-btn" onclick="closePeople()">Ã—</button>
                </div>
            </div>
            <div class="people-content">
                <div class="people-models-list" id="peopleModelsList">
                    <!-- Model icons will be populated here vertically -->
                </div>
                <div class="people-controls">
                    <button class="add-model-btn" onclick="showAddModelDialog()" title="Add new model">
                        <span class="add-icon">+</span>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Settings Panel (Left Side Overlay) -->
        <div class="settings-panel" id="settingsPanel">
            <div class="settings-header">
                <span class="settings-title">Live2D Settings</span>
                <div class="window-controls">
                    <button class="control-btn" onclick="toggleSettingsSnap()" title="Toggle Snap">ðŸ“Œ</button>
                    <button class="close-btn" onclick="closeSettings()">Ã—</button>
                </div>
            </div>
            <div class="settings-content">
                <div class="settings-group">
                    <h4>Model Selection</h4>
                    <div class="setting-item">
                        <label for="modelSelect">Model:</label>
                        <select id="modelSelect" onchange="onModelChange()">
                            <option value="">Select a model...</option>
                        </select>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h4>Display Controls</h4>
                    <div class="setting-item">
                        <label for="zoomSlider">Scale: <span id="zoomValue">1.0</span></label>
                        <input type="range" id="zoomSlider" min="0.1" max="3.0" step="0.1" value="1.0" oninput="updateZoom(this.value); document.getElementById('zoomValue').textContent = this.value;">
                    </div>
                    <div class="setting-controls">
                        <button class="btn btn-secondary" onclick="resetZoom()">Reset</button>
                        <button class="btn btn-secondary" onclick="fitModel()">Fit</button>
                        <button class="btn btn-secondary" onclick="centerModel()">Center</button>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h4>Motions</h4>
                    <div class="setting-item">
                        <label for="motionGroupSelect">Motion Group:</label>
                        <select id="motionGroupSelect" onchange="onMotionGroupChange()">
                            <option value="">No motions available</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label for="motionSelect">Motion:</label>
                        <select id="motionSelect" onchange="onMotionTypeChange()">
                            <option value="">Select motion group first</option>
                        </select>
                    </div>
                    <div class="setting-controls">
                        <button class="btn btn-primary" onclick="playSelectedMotion()">Play Motion</button>
                        <button class="btn btn-secondary" onclick="playRandomMotion()">Random</button>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h4>Expressions</h4>
                    <div class="setting-item">
                        <label for="expressionSelect">Expression:</label>
                        <select id="expressionSelect" onchange="onExpressionChange()">
                            <option value="">No expressions available</option>
                        </select>
                    </div>
                    <div class="setting-controls">
                        <button class="btn btn-primary" onclick="playExpression()">Apply Expression</button>
                        <button class="btn btn-secondary" onclick="resetExpression()">Reset</button>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h4>Debug Options</h4>
                    <div class="setting-item">
                        <label>
                            <input type="checkbox" id="showCanvasFrame" checked onchange="toggleCanvasFrame()">
                            Show Canvas Frame
                        </label>
                    </div>
                    <div class="setting-item">
                        <label>
                            <input type="checkbox" id="showModelFrame" onchange="toggleModelFrame()">
                            Show Model Frame
                        </label>
                    </div>
                    <div class="setting-item">
                        <label>
                            <input type="checkbox" id="showHitAreas" onchange="toggleHitAreas()">
                            Show Hit Areas
                        </label>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h4>Actions</h4>
                    <div class="setting-controls">
                        <button class="btn btn-primary" onclick="testModel()">Test Model</button>
                        <button class="btn btn-warning" onclick="resetModel()">Reset</button>
                    </div>
                    <div class="setting-controls">
                        <button class="btn btn-info" onclick="debugWindowPositions()">Debug Positions</button>
                        <button class="btn btn-warning" onclick="resetWindowLayout()">Reset Layout</button>
                    </div>
                    <div class="setting-controls">
                        <button class="btn btn-info" onclick="rescueOffScreenWindows()">Rescue Windows</button>
                    </div>
                    <div class="setting-item">
                        <label style="font-size: 12px; color: #aaa; font-style: italic;">
                            Emergency shortcuts:<br>
                            Ctrl+Shift+R = Reset to defaults<br>
                            Ctrl+Shift+B = Rescue off-screen windows
                        </label>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Canvas Area -->
        <div class="canvas-container">
            <div class="canvas-frame">
                <div id="pixiContainer"></div>
            </div>
            <div class="loading-overlay" id="loadingOverlay" style="display: none;">
                <div class="loading-spinner"></div>
            </div>
        </div>
    </div>

<!-- Load PIXI.js and Live2D libraries in correct order -->
<!-- Step 1: Load PIXI.js 6.5.10 from dist folder -->
<script src="dist/pixi-6.5.10.min.js"></script>

<!-- Step 2: Load EventEmitter compatibility for PIXI v6 -->
<script src="js/eventemitter-preloader-v6.js"></script>

<!-- Step 3: Load Live2D v2 Bundle for Cubism 2.x models -->
<script src="dist/live2d_bundle.js"></script>

<!-- Step 4: Load Cubism 5 Core for modern models -->
<script src="dist/CubismSdkForWeb-5-r.4/Core/live2dcubismcore.min.js"></script>

<!-- Step 6: Verify dual architecture setup -->
<script>
console.log('=== Dual Architecture Verification ===');
console.log('PIXI version:', typeof PIXI !== 'undefined' ? PIXI.VERSION : 'Not loaded');
console.log('EventEmitter available:', typeof EventEmitter !== 'undefined');
console.log('Live2D v2 Bundle loaded:', typeof window.Live2D !== 'undefined');
console.log('Cubism 5 Core loaded:', typeof window.Live2DCubismCore !== 'undefined');

// Debug Live2D v2 Bundle
if (typeof window.Live2D !== 'undefined') {
    console.log('âœ“ Live2D v2 Bundle ready for Cubism 2.x models');
    console.log('- window.Live2D:', typeof window.Live2D);
    console.log('- window.Live2DModelWebGL:', typeof window.Live2DModelWebGL);
    console.log('- window.live2dv2:', typeof window.live2dv2);
}

// Debug Cubism 5 Core
if (typeof window.Live2DCubismCore !== 'undefined') {
    console.log('âœ“ Cubism 5 Core ready for modern models');
    console.log('- Core version:', window.Live2DCubismCore.Version ? window.Live2DCubismCore.Version.csmGetVersion() : 'unknown');
}

console.log('=== End Verification ===');
</script>

<!-- Step 5: Load pixi-live2d-display -->
<script src="https://cdn.jsdelivr.net/npm/pixi-live2d-display@0.4.0/dist/index.min.js"></script>

<!-- Step 5: Verify Live2D plugin initialization -->
<script>
// Initialize Live2D plugin following Live2D Viewer Web pattern
console.log('Initializing Live2D plugin (Live2D Viewer Web compatible)...');

// Wait for all scripts to load
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(function() {
        console.log('Checking library compatibility...');
        
        // Verify libraries are loaded
        if (typeof PIXI === 'undefined') {
            console.error('PIXI.js not loaded');
            return;
        }
        
        if (typeof EventEmitter === 'undefined') {
            console.error('EventEmitter not available');
            return;
        }
        
        console.log('âœ“ PIXI version:', PIXI.VERSION);
        console.log('âœ“ EventEmitter type:', typeof EventEmitter);
        
        // Check if PIXI.utils.EventEmitter exists (Live2D Viewer Web pattern)
        if (PIXI.utils && PIXI.utils.EventEmitter) {
            console.log('âœ“ PIXI.utils.EventEmitter available (Live2D Viewer Web compatible)');
        }
        
        // Check if Live2D plugin is available
        if (typeof PIXI.live2d === 'undefined') {
            console.error('âœ— PIXI.live2d not loaded - pixi-live2d-display may not be compatible');
            console.log('Available PIXI properties:', Object.keys(PIXI));
            
            // Try to diagnose the issue
            if (window.pixiLive2DLoadError) {
                console.error('Library loading error detected - check network tab');
            }
        } else {
            console.log('âœ“ PIXI.live2d loaded successfully');
            console.log('Available PIXI.live2d properties:', Object.keys(PIXI.live2d));
            
            // Check for Live2DModel
            if (PIXI.live2d.Live2DModel) {
                console.log('âœ“ Live2DModel class available');
                window.Live2DModel = PIXI.live2d.Live2DModel;
                
                // Test if it has the expected methods
                if (typeof PIXI.live2d.Live2DModel.from === 'function') {
                    console.log('âœ“ Live2DModel.from() method available');
                } else {
                    console.warn('Live2DModel.from() method not found');
                }
            } else {
                console.warn('Live2DModel not found in PIXI.live2d');
            }
            
            // Check for Live2DFactory
            if (PIXI.live2d.Live2DFactory) {
                console.log('âœ“ Live2DFactory available');
                window.Live2DFactory = PIXI.live2d.Live2DFactory;
            } else {
                console.warn('Live2DFactory not found in PIXI.live2d');
            }
        }
        
        console.log('Live2D plugin initialization check complete');
        console.log('System ready for Live2D model loading');
        
    }, 500); // Increased delay to ensure all libraries are loaded
});
</script>

<!-- Step 5: Load Live2D modular system -->
<script src="js/live2d_config.js"></script>
<script src="js/live2d_logger.js"></script>
<script src="js/live2d_tester.js"></script>
<script src="js/live2d_interaction.js"></script>
<script src="js/live2d_core.js"></script>
<script src="js/live2d_model_manager.js"></script>
<script src="js/live2d_multi_model_manager.js"></script>
<script src="js/live2d_motion_manager.js"></script>
<script src="js/live2d_integration.js"></script>
<script src="js/live2d_ui_controller.js"></script>
<script src="js/live2d_simple_fix.js"></script>

<script>
// Global variables for the modular system
let live2dIntegration = null;
let uiController = null;
let live2dMultiModelManager = null; // Make available globally for remove buttons

// Initialize the modular Live2D system
async function initializeLive2D() {
    try {
        console.log('Initializing Live2D modular system...');
        
        // Create integration instance
        live2dIntegration = new Live2DIntegration();
        
        // Initialize integration (canvas container)
        const success = await live2dIntegration.initialize('pixiContainer');
        
        if (!success) {
            throw new Error('Failed to initialize Live2D integration');
        }
        
        // Create UI controller
        uiController = new Live2DUIController(live2dIntegration);
        
        // Initialize UI controller
        await uiController.initialize();
        
        // Store reference to multi-model manager for global access
        live2dMultiModelManager = live2dIntegration.modelManager;
        
        // Set up connection between multi-model manager and UI controller
        live2dMultiModelManager.setUIController(uiController);
        
        console.log('Live2D system initialized successfully!');
        
    } catch (error) {
        console.error('Failed to initialize Live2D system:', error);
    }
}

// Debug function to show current window positions
function debugWindowPositions() {
    const chatWindow = document.getElementById('chatWindow');
    const peoplePanel = document.getElementById('peoplePanel');
    const settingsPanel = document.getElementById('settingsPanel');
    
    console.log('=== Window Positions Debug ===');
    console.log('Chat Window:', {
        rect: chatWindow.getBoundingClientRect(),
        style: { left: chatWindow.style.left, top: chatWindow.style.top, transform: chatWindow.style.transform },
        computed: window.getComputedStyle(chatWindow).transform
    });
    console.log('People Panel:', {
        rect: peoplePanel.getBoundingClientRect(),
        style: { left: peoplePanel.style.left, top: peoplePanel.style.top, transform: peoplePanel.style.transform },
        computed: window.getComputedStyle(peoplePanel).transform
    });
    console.log('Settings Panel:', {
        rect: settingsPanel.getBoundingClientRect(),
        style: { left: settingsPanel.style.left, top: settingsPanel.style.top, transform: settingsPanel.style.transform },
        computed: window.getComputedStyle(settingsPanel).transform
    });
    console.log('Saved Layout:', JSON.parse(localStorage.getItem(LAYOUT_STORAGE_KEY) || '{}'));
    console.log('==============================');
}

function onModelChange() {
    console.log('onModelChange called');
    if (uiController) {
        const modelName = document.getElementById('modelSelect').value;
        uiController.onModelChange(modelName);
    } else {
        console.error('uiController not available');
    }
}

function updateZoom(value) {
    if (live2dIntegration && live2dIntegration.core && live2dIntegration.core.interactionManager) {
        live2dIntegration.core.interactionManager.setZoom(parseFloat(value));
    }
}

function resetZoom() {
    if (live2dIntegration && live2dIntegration.core && live2dIntegration.core.interactionManager) {
        live2dIntegration.core.interactionManager.resetZoom();
        // Update slider
        const slider = document.getElementById('zoomSlider');
        if (slider) slider.value = 1.0;
        // Update display
        const display = document.getElementById('zoomValue');
        if (display) display.textContent = '1.0';
    }
}

function fitModel() {
    if (live2dIntegration && live2dIntegration.core && live2dIntegration.core.interactionManager) {
        live2dIntegration.core.interactionManager.fitModelToCanvas();
    }
}

function centerModel() {
    if (live2dIntegration && live2dIntegration.core && live2dIntegration.core.interactionManager) {
        live2dIntegration.core.interactionManager.centerModel();
    }
}

function onMotionGroupChange() {
    if (uiController) {
        const group = document.getElementById('motionGroupSelect').value;
        uiController.onMotionGroupChange(group);
    }
}

function onMotionTypeChange() {
    if (uiController) {
        const motion = document.getElementById('motionSelect').value;
        uiController.onMotionTypeChange(motion);
    }
}

function playSelectedMotion() {
    if (uiController) uiController.playSelectedMotion();
}

function playRandomMotion() {
    if (uiController) uiController.playRandomMotion();
}

function onExpressionChange() {
    if (uiController) {
        const expression = document.getElementById('expressionSelect').value;
        uiController.onExpressionChange(expression);
    }
}

function playExpression() {
    if (uiController) uiController.playExpression();
}

function resetExpression() {
    if (uiController) uiController.resetExpression();
}

function testModel() {
    if (uiController) uiController.testModel();
}

function resetModel() {
    console.log('resetModel called');
    if (uiController) {
        uiController.resetModel();
    } else {
        console.error('uiController not available');
    }
}

function toggleSettings() {
    console.log('toggleSettings called');
    if (uiController) {
        uiController.toggleSettings();
    } else if (window.toggleSettingsPanel) {
        window.toggleSettingsPanel();
    } else {
        console.error('uiController and toggleSettingsPanel not available');
    }
}

function debugModel() {
    console.log('debugModel called');
    if (uiController) {
        uiController.debugModel();
    } else {
        console.error('uiController not available');
    }
}

function toggleCanvasFrame() {
    if (uiController) uiController.toggleCanvasFrame();
}

function toggleModelFrame() {
    if (uiController) uiController.toggleModelFrame();
}

function toggleHitAreas() {
    if (uiController) uiController.toggleHitAreas();
}

function toggleDebugMode() {
    if (uiController) uiController.toggleDebugMode();
}

function toggleFPS() {
    if (uiController) uiController.toggleFPS();
}

function toggleMouseLogging() {
    if (uiController) uiController.toggleMouseLogging();
}

function changeRenderQuality() {
    if (uiController) uiController.changeRenderQuality();
}

function toggleAntialiasing() {
    if (uiController) uiController.toggleAntialiasing();
}

function showModelInfo() {
    if (live2dIntegration) {
        live2dIntegration.debugModelBounds();
        live2dIntegration.core.debugModelVisibility();
    }
}

// Global state
let chatOpen = false;
let peopleOpen = false;
let settingsOpen = false;
let chatSnapped = false;
let peopleSnapped = false;
let settingsSnapped = false;

// Draggable functionality
let isDragging = false;
let currentDragElement = null;
let dragOffset = { x: 0, y: 0 };

// Window Layout Persistence System
const LAYOUT_STORAGE_KEY = 'ai-companion-window-layout';

// Default window layouts
const DEFAULT_LAYOUTS = {
    chatWindow: {
        position: { x: 'center', y: 'bottom' },
        size: { width: 400, height: 400 },
        snapped: false,
        snapPosition: 'bottom',
        open: false
    },
    peoplePanel: {
        position: { x: 'right-20', y: 'top-80' },
        size: { width: 200, height: 'auto' },
        snapped: false,
        snapPosition: 'right',
        open: false
    },
    settingsPanel: {
        position: { x: 'left-20', y: 'top-20' },
        size: { width: 350, height: 'auto' },
        snapped: false,
        snapPosition: 'left',
        open: false
    }
};

// Save window layout to localStorage
function saveWindowLayout() {
    const layout = {
        chatWindow: {
            position: getElementPosition('chatWindow'),
            size: getElementSize('chatWindow'),
            snapped: chatSnapped,
            snapPosition: getChatSnapPosition(),
            open: chatOpen
        },
        peoplePanel: {
            position: getElementPosition('peoplePanel'),
            size: getElementSize('peoplePanel'),
            snapped: peopleSnapped,
            snapPosition: getPeopleSnapPosition(),
            open: peopleOpen
        },
        settingsPanel: {
            position: getElementPosition('settingsPanel'),
            size: getElementSize('settingsPanel'),
            snapped: settingsSnapped,
            snapPosition: getSettingsSnapPosition(),
            open: settingsOpen
        }
    };
    
    // Validate positions to prevent off-screen windows
    layout.chatWindow.position = validatePosition(layout.chatWindow.position);
    layout.peoplePanel.position = validatePosition(layout.peoplePanel.position);
    layout.settingsPanel.position = validatePosition(layout.settingsPanel.position);
    
    localStorage.setItem(LAYOUT_STORAGE_KEY, JSON.stringify(layout));
}

// Validate that positions are within viewport bounds
function validatePosition(position) {
    const maxX = window.innerWidth - 200; // Minimum 200px visible
    const maxY = window.innerHeight - 100; // Minimum 100px visible
    
    return {
        x: Math.max(0, Math.min(position.x, maxX)),
        y: Math.max(0, Math.min(position.y, maxY))
    };
}

// Reset all windows to default positions
function resetWindowLayout() {
    console.log('Resetting window layout to defaults');
    localStorage.removeItem(LAYOUT_STORAGE_KEY);
    
    // Immediately apply default layouts instead of reloading
    applyDefaultLayout();
}

// Apply default layout immediately
function applyDefaultLayout() {
    console.log('Applying default window layout');
    
    // Reset all windows to default positions
    const chatWindow = document.getElementById('chatWindow');
    const peoplePanel = document.getElementById('peoplePanel');
    const settingsPanel = document.getElementById('settingsPanel');
    
    if (chatWindow) {
        // Reset chat window
        chatWindow.style.left = '';
        chatWindow.style.right = '';
        chatWindow.style.top = '';
        chatWindow.style.bottom = '';
        chatWindow.style.transform = '';
        chatWindow.style.position = 'fixed';
        chatWindow.classList.remove('pinned');
        chatWindow.classList.add('open'); /* Add open class for default visibility */
        
        // Apply default CSS positioning - Show the chat window in default position
        chatWindow.style.bottom = '10px'; /* Bottom edge 10px from bottom window edge */
        chatWindow.style.left = '50%';
        chatWindow.style.transform = 'translateX(-50%) translateY(0)'; /* Show chat window in default position */
        chatWindow.style.width = '50%'; /* Use responsive width from CSS */
        chatWindow.style.height = '30%'; /* Use responsive height from CSS - updated to 30% */
        
        // Reset pin button
        const chatPinButton = chatWindow.querySelector('.control-btn[onclick="toggleChatSnap()"]');
        if (chatPinButton) chatPinButton.classList.remove('pinned');
        
        chatOpen = true; /* Panel is visible in default position */
        chatSnapped = false;
    }
    
    if (peoplePanel) {
        // Reset people panel
        peoplePanel.style.left = '';
        peoplePanel.style.right = '';
        peoplePanel.style.top = '';
        peoplePanel.style.bottom = '';
        peoplePanel.style.transform = '';
        peoplePanel.style.position = 'fixed';
        peoplePanel.classList.remove('pinned');
        peoplePanel.classList.add('open'); /* Add open class for default visibility */
        
        // Apply default CSS positioning - Show the panel in default position
        peoplePanel.style.top = '80px';
        peoplePanel.style.right = '20px'; /* Right edge 20px from right window edge */
        peoplePanel.style.transform = 'translateX(0)'; /* Show panel in default position */
        peoplePanel.style.width = '200px';
        
        // Reset pin button
        const peoplePinButton = peoplePanel.querySelector('.control-btn[onclick="togglePeopleSnap()"]');
        if (peoplePinButton) peoplePinButton.classList.remove('pinned');
        
        peopleOpen = true; /* Panel is visible in default position */
        peopleSnapped = false;
    }
    
    if (settingsPanel) {
        // Reset settings panel
        settingsPanel.style.left = '';
        settingsPanel.style.right = '';
        settingsPanel.style.top = '';
        settingsPanel.style.bottom = '';
        settingsPanel.style.transform = '';
        settingsPanel.style.position = 'fixed';
        settingsPanel.classList.remove('pinned');
        settingsPanel.classList.remove('open'); /* Settings should start closed */
        
        // Apply default CSS positioning - Hide the panel initially
        settingsPanel.style.top = '20px';
        settingsPanel.style.left = '20px';
        settingsPanel.style.transform = 'translateX(-100%)'; /* Hide panel initially */
        settingsPanel.style.width = '350px';
        
        // Reset pin button
        const settingsPinButton = settingsPanel.querySelector('.control-btn[onclick="toggleSettingsSnap()"]');
        if (settingsPinButton) settingsPinButton.classList.remove('pinned');
        
        settingsOpen = false; /* Panel is hidden by default */
        settingsSnapped = false;
    }
    
    updateNavIconStates();
    console.log('Default layout applied');
}

// Load window layout from localStorage
function loadWindowLayout() {
    try {
        const savedLayout = localStorage.getItem(LAYOUT_STORAGE_KEY);
        if (!savedLayout) {
            console.log('No saved layout found, using defaults');
            return DEFAULT_LAYOUTS;
        }
        
        const layout = JSON.parse(savedLayout);
        console.log('Window layout loaded:', layout);
        return layout;
    } catch (error) {
        console.error('Error loading window layout:', error);
        return DEFAULT_LAYOUTS;
    }
}

// Apply saved layout to windows
function applyWindowLayout(layout) {
    // Apply chat window layout
    if (layout.chatWindow) {
        const chatWindow = document.getElementById('chatWindow');
        if (chatWindow) {
            applyElementLayout(chatWindow, layout.chatWindow);
            chatOpen = layout.chatWindow.open;
            chatSnapped = layout.chatWindow.snapped;
            if (chatOpen) {
                chatWindow.classList.add('open');
            }
            if (chatSnapped) {
                chatWindow.classList.add('pinned'); // Add visual indicator
                const pinButton = chatWindow.querySelector('.control-btn[onclick="toggleChatSnap()"]');
                if (pinButton) pinButton.classList.add('pinned');
            }
        }
    }
    
    // Apply people panel layout
    if (layout.peoplePanel) {
        const peoplePanel = document.getElementById('peoplePanel');
        if (peoplePanel) {
            applyElementLayout(peoplePanel, layout.peoplePanel);
            peopleOpen = layout.peoplePanel.open;
            peopleSnapped = layout.peoplePanel.snapped;
            if (peopleOpen) {
                peoplePanel.classList.add('open');
            }
            if (peopleSnapped) {
                peoplePanel.classList.add('pinned'); // Add visual indicator
                const pinButton = peoplePanel.querySelector('.control-btn[onclick="togglePeopleSnap()"]');
                if (pinButton) pinButton.classList.add('pinned');
            }
        }
    }
    
    // Apply settings panel layout
    if (layout.settingsPanel) {
        const settingsPanel = document.getElementById('settingsPanel');
        if (settingsPanel) {
            applyElementLayout(settingsPanel, layout.settingsPanel);
            settingsOpen = layout.settingsPanel.open;
            settingsSnapped = layout.settingsPanel.snapped;
            if (settingsOpen) {
                settingsPanel.classList.add('open');
            }
            if (settingsSnapped) {
                settingsPanel.classList.add('pinned'); // Add visual indicator
                const pinButton = settingsPanel.querySelector('.control-btn[onclick="toggleSettingsSnap()"]');
                if (pinButton) pinButton.classList.add('pinned');
            }
        }
    }
    
    updateNavIconStates();
}

// Helper functions for layout management
function getElementPosition(elementId) {
    const element = document.getElementById(elementId);
    if (!element) return { x: 0, y: 0 };
    
    // Get computed style to check for transforms
    const computedStyle = window.getComputedStyle(element);
    const rect = element.getBoundingClientRect();
    
    // If element has been positioned manually, use the style values
    if (element.style.left && element.style.left !== '') {
        const left = parseInt(element.style.left.replace('px', ''));
        const top = parseInt(element.style.top ? element.style.top.replace('px', '') : '0');
        return { x: left, y: top };
    }
    
    // Otherwise use bounding rect, but account for potential issues
    return {
        x: Math.max(0, rect.left),
        y: Math.max(0, rect.top)
    };
}

function getElementSize(elementId) {
    const element = document.getElementById(elementId);
    if (!element) return { width: 0, height: 0 };
    
    return {
        width: element.offsetWidth,
        height: element.offsetHeight
    };
}

function applyElementLayout(element, layout) {
    // CRITICAL FIX: Reset all positioning properties to prevent cumulative drift
    element.style.left = '';
    element.style.right = '';
    element.style.top = '';
    element.style.bottom = '';
    element.style.transform = '';
    element.style.position = 'fixed';
    
    if (layout.position) {
        // Apply position with absolute values only
        if (typeof layout.position.x === 'string') {
            if (layout.position.x === 'center') {
                element.style.left = '50%';
                element.style.transform = 'translateX(-50%)';
            } else if (layout.position.x.includes('left-')) {
                element.style.left = layout.position.x.replace('left-', '') + 'px';
            } else if (layout.position.x.includes('right-')) {
                element.style.right = layout.position.x.replace('right-', '') + 'px';
            }
        } else {
            // Always use absolute pixel positioning to prevent drift
            element.style.left = Math.max(0, layout.position.x) + 'px';
        }
        
        if (typeof layout.position.y === 'string') {
            if (layout.position.y.includes('top-')) {
                element.style.top = layout.position.y.replace('top-', '') + 'px';
            } else if (layout.position.y.includes('bottom-')) {
                element.style.bottom = layout.position.y.replace('bottom-', '') + 'px';
            }
        } else {
            // Always use absolute pixel positioning to prevent drift
            element.style.top = Math.max(0, layout.position.y) + 'px';
        }
    }
    
    if (layout.size) {
        // Apply size
        if (layout.size.width !== 'auto') {
            element.style.width = layout.size.width + 'px';
        }
        if (layout.size.height !== 'auto') {
            element.style.height = layout.size.height + 'px';
        }
    }
}

function getChatSnapPosition() {
    const chatWindow = document.getElementById('chatWindow');
    if (chatWindow.classList.contains('snapped-left')) return 'left';
    if (chatWindow.classList.contains('snapped-right')) return 'right';
    if (chatWindow.classList.contains('snapped-bottom')) return 'bottom';
    return 'bottom';
}

function getPeopleSnapPosition() {
    const peoplePanel = document.getElementById('peoplePanel');
    if (peoplePanel.classList.contains('snapped-left')) return 'left';
    if (peoplePanel.classList.contains('snapped-right')) return 'right';
    return 'right';
}

function getSettingsSnapPosition() {
    const settingsPanel = document.getElementById('settingsPanel');
    if (settingsPanel.classList.contains('snapped-left')) return 'left';
    if (settingsPanel.classList.contains('snapped-right')) return 'right';
    return 'left';
}

// Clear saved layout (for debugging)
function clearSavedLayout() {
    localStorage.removeItem(LAYOUT_STORAGE_KEY);
    console.log('Saved layout cleared');
}

// Add emergency reset functionality for off-screen windows
document.addEventListener('keydown', function(e) {
    // Ctrl+Shift+R to reset window layout
    if (e.ctrlKey && e.shiftKey && e.key === 'R') {
        e.preventDefault();
        console.log('Emergency layout reset triggered');
        resetWindowLayout();
    }
    
    // Ctrl+Shift+B to bring all windows back into view (rescue mode)
    if (e.ctrlKey && e.shiftKey && e.key === 'B') {
        e.preventDefault();
        console.log('Emergency rescue mode triggered');
        rescueOffScreenWindows();
    }
});

// Emergency function to bring off-screen windows back into view
function rescueOffScreenWindows() {
    console.log('Rescuing off-screen windows...');
    
    const windows = [
        { element: document.getElementById('chatWindow'), name: 'Chat' },
        { element: document.getElementById('peoplePanel'), name: 'People' },
        { element: document.getElementById('settingsPanel'), name: 'Settings' }
    ];
    
    windows.forEach(({ element, name }) => {
        if (!element) return;
        
        const rect = element.getBoundingClientRect();
        const isOffScreen = rect.left < 0 || rect.top < 0 || 
                           rect.right > window.innerWidth || 
                           rect.bottom > window.innerHeight;
        
        if (isOffScreen) {
            console.log(`Rescuing ${name} window from off-screen position`);
            
            // Reset positioning and place in safe area
            element.style.left = '';
            element.style.right = '';
            element.style.top = '';
            element.style.bottom = '';
            element.style.transform = '';
            element.style.position = 'fixed';
            
            // Place in center-ish safe area
            const safeX = Math.max(20, Math.min(window.innerWidth - 300, 100));
            const safeY = Math.max(20, Math.min(window.innerHeight - 200, 100));
            
            element.style.left = safeX + 'px';
            element.style.top = safeY + 'px';
            
            // Make sure it's visible
            element.classList.add('open');
            if (name === 'Chat') chatOpen = true;
            if (name === 'People') peopleOpen = true;
            if (name === 'Settings') settingsOpen = true;
        }
    });
    
    updateNavIconStates();
    saveWindowLayout(); // Save the rescued positions
    console.log('Window rescue complete');
}

// Navigation functions
function updateNavIconStates() {
    const navIcons = document.querySelectorAll('.nav-icon');
    navIcons.forEach(icon => {
        icon.classList.remove('active');
    });
    
    if (chatOpen) {
        const chatIcon = document.querySelector('.nav-icon[onclick="openChat()"]');
        if (chatIcon) chatIcon.classList.add('active');
    }
    
    if (peopleOpen) {
        const peopleIcon = document.querySelector('.nav-icon[onclick="openPeople()"]');
        if (peopleIcon) peopleIcon.classList.add('active');
    }
    
    if (settingsOpen) {
        const settingsIcon = document.querySelector('.nav-icon[onclick="openSettings()"]');
        if (settingsIcon) settingsIcon.classList.add('active');
    }
}

// Chat functions
function openChat() {
    // Toggle chat window
    chatOpen = !chatOpen;
    const chatWindow = document.getElementById('chatWindow');
    
    if (chatOpen) {
        chatWindow.classList.add('open');
    } else {
        chatWindow.classList.remove('open');
    }
    
    updateNavIconStates();
    saveWindowLayout(); // Save layout when window opens/closes
}

function showChat() {
    // Only open chat window, don't toggle
    if (!chatOpen) {
        chatOpen = true;
        const chatWindow = document.getElementById('chatWindow');
        chatWindow.classList.add('open');
        updateNavIconStates();
        saveWindowLayout();
    }
}

function closeChat() {
    chatOpen = false;
    const chatWindow = document.getElementById('chatWindow');
    chatWindow.classList.remove('open');
    updateNavIconStates();
    saveWindowLayout(); // Save layout when window closes
}

function toggleChatSnap() {
    const chatWindow = document.getElementById('chatWindow');
    const pinButton = chatWindow.querySelector('.control-btn[onclick="toggleChatSnap()"]');
    chatSnapped = !chatSnapped;
    
    if (chatSnapped) {
        // Pin the window in its current position instead of snapping to bottom
        chatWindow.style.position = 'fixed';
        chatWindow.style.transform = 'none'; // Remove any transform
        chatWindow.classList.add('pinned'); // Add visual indicator
        if (pinButton) pinButton.classList.add('pinned');
    } else {
        // Unpin the window
        chatWindow.style.position = 'fixed';
        chatWindow.classList.remove('pinned'); // Remove visual indicator
        if (pinButton) pinButton.classList.remove('pinned');
    }
    
    // Save layout when snap state changes
    saveWindowLayout();
}

// People functions
function openPeople() {
    // Toggle people panel
    peopleOpen = !peopleOpen;
    const peoplePanel = document.getElementById('peoplePanel');
    
    if (peopleOpen) {
        peoplePanel.classList.add('open');
        populatePeopleModels();
    } else {
        peoplePanel.classList.remove('open');
    }
    
    updateNavIconStates();
    saveWindowLayout(); // Save layout when window opens/closes
}

function showPeople() {
    // Only open people panel, don't toggle
    if (!peopleOpen) {
        peopleOpen = true;
        const peoplePanel = document.getElementById('peoplePanel');
        peoplePanel.classList.add('open');
        populatePeopleModels();
        updateNavIconStates();
        saveWindowLayout();
    }
}

function closePeople() {
    peopleOpen = false;
    const peoplePanel = document.getElementById('peoplePanel');
    peoplePanel.classList.remove('open');
    updateNavIconStates();
    saveWindowLayout(); // Save layout when window closes
}

function togglePeopleSnap() {
    const peoplePanel = document.getElementById('peoplePanel');
    const pinButton = peoplePanel.querySelector('.control-btn[onclick="togglePeopleSnap()"]');
    peopleSnapped = !peopleSnapped;
    
    if (peopleSnapped) {
        // Pin the window in its current position
        peoplePanel.style.position = 'fixed';
        peoplePanel.classList.add('pinned'); // Add visual indicator
        if (pinButton) pinButton.classList.add('pinned');
    } else {
        // Unpin the window
        peoplePanel.style.position = 'fixed';
        peoplePanel.classList.remove('pinned'); // Remove visual indicator
        if (pinButton) pinButton.classList.remove('pinned');
    }
    
    // Save layout when snap state changes
    saveWindowLayout();
}

// Settings functions
function openSettings() {
    // Toggle settings panel
    settingsOpen = !settingsOpen;
    const settingsPanel = document.getElementById('settingsPanel');
    
    if (settingsOpen) {
        settingsPanel.classList.add('open');
    } else {
        settingsPanel.classList.remove('open');
    }
    
    updateNavIconStates();
    saveWindowLayout(); // Save layout when window opens/closes
}

function showSettings() {
    // Only open settings panel, don't toggle
    if (!settingsOpen) {
        settingsOpen = true;
        const settingsPanel = document.getElementById('settingsPanel');
        settingsPanel.classList.add('open');
        updateNavIconStates();
        saveWindowLayout();
    }
}

function closeSettings() {
    settingsOpen = false;
    const settingsPanel = document.getElementById('settingsPanel');
    settingsPanel.classList.remove('open');
    updateNavIconStates();
    saveWindowLayout(); // Save layout when window closes
}

function toggleSettingsSnap() {
    const settingsPanel = document.getElementById('settingsPanel');
    const pinButton = settingsPanel.querySelector('.control-btn[onclick="toggleSettingsSnap()"]');
    settingsSnapped = !settingsSnapped;
    
    if (settingsSnapped) {
        // Pin the window in its current position
        settingsPanel.style.position = 'fixed';
        settingsPanel.classList.add('pinned'); // Add visual indicator
        if (pinButton) pinButton.classList.add('pinned');
    } else {
        // Unpin the window
        settingsPanel.style.position = 'fixed';
        settingsPanel.classList.remove('pinned'); // Remove visual indicator
        if (pinButton) pinButton.classList.remove('pinned');
    }
    
    // Save layout when snap state changes
    saveWindowLayout();
}

// Additional navigation functions
function toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
    }
}

function toggleHelp() {
    // Show help modal or tooltip
    console.log('Help functionality - to be implemented');
    // This could open a help panel or show keyboard shortcuts
}

// People panel functionality
function populatePeopleModels() {
    const modelsList = document.getElementById('peopleModelsList');
    
    // Clear existing models
    modelsList.innerHTML = '';
    
    // This would normally get models from the multi-model manager
    // For now, we'll simulate some models
    const models = [
        { id: 'miku_2', name: 'Miku 2', emoji: 'ðŸŽ¤', active: true },
        { id: 'example_model', name: 'Example', emoji: 'ðŸ‘‹', active: false }
    ];
    
    models.forEach(model => {
        const modelItem = document.createElement('div');
        modelItem.className = `people-model-item ${model.active ? 'active' : ''}`;
        modelItem.innerHTML = `
            <div class="people-model-avatar">${model.emoji}</div>
            <div class="people-model-info">
                <div class="people-model-name">${model.name}</div>
                <div class="people-model-status">${model.active ? 'Active' : 'Inactive'}</div>
            </div>
            <button class="people-model-remove" onclick="removeModel('${model.id}')">Ã—</button>
        `;
        
        modelItem.addEventListener('click', (e) => {
            if (!e.target.classList.contains('people-model-remove')) {
                selectModel(model.id);
            }
        });
        
        modelsList.appendChild(modelItem);
    });
}

function selectModel(modelId) {
    // Update active model
    document.querySelectorAll('.people-model-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Set the clicked model as active
    event.currentTarget.classList.add('active');
    
    // Update model name in settings
    const modelSelect = document.getElementById('modelSelect');
    if (modelSelect) {
        modelSelect.value = modelId;
        onModelChange();
    }
}

function removeModel(modelId) {
    // Remove model from multi-model manager
    if (live2dMultiModelManager) {
        live2dMultiModelManager.removeModel(modelId);
    }
    
    // Refresh the people panel
    populatePeopleModels();
}

function showAddModelDialog() {
    // This would show the model selection dialog
    // For now, just log
    console.log('Show add model dialog');
}

// Draggable functionality
function initializeDraggable() {
    const draggableElements = [
        { element: document.getElementById('chatWindow'), header: '.chat-header' },
        { element: document.getElementById('peoplePanel'), header: '.people-header' },
        { element: document.getElementById('settingsPanel'), header: '.settings-header' }
    ];
    
    draggableElements.forEach(({ element, header }) => {
        const headerElement = element.querySelector(header);
        if (headerElement) {
            headerElement.addEventListener('mousedown', (e) => startDrag(e, element));
        }
    });
    
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', stopDrag);
}

function startDrag(e, element) {
    // Check if the element is pinned and prevent dragging
    const pinButton = element.querySelector('.control-btn[onclick*="Snap"]');
    const isPinned = pinButton && pinButton.classList.contains('pinned');
    
    if (isPinned) {
        return; // Don't allow dragging if pinned
    }
    
    isDragging = true;
    currentDragElement = element;
    
    const rect = element.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;
    
    element.style.zIndex = '300';
    document.body.style.cursor = 'move';
}

function drag(e) {
    if (!isDragging || !currentDragElement) return;
    
    const x = e.clientX - dragOffset.x;
    const y = e.clientY - dragOffset.y;
    
    // Constrain to viewport
    const maxX = window.innerWidth - currentDragElement.offsetWidth;
    const maxY = window.innerHeight - currentDragElement.offsetHeight;
    
    const constrainedX = Math.max(0, Math.min(x, maxX));
    const constrainedY = Math.max(0, Math.min(y, maxY));
    
    currentDragElement.style.left = constrainedX + 'px';
    currentDragElement.style.top = constrainedY + 'px';
    currentDragElement.style.right = 'auto';
    currentDragElement.style.bottom = 'auto';
    currentDragElement.style.transform = 'none';
}

function stopDrag() {
    if (isDragging) {
        isDragging = false;
        if (currentDragElement) {
            currentDragElement.style.zIndex = '200';
        }
        currentDragElement = null;
        document.body.style.cursor = 'default';
        
        // Save layout when dragging stops
        saveWindowLayout();
    }
}

// Chat functionality
function handleChatKeyPress(event) {
    if (event.key === 'Enter') {
        sendMessage();
    }
}

function sendMessage() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();
    
    if (message) {
        // Add message to chat
        addMessageToChat('user', message);
        input.value = '';
        
        // TODO: Send to AI backend
        // For now, just add a placeholder response
        setTimeout(() => {
            addMessageToChat('ai', 'I received your message: ' + message);
        }, 1000);
    }
}

function addMessageToChat(sender, message) {
    const messagesContainer = document.getElementById('chatMessages');
    const messageElement = document.createElement('div');
    messageElement.className = `chat-message ${sender}`;
    messageElement.innerHTML = `
        <div class="message-content">${message}</div>
        <div class="message-time">${new Date().toLocaleTimeString()}</div>
    `;
    messagesContainer.appendChild(messageElement);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    // Load and apply saved window layout
    const savedLayout = loadWindowLayout();
    applyWindowLayout(savedLayout);
    
    // Initialize draggable functionality
    initializeDraggable();
    
    // Initialize navigation states
    updateNavIconStates();
    
    // Wait for all libraries to load properly
    setTimeout(async function() {
        console.log('Libraries loaded, checking availability...');
        
        // Check library availability
        if (typeof PIXI === 'undefined') {
            console.error('PIXI.js not loaded');
            return;
        }
        
        if (typeof EventEmitter === 'undefined') {
            console.error('EventEmitter not available');
            return;
        }
        
        console.log('PIXI version:', PIXI.VERSION);
        console.log('EventEmitter available:', typeof EventEmitter !== 'undefined');
        
        // Initialize the Live2D system
        await initializeLive2D();
    }, 1000); // Increased delay to ensure libraries are loaded
});

// Save layout on window resize and before page unload
window.addEventListener('resize', function() {
    // Debounce resize events to avoid excessive saves
    clearTimeout(window.resizeTimeout);
    window.resizeTimeout = setTimeout(saveWindowLayout, 500);
});

window.addEventListener('beforeunload', function() {
    saveWindowLayout();
});

</script>
</body>
</html>
