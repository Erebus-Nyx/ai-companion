<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live2D AI Companion - Dual Architecture Testing Interface</title>
    <link rel="stylesheet" href="/static/css/live2d_test.css">
</head>
    
    <!-- Live2D AI Companion - Production-ready avatar system with dual runtime support -->
</head>
<body>
    <div class="app-container">
        <!-- Navigation Icons (Top Right) -->
        <nav class="nav-icons" id="navIcons">
            <button class="nav-icon" onclick="openChat()" title="Chat" data-tooltip="Chat">
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"/>
                </svg>
            </button>
            <button class="nav-icon" onclick="openPeople()" title="People" data-tooltip="People">
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                    <circle cx="9" cy="7" r="4"/>
                    <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                    <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                </svg>
            </button>
            <button class="nav-icon" onclick="openSettings()" title="Settings" data-tooltip="Settings">
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="3"/>
                    <path d="M12 1v6m0 6v6m11-7h-6m-6 0H1"/>
                </svg>
            </button>
            <div class="nav-divider"></div>
            <button class="nav-icon" onclick="toggleDebugConsole()" title="Debug Console" data-tooltip="Debug">
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9 12l2 2 4-4"/>
                    <path d="M21 12c.552 0 1-.448 1-1V5c0-.552-.448-1-1-1H3c-.552 0-1 .448-1 1v6c0 .552.448 1 1 1"/>
                </svg>
            </button>
            <div class="nav-divider"></div>
            <button class="nav-icon" onclick="toggleFullscreen()" title="Fullscreen" data-tooltip="Fullscreen">
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
                </svg>
            </button>
            <button class="nav-icon" onclick="toggleHelp()" title="Help" data-tooltip="Help">
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
                    <point cx="12" cy="17"/>
                </svg>
            </button>
        </nav>
        
        <!-- Chat Window -->
        <div class="chat-window" id="chatWindow">
            <div class="chat-header">
                <span class="chat-title">Chat</span>
                <div class="window-controls">
                    <button class="control-btn" onclick="toggleChatSnap()" title="Toggle Snap">📌</button>
                    <button class="close-btn" onclick="closeChat()">×</button>
                </div>
            </div>
            <div class="chat-content">
                <div class="chat-messages" id="chatMessages">
                    <!-- Chat messages will be populated here -->
                </div>
                <div class="chat-input-container">
                    <input type="text" class="chat-input" id="chatInput" placeholder="Type a message..." onkeypress="handleChatKeyPress(event)">
                    <button class="send-btn" onclick="sendMessage()">Send</button>
                    <button class="voice-btn" id="voiceButton" onclick="toggleVoiceRecording()" title="Voice Recording">🎤</button>
                </div>
            </div>
        </div>
        
        <!-- People Panel (Right Side) -->
        <div class="people-panel" id="peoplePanel">
            <div class="people-header">
                <span class="people-title">People</span>
                <div class="window-controls">
                    <button class="control-btn" onclick="togglePeopleSnap()" title="Toggle Snap">📌</button>
                    <button class="close-btn" onclick="closePeople()">×</button>
                </div>
            </div>
            <div class="people-content">
                <div class="people-models-list" id="peopleModelsList">
                    <!-- Model icons will be populated here vertically -->
                </div>
                <div class="people-controls">
                    <button class="add-model-btn" onclick="showAddModelDialog()" title="Add new model">
                        <span class="add-icon">+</span>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Settings Panel (Left Side Overlay) -->
        <div class="settings-panel" id="settingsPanel">
            <div class="settings-header">
                <span class="settings-title">Live2D Settings</span>
                <div class="window-controls">
                    <button class="control-btn" onclick="toggleSettingsSnap()" title="Toggle Snap">📌</button>
                    <button class="close-btn" onclick="closeSettings()">×</button>
                </div>
            </div>
            <div class="settings-content">
                <div class="settings-group">
                    <h4>Model Selection</h4>
                    <div class="setting-item">
                        <label for="modelSelect">Model:</label>
                        <select id="modelSelect" onchange="onModelChange()">
                            <option value="">Select a model...</option>
                        </select>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h4>Display Controls</h4>
                    <div class="setting-item">
                        <label for="zoomSlider">Scale: <span id="zoomValue">1.0</span></label>
                        <input type="range" id="zoomSlider" min="0.1" max="3.0" step="0.1" value="1.0" oninput="updateZoom(this.value); document.getElementById('zoomValue').textContent = this.value;">
                    </div>
                    <div class="setting-controls">
                        <button class="btn btn-secondary" onclick="resetZoom()">Reset</button>
                        <button class="btn btn-secondary" onclick="fitModel()">Fit</button>
                        <button class="btn btn-secondary" onclick="centerModel()">Center</button>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h4>Motions</h4>
                    <div class="setting-item">
                        <label for="motionGroupSelect">Motion Group:</label>
                        <select id="motionGroupSelect" onchange="onMotionGroupChange()">
                            <option value="">No motions available</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label for="motionSelect">Motion:</label>
                        <select id="motionSelect" onchange="onMotionTypeChange()">
                            <option value="">Select motion group first</option>
                        </select>
                    </div>
                    <div class="setting-controls">
                        <button class="btn btn-primary" onclick="playSelectedMotion()">Play Motion</button>
                        <button class="btn btn-secondary" onclick="playRandomMotion()">Random</button>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h4>Expressions</h4>
                    <div class="setting-item">
                        <label for="expressionSelect">Expression:</label>
                        <select id="expressionSelect" onchange="onExpressionChange()">
                            <option value="">No expressions available</option>
                        </select>
                    </div>
                    <div class="setting-controls">
                        <button class="btn btn-primary" onclick="playExpression()">Apply Expression</button>
                        <button class="btn btn-secondary" onclick="resetExpression()">Reset</button>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h4>Debug Options</h4>
                    <div class="setting-item">
                        <label>
                            <input type="checkbox" id="showCanvasFrame" checked onchange="toggleCanvasFrame()">
                            Show Canvas Frame
                        </label>
                    </div>
                    <div class="setting-item">
                        <label>
                            <input type="checkbox" id="showModelFrame" onchange="toggleModelFrame()">
                            Show Model Frame
                        </label>
                    </div>
                    <div class="setting-item">
                        <label>
                            <input type="checkbox" id="showHitAreas" onchange="toggleHitAreas()">
                            Show Hit Areas
                        </label>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h4>Actions</h4>
                    <div class="setting-controls">
                        <button class="btn btn-primary" onclick="testModel()">Test Model</button>
                        <button class="btn btn-warning" onclick="resetModel()">Reset</button>
                    </div>
                    <div class="setting-controls">
                        <button class="btn btn-info" onclick="debugWindowPositions()">Debug Positions</button>
                        <button class="btn btn-warning" onclick="resetWindowLayout()">Reset Layout</button>
                    </div>
                    <div class="setting-controls">
                        <button class="btn btn-info" onclick="rescueOffScreenWindows()">Rescue Windows</button>
                    </div>
                    <div class="setting-item">
                        <label style="font-size: 12px; color: #aaa; font-style: italic;">
                            Emergency shortcuts:<br>
                            Ctrl+Shift+R = Reset to defaults<br>
                            Ctrl+Shift+B = Rescue off-screen windows
                        </label>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Enhanced Debug Console -->
        <div class="debug-ui-panel" id="debugUIPanel" style="display: none;">
            <div class="debug-header">
                🔍 Live2D AI Companion Debug Console
                <button class="debug-close-btn" onclick="toggleDebugConsole()" style="float: right; background: none; border: none; color: #ff4444; cursor: pointer; font-size: 16px;">✕</button>
            </div>
            
            <div class="debug-section">
                <h4>System Status</h4>
                <div class="debug-item" id="debug-sdk-status">SDK: <span class="debug-status-warn">Checking...</span></div>
                <div class="debug-item" id="debug-canvas-status">Canvas: <span class="debug-status-warn">Initializing...</span></div>
            </div>
            
            <div class="debug-section">
                <h4>Model Info</h4>
                <div class="debug-item" id="debug-model-name">Name: <span id="debug-current-model">None</span></div>
                <div class="debug-item" id="debug-motion-groups">Motion Groups: <span id="debug-motion-count">0</span></div>
                <div class="debug-item" id="debug-last-motion">Last Motion: <span id="debug-last-motion-name">None</span></div>
                <div class="debug-item" id="debug-available-models">Available Models: <span id="debug-models-list">Loading...</span></div>
            </div>
            
            <div class="debug-section">
                <h4>Database Info</h4>
                <div class="debug-item" id="debug-db-models">DB Models: <span id="debug-db-model-count">-</span></div>
                <div class="debug-item" id="debug-db-motions">DB Motions: <span id="debug-db-motion-count">-</span></div>
                <div class="debug-item" id="debug-db-status">DB Connection: <span id="debug-db-connection">Unknown</span></div>
            </div>
            
            <div class="debug-section">
                <h4>System Operations</h4>
                <div class="debug-controls" style="flex-wrap: wrap; gap: 0.25rem;">
                    <button class="debug-btn" onclick="debugRefreshAll()" title="Refresh all status information">🔄 Refresh All</button>
                    <button class="debug-btn" onclick="debugTestSystem()" title="Run comprehensive system test">🧪 System Test</button>
                    <button class="debug-btn" onclick="debugDatabaseInfo()" title="Load database information">💾 DB Info</button>
                    <button class="debug-btn" onclick="debugClearDatabase()" title="Clear database (WARNING: Destructive)" style="background: #ff4444;">🗑 Clear DB</button>
                    <button class="debug-btn" onclick="debugReimportData()" title="Re-import all models and motions" style="background: #ff9800;">📥 Re-import</button>
                </div>
            </div>
            
            <div class="debug-section">
                <h4>Model Operations</h4>
                <div class="debug-controls" style="flex-wrap: wrap; gap: 0.25rem;">
                    <button class="debug-btn" onclick="debugTestMotion()" title="Test a random motion">🎭 Test Motion</button>
                    <button class="debug-btn" onclick="debugLogMotions()" title="Log available motions to console">📝 Log Motions</button>
                    <button class="debug-btn" onclick="debugModelStructure()" title="Analyze model structure">🔍 Structure</button>
                    <button class="debug-btn" onclick="debugLive2D()" title="Debug Live2D system">🔍 Debug L2D</button>
                    <button class="debug-btn" onclick="debugLoadDefaultModel()" title="Load default model" id="debug-load-default-model" style="display:none;background:#4caf50;">📦 Load Model</button>
                </div>
                
                <div class="debug-controls" style="margin-top: 0.5rem;">
                    <h5 style="margin: 0.5rem 0 0.3rem 0; color: #ffeb3b;">⚡ Performance Tests:</h5>
                    <button class="debug-btn" onclick="testLoadingPerformance()" title="Test model loading speed">🏃‍♂️ Load Speed</button>
                    <button class="debug-btn" onclick="benchmarkModelSwitching()" title="Benchmark model switching">🏎️ Switch Speed</button>
                    <button class="debug-btn" onclick="displayPerformanceStats()" title="Show performance statistics">📊 Stats</button>
                    <button class="debug-btn" onclick="clearPerformanceCache()" title="Clear performance cache">🧹 Clear Cache</button>
                </div>
            </div>
            
            <div class="debug-section">
                <h4>Real-time Log</h4>
                <div class="debug-log" id="debug-realtime-log">
                    🔍 Debug console initialized. Use buttons above to run tests...
                </div>
                <div class="debug-controls" style="margin-top: 0.5rem;">
                    <button class="debug-btn" onclick="debugClearLog()" title="Clear debug log">🗑 Clear Log</button>
                    <button class="debug-btn" onclick="debugToggleVerbose()" title="Toggle verbose logging">💬 Verbose</button>
                    <button class="debug-btn" onclick="debugExportLog()" title="Export log to console">📤 Export Log</button>
                </div>
            </div>
        </div>
        
        <!-- Canvas Area -->
        <div class="canvas-container">
            <div class="canvas-frame">
                <div id="pixiContainer"></div>
            </div>
            <div class="loading-overlay" id="loadingOverlay" style="display: none;">
                <div class="loading-spinner"></div>
            </div>
        </div>
    </div>

    <!-- Model Selection Dialog -->
    <div class="model-selection-dialog" id="modelSelectionDialog" style="display: none;">
        <div class="dialog-overlay" onclick="closeAddModelDialog()"></div>
        <div class="dialog-content">
            <div class="dialog-header">
                <h3>Add Live2D Model</h3>
                <button class="dialog-close" onclick="closeAddModelDialog()">×</button>
            </div>
            <div class="dialog-body">
                <div class="model-grid" id="modelGrid">
                    <div style="text-align: center; padding: 20px; color: #aaa;">
                        Loading available models...
                    </div>
                </div>
            </div>
        </div>
    </div>

<!-- Load PIXI.js and Live2D libraries in correct order -->
<!-- Step 1: Load PIXI.js 6.5.10 from dist folder -->
<script src="/static/dist/pixi-6.5.10.min.js"></script>

<!-- Step 2: Load EventEmitter compatibility for PIXI v6 -->
<script src="/static/js/eventemitter-preloader-v6.js"></script>

<!-- Step 3: Load Live2D v2 Bundle for Cubism 2.x models -->
<script src="/static/dist/live2d_bundle.js"></script>

<!-- Step 4: Load Cubism 5 Core for modern models -->
<script src="/static/dist/CubismSdkForWeb-5-r.4/Core/live2dcubismcore.min.js"></script>

<!-- Step 6: Verify dual architecture setup -->
<script>
console.log('=== Dual Architecture Verification ===');
console.log('PIXI version:', typeof PIXI !== 'undefined' ? PIXI.VERSION : 'Not loaded');
console.log('EventEmitter available:', typeof EventEmitter !== 'undefined');
console.log('Live2D v2 Bundle loaded:', typeof window.Live2D !== 'undefined');
console.log('Cubism 5 Core loaded:', typeof window.Live2DCubismCore !== 'undefined');

// Debug Live2D v2 Bundle
if (typeof window.Live2D !== 'undefined') {
    console.log('✓ Live2D v2 Bundle ready for Cubism 2.x models');
    console.log('- window.Live2D:', typeof window.Live2D);
    console.log('- window.Live2DModelWebGL:', typeof window.Live2DModelWebGL);
    console.log('- window.live2dv2:', typeof window.live2dv2);
}

// Debug Cubism 5 Core
if (typeof window.Live2DCubismCore !== 'undefined') {
    console.log('✓ Cubism 5 Core ready for modern models');
    console.log('- Core version:', window.Live2DCubismCore.Version ? window.Live2DCubismCore.Version.csmGetVersion() : 'unknown');
}

console.log('=== End Verification ===');
</script>

<!-- Step 5: Load pixi-live2d-display (local for offline installation) -->
<script src="/static/dist/pixi-live2d-display-0.4.0.min.js"></script>

<!-- Step 5: Verify Live2D plugin initialization -->
<script>
// AI Companion API Configuration - Auto-detect protocol and server
window.ai2d_chat_CONFIG = {
    // Automatically detect the current protocol and server
    API_BASE_URL: (() => {
        const protocol = window.location.protocol; // 'http:' or 'https:'
        const hostname = window.location.hostname;
        const port = window.location.port;
        
        // For HTTPS deployments (like Cloudflare tunnel), use same protocol without port
        if (protocol === 'https:') {
            return `${protocol}//${hostname}`;
        }
        
        // For HTTP deployments (local development), include port if available
        if (port) {
            return `${protocol}//${hostname}:${port}`;
        }
        
        // Fallback to protocol and hostname only
        return `${protocol}//${hostname}`;
    })(),
    
    // Fallback URLs for different environments
    FALLBACK_URLS: (() => {
        const protocol = window.location.protocol;
        const hostname = window.location.hostname;
        
        if (protocol === 'https:') {
            return [
                `${protocol}//${hostname}`, // HTTPS without port
                `http://${hostname}:19443`, // Development fallback
                `http://${hostname}:19447`  // Production fallback
            ];
        } else {
            return [
                `http://${hostname}:19443`, // Development
                `http://${hostname}:19447`, // Production
                'http://localhost:19443',   // Default dev
                'http://localhost:19447'    // Default prod
            ];
        }
    })()
};

console.log('AI Companion API Config:', window.ai2d_chat_CONFIG.API_BASE_URL);
console.log('Protocol detected:', window.location.protocol);
console.log('Fallback URLs:', window.ai2d_chat_CONFIG.FALLBACK_URLS);
</script>

<script>
// Initialize Live2D plugin following Live2D Viewer Web pattern
console.log('Initializing Live2D plugin (Live2D Viewer Web compatible)...');

// Wait for all scripts to load
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(function() {
        console.log('Checking library compatibility...');
        
        // Verify libraries are loaded
        if (typeof PIXI === 'undefined') {
            console.error('PIXI.js not loaded');
            return;
        }
        
        if (typeof EventEmitter === 'undefined') {
            console.error('EventEmitter not available');
            return;
        }
        
        console.log('✓ PIXI version:', PIXI.VERSION);
        console.log('✓ EventEmitter type:', typeof EventEmitter);
        
        // Check if PIXI.utils.EventEmitter exists (Live2D Viewer Web pattern)
        if (PIXI.utils && PIXI.utils.EventEmitter) {
            console.log('✓ PIXI.utils.EventEmitter available (Live2D Viewer Web compatible)');
        }
        
        // Check if Live2D plugin is available
        if (typeof PIXI.live2d === 'undefined') {
            console.error('✗ PIXI.live2d not loaded - pixi-live2d-display may not be compatible');
            console.log('Available PIXI properties:', Object.keys(PIXI));
            
            // Try to diagnose the issue
            if (window.pixiLive2DLoadError) {
                console.error('Library loading error detected - check network tab');
            }
        } else {
            console.log('✓ PIXI.live2d loaded successfully');
            console.log('Available PIXI.live2d properties:', Object.keys(PIXI.live2d));
            
            // Check for Live2DModel
            if (PIXI.live2d.Live2DModel) {
                console.log('✓ Live2DModel class available');
                window.Live2DModel = PIXI.live2d.Live2DModel;
                
                // Test if it has the expected methods
                if (typeof PIXI.live2d.Live2DModel.from === 'function') {
                    console.log('✓ Live2DModel.from() method available');
                } else {
                    console.warn('Live2DModel.from() method not found');
                }
            } else {
                console.warn('Live2DModel not found in PIXI.live2d');
            }
            
            // Check for Live2DFactory
            if (PIXI.live2d.Live2DFactory) {
                console.log('✓ Live2DFactory available');
                window.Live2DFactory = PIXI.live2d.Live2DFactory;
            } else {
                console.warn('Live2DFactory not found in PIXI.live2d');
            }
        }
        
        console.log('Live2D plugin initialization check complete');
        console.log('System ready for Live2D model loading');
        
    }, 500); // Increased delay to ensure all libraries are loaded
});
</script>

<!-- Step 5: Load Live2D modular system -->
<script src="/static/js/live2d_config.js"></script>
<script src="/static/js/live2d_logger.js"></script>
<script src="/static/js/live2d_tester.js"></script>
<script src="/static/js/live2d_interaction.js"></script>
<script src="/static/js/live2d_core.js"></script>
<script src="/static/js/live2d_model_manager.js"></script>
<script src="/static/js/live2d_multi_model_manager.js"></script>
<script src="/static/js/live2d_motion_manager.js"></script>
<script src="/static/js/live2d_integration.js"></script>
<script src="/static/js/live2d_ui_controller.js"></script>
<script src="/static/js/live2d_simple_fix.js"></script>

<!-- AI Companion Core Functionality -->
<script src="/static/js/tts-audio.js"></script>
<script src="/static/js/chat.js"></script>
<script src="/static/js/db.js"></script>
<script src="/static/js/debug.js"></script>
<script src="/static/js/voice-recording.js"></script>

<!-- SocketIO for real-time communication -->
<script src="https://cdn.socket.io/4.5.0/socket.io.min.js"></script>

<script>
// Global variables for the modular system
let live2dIntegration = null;
let uiController = null;
let live2dMultiModelManager = null; // Make available globally for remove buttons

// Initialize the modular Live2D system
async function initializeLive2D() {
    try {
        console.log('Initializing Live2D modular system...');
        
        // Create integration instance
        live2dIntegration = new Live2DIntegration();
        
        // Initialize integration (canvas container)
        const success = await live2dIntegration.initialize('pixiContainer');
        
        if (!success) {
            throw new Error('Failed to initialize Live2D integration');
        }
        
        // Create UI controller
        uiController = new Live2DUIController(live2dIntegration);
        
        // Initialize UI controller
        await uiController.initialize();
        
        // Store reference to multi-model manager for global access
        live2dMultiModelManager = live2dIntegration.modelManager;
        
        // Set up connection between multi-model manager and UI controller
        live2dMultiModelManager.setUIController(uiController);
        
        // Initialize the People panel with actual loaded models (clear any hardcoded data)
        populatePeopleModels();
        
        console.log('Live2D system initialized successfully!');
        
    } catch (error) {
        console.error('Failed to initialize Live2D system:', error);
    }
}

// Debug function to show current window positions
function debugWindowPositions() {
    const chatWindow = document.getElementById('chatWindow');
    const peoplePanel = document.getElementById('peoplePanel');
    const settingsPanel = document.getElementById('settingsPanel');
    
    console.log('=== Window Positions Debug ===');
    console.log('Chat Window:', {
        rect: chatWindow.getBoundingClientRect(),
        style: { left: chatWindow.style.left, top: chatWindow.style.top, transform: chatWindow.style.transform },
        computed: window.getComputedStyle(chatWindow).transform
    });
    console.log('People Panel:', {
        rect: peoplePanel.getBoundingClientRect(),
        style: { left: peoplePanel.style.left, top: peoplePanel.style.top, transform: peoplePanel.style.transform },
        computed: window.getComputedStyle(peoplePanel).transform
    });
    console.log('Settings Panel:', {
        rect: settingsPanel.getBoundingClientRect(),
        style: { left: settingsPanel.style.left, top: settingsPanel.style.top, transform: settingsPanel.style.transform },
        computed: window.getComputedStyle(settingsPanel).transform
    });
    console.log('Saved Layout:', JSON.parse(localStorage.getItem(LAYOUT_STORAGE_KEY) || '{}'));
    console.log('==============================');
}

function onModelChange() {
    console.log('onModelChange called');
    if (uiController) {
        const modelName = document.getElementById('modelSelect').value;
        uiController.onModelChange(modelName);
    } else {
        console.error('uiController not available');
    }
}

function updateZoom(value) {
    if (live2dIntegration && live2dIntegration.core && live2dIntegration.core.interactionManager) {
        live2dIntegration.core.interactionManager.setZoom(parseFloat(value));
    }
}

function resetZoom() {
    if (live2dIntegration && live2dIntegration.core && live2dIntegration.core.interactionManager) {
        live2dIntegration.core.interactionManager.resetZoom();
        // Update slider
        const slider = document.getElementById('zoomSlider');
        if (slider) slider.value = 1.0;
        // Update display
        const display = document.getElementById('zoomValue');
        if (display) display.textContent = '1.0';
    }
}

function fitModel() {
    if (live2dIntegration && live2dIntegration.core && live2dIntegration.core.interactionManager) {
        live2dIntegration.core.interactionManager.fitModelToCanvas();
    }
}

function centerModel() {
    if (live2dIntegration && live2dIntegration.core && live2dIntegration.core.interactionManager) {
        live2dIntegration.core.interactionManager.centerModel();
    }
}

function onMotionGroupChange() {
    if (uiController) {
        const group = document.getElementById('motionGroupSelect').value;
        uiController.onMotionGroupChange(group);
    }
}

function onMotionTypeChange() {
    if (uiController) {
        const motion = document.getElementById('motionSelect').value;
        uiController.onMotionTypeChange(motion);
    }
}

function playSelectedMotion() {
    if (uiController) uiController.playSelectedMotion();
}

function playRandomMotion() {
    if (uiController) uiController.playRandomMotion();
}

function onExpressionChange() {
    if (uiController) {
        const expression = document.getElementById('expressionSelect').value;
        uiController.onExpressionChange(expression);
    }
}

function playExpression() {
    if (uiController) uiController.playExpression();
}

function resetExpression() {
    if (uiController) uiController.resetExpression();
}

function testModel() {
    if (uiController) uiController.testModel();
}

function resetModel() {
    console.log('resetModel called');
    if (uiController) {
        uiController.resetModel();
    } else {
        console.error('uiController not available');
    }
}

function toggleSettings() {
    console.log('toggleSettings called');
    if (uiController) {
        uiController.toggleSettings();
    } else if (window.toggleSettingsPanel) {
        window.toggleSettingsPanel();
    } else {
        console.error('uiController and toggleSettingsPanel not available');
    }
}

function debugModel() {
    console.log('debugModel called');
    if (uiController) {
        uiController.debugModel();
    } else {
        console.error('uiController not available');
    }
}

function toggleCanvasFrame() {
    if (uiController) uiController.toggleCanvasFrame();
}

function toggleModelFrame() {
    if (uiController) uiController.toggleModelFrame();
}

function toggleHitAreas() {
    if (uiController) uiController.toggleHitAreas();
}

function toggleDebugMode() {
    if (uiController) uiController.toggleDebugMode();
}

function toggleFPS() {
    if (uiController) uiController.toggleFPS();
}

function toggleMouseLogging() {
    if (uiController) uiController.toggleMouseLogging();
}

function changeRenderQuality() {
    if (uiController) uiController.changeRenderQuality();
}

function toggleAntialiasing() {
    if (uiController) uiController.toggleAntialiasing();
}

function showModelInfo() {
    if (live2dIntegration) {
        live2dIntegration.debugModelBounds();
        live2dIntegration.core.debugModelVisibility();
    }
}

// Global state
let chatOpen = false;
let peopleOpen = false;
let settingsOpen = false;
let chatSnapped = false;
let peopleSnapped = false;
let settingsSnapped = false;

// Draggable functionality
let isDragging = false;
let currentDragElement = null;
let dragOffset = { x: 0, y: 0 };

// Window Layout Persistence System
const LAYOUT_STORAGE_KEY = 'ai2d_chat-window-layout';

// Default window layouts
const DEFAULT_LAYOUTS = {
    chatWindow: {
        position: { x: 'center', y: 'bottom' },
        size: { width: 400, height: 400 },
        snapped: false,
        snapPosition: 'bottom',
        open: false
    },
    peoplePanel: {
        position: { x: 'right-20', y: 'top-80' },
        size: { width: 200, height: 'auto' },
        snapped: false,
        snapPosition: 'right',
        open: false
    },
    settingsPanel: {
        position: { x: 'left-20', y: 'top-20' },
        size: { width: 350, height: 'auto' },
        snapped: false,
        snapPosition: 'left',
        open: false
    }
};

// Save window layout to localStorage
function saveWindowLayout() {
    const layout = {
        chatWindow: {
            position: getElementPosition('chatWindow'),
            size: getElementSize('chatWindow'),
            snapped: chatSnapped,
            snapPosition: getChatSnapPosition(),
            open: chatOpen
        },
        peoplePanel: {
            position: getElementPosition('peoplePanel'),
            size: getElementSize('peoplePanel'),
            snapped: peopleSnapped,
            snapPosition: getPeopleSnapPosition(),
            open: peopleOpen
        },
        settingsPanel: {
            position: getElementPosition('settingsPanel'),
            size: getElementSize('settingsPanel'),
            snapped: settingsSnapped,
            snapPosition: getSettingsSnapPosition(),
            open: settingsOpen
        }
    };
    
    // Validate positions to prevent off-screen windows
    layout.chatWindow.position = validatePosition(layout.chatWindow.position);
    layout.peoplePanel.position = validatePosition(layout.peoplePanel.position);
    layout.settingsPanel.position = validatePosition(layout.settingsPanel.position);
    
    localStorage.setItem(LAYOUT_STORAGE_KEY, JSON.stringify(layout));
}

// Validate that positions are within viewport bounds
function validatePosition(position) {
    const maxX = window.innerWidth - 200; // Minimum 200px visible
    const maxY = window.innerHeight - 100; // Minimum 100px visible
    
    return {
        x: Math.max(0, Math.min(position.x, maxX)),
        y: Math.max(0, Math.min(position.y, maxY))
    };
}

// Reset all windows to default positions
function resetWindowLayout() {
    console.log('Resetting window layout to defaults');
    localStorage.removeItem(LAYOUT_STORAGE_KEY);
    
    // Immediately apply default layouts instead of reloading
    applyDefaultLayout();
}

// Apply default layout immediately
function applyDefaultLayout() {
    console.log('Applying default window layout');
    
    // Reset all windows to default positions
    const chatWindow = document.getElementById('chatWindow');
    const peoplePanel = document.getElementById('peoplePanel');
    const settingsPanel = document.getElementById('settingsPanel');
    
    if (chatWindow) {
        // Reset chat window
        chatWindow.style.left = '';
        chatWindow.style.right = '';
        chatWindow.style.top = '';
        chatWindow.style.bottom = '';
        chatWindow.style.transform = '';
        chatWindow.style.position = 'fixed';
        chatWindow.classList.remove('pinned');
        chatWindow.classList.add('open'); /* Add open class for default visibility */
        
        // Apply default CSS positioning - Show the chat window in default position
        chatWindow.style.bottom = '10px'; /* Bottom edge 10px from bottom window edge */
        chatWindow.style.left = '50%';
        chatWindow.style.transform = 'translateX(-50%) translateY(0)'; /* Show chat window in default position */
        chatWindow.style.width = '50%'; /* Use responsive width from CSS */
        chatWindow.style.height = '30%'; /* Use responsive height from CSS - updated to 30% */
        
        // Reset pin button
        const chatPinButton = chatWindow.querySelector('.control-btn[onclick="toggleChatSnap()"]');
        if (chatPinButton) chatPinButton.classList.remove('pinned');
        
        chatOpen = true; /* Panel is visible in default position */
        chatSnapped = false;
    }
    
    if (peoplePanel) {
        // Reset people panel
        peoplePanel.style.left = '';
        peoplePanel.style.right = '';
        peoplePanel.style.top = '';
        peoplePanel.style.bottom = '';
        peoplePanel.style.transform = '';
        peoplePanel.style.position = 'fixed';
        peoplePanel.classList.remove('pinned');
        peoplePanel.classList.add('open'); /* Add open class for default visibility */
        
        // Apply default CSS positioning - Show the panel in default position
        peoplePanel.style.top = '80px';
        peoplePanel.style.right = '20px'; /* Right edge 20px from right window edge */
        peoplePanel.style.transform = 'translateX(0)'; /* Show panel in default position */
        peoplePanel.style.width = '200px';
        
        // Reset pin button
        const peoplePinButton = peoplePanel.querySelector('.control-btn[onclick="togglePeopleSnap()"]');
        if (peoplePinButton) peoplePinButton.classList.remove('pinned');
        
        peopleOpen = true; /* Panel is visible in default position */
        peopleSnapped = false;
    }
    
    if (settingsPanel) {
        // Reset settings panel
        settingsPanel.style.left = '';
        settingsPanel.style.right = '';
        settingsPanel.style.top = '';
        settingsPanel.style.bottom = '';
        settingsPanel.style.transform = '';
        settingsPanel.style.position = 'fixed';
        settingsPanel.classList.remove('pinned');
        settingsPanel.classList.remove('open'); /* Settings should start closed */
        
        // Apply default CSS positioning - Hide the panel initially
        settingsPanel.style.top = '20px';
        settingsPanel.style.left = '20px';
        settingsPanel.style.transform = 'translateX(-100%)'; /* Hide panel initially */
        settingsPanel.style.width = '350px';
        
        // Reset pin button
        const settingsPinButton = settingsPanel.querySelector('.control-btn[onclick="toggleSettingsSnap()"]');
        if (settingsPinButton) settingsPinButton.classList.remove('pinned');
        
        settingsOpen = false; /* Panel is hidden by default */
        settingsSnapped = false;
    }
    
    updateNavIconStates();
    console.log('Default layout applied');
}

// Load window layout from localStorage
function loadWindowLayout() {
    try {
        const savedLayout = localStorage.getItem(LAYOUT_STORAGE_KEY);
        if (!savedLayout) {
            console.log('No saved layout found, using defaults');
            return DEFAULT_LAYOUTS;
        }
        
        const layout = JSON.parse(savedLayout);
        console.log('Window layout loaded:', layout);
        return layout;
    } catch (error) {
        console.error('Error loading window layout:', error);
        return DEFAULT_LAYOUTS;
    }
}

// Apply saved layout to windows
function applyWindowLayout(layout) {
    // Apply chat window layout
    if (layout.chatWindow) {
        const chatWindow = document.getElementById('chatWindow');
        if (chatWindow) {
            applyElementLayout(chatWindow, layout.chatWindow);
            chatOpen = layout.chatWindow.open;
            chatSnapped = layout.chatWindow.snapped;
            if (chatOpen) {
                chatWindow.classList.add('open');
            }
            if (chatSnapped) {
                chatWindow.classList.add('pinned'); // Add visual indicator
                const pinButton = chatWindow.querySelector('.control-btn[onclick="toggleChatSnap()"]');
                if (pinButton) pinButton.classList.add('pinned');
            }
        }
    }
    
    // Apply people panel layout
    if (layout.peoplePanel) {
        const peoplePanel = document.getElementById('peoplePanel');
        if (peoplePanel) {
            applyElementLayout(peoplePanel, layout.peoplePanel);
            peopleOpen = layout.peoplePanel.open;
            peopleSnapped = layout.peoplePanel.snapped;
            if (peopleOpen) {
                peoplePanel.classList.add('open');
            }
            if (peopleSnapped) {
                peoplePanel.classList.add('pinned'); // Add visual indicator
                const pinButton = peoplePanel.querySelector('.control-btn[onclick="togglePeopleSnap()"]');
                if (pinButton) pinButton.classList.add('pinned');
            }
        }
    }
    
    // Apply settings panel layout
    if (layout.settingsPanel) {
        const settingsPanel = document.getElementById('settingsPanel');
        if (settingsPanel) {
            applyElementLayout(settingsPanel, layout.settingsPanel);
            settingsOpen = layout.settingsPanel.open;
            settingsSnapped = layout.settingsPanel.snapped;
            if (settingsOpen) {
                settingsPanel.classList.add('open');
            }
            if (settingsSnapped) {
                settingsPanel.classList.add('pinned'); // Add visual indicator
                const pinButton = settingsPanel.querySelector('.control-btn[onclick="toggleSettingsSnap()"]');
                if (pinButton) pinButton.classList.add('pinned');
            }
        }
    }
    
    updateNavIconStates();
}

// Helper functions for layout management
function getElementPosition(elementId) {
    const element = document.getElementById(elementId);
    if (!element) return { x: 0, y: 0 };
    
    // Get computed style to check for transforms
    const computedStyle = window.getComputedStyle(element);
    const rect = element.getBoundingClientRect();
    
    // If element has been positioned manually, use the style values
    if (element.style.left && element.style.left !== '') {
        const left = parseInt(element.style.left.replace('px', ''));
        const top = parseInt(element.style.top ? element.style.top.replace('px', '') : '0');
        return { x: left, y: top };
    }
    
    // Otherwise use bounding rect, but account for potential issues
    return {
        x: Math.max(0, rect.left),
        y: Math.max(0, rect.top)
    };
}

function getElementSize(elementId) {
    const element = document.getElementById(elementId);
    if (!element) return { width: 0, height: 0 };
    
    return {
        width: element.offsetWidth,
        height: element.offsetHeight
    };
}

function applyElementLayout(element, layout) {
    // CRITICAL FIX: Reset all positioning properties to prevent cumulative drift
    element.style.left = '';
    element.style.right = '';
    element.style.top = '';
    element.style.bottom = '';
    element.style.transform = '';
    element.style.position = 'fixed';
    
    if (layout.position) {
        // Apply position with absolute values only
        if (typeof layout.position.x === 'string') {
            if (layout.position.x === 'center') {
                element.style.left = '50%';
                element.style.transform = 'translateX(-50%)';
            } else if (layout.position.x.includes('left-')) {
                element.style.left = layout.position.x.replace('left-', '') + 'px';
            } else if (layout.position.x.includes('right-')) {
                element.style.right = layout.position.x.replace('right-', '') + 'px';
            }
        } else {
            // Always use absolute pixel positioning to prevent drift
            element.style.left = Math.max(0, layout.position.x) + 'px';
        }
        
        if (typeof layout.position.y === 'string') {
            if (layout.position.y.includes('top-')) {
                element.style.top = layout.position.y.replace('top-', '') + 'px';
            } else if (layout.position.y.includes('bottom-')) {
                element.style.bottom = layout.position.y.replace('bottom-', '') + 'px';
            }
        } else {
            // Always use absolute pixel positioning to prevent drift
            element.style.top = Math.max(0, layout.position.y) + 'px';
        }
    }
    
    if (layout.size) {
        // Apply size
        if (layout.size.width !== 'auto') {
            element.style.width = layout.size.width + 'px';
        }
        if (layout.size.height !== 'auto') {
            element.style.height = layout.size.height + 'px';
        }
    }
}

function getChatSnapPosition() {
    const chatWindow = document.getElementById('chatWindow');
    if (chatWindow.classList.contains('snapped-left')) return 'left';
    if (chatWindow.classList.contains('snapped-right')) return 'right';
    if (chatWindow.classList.contains('snapped-bottom')) return 'bottom';
    return 'bottom';
}

function getPeopleSnapPosition() {
    const peoplePanel = document.getElementById('peoplePanel');
    if (peoplePanel.classList.contains('snapped-left')) return 'left';
    if (peoplePanel.classList.contains('snapped-right')) return 'right';
    return 'right';
}

function getSettingsSnapPosition() {
    const settingsPanel = document.getElementById('settingsPanel');
    if (settingsPanel.classList.contains('snapped-left')) return 'left';
    if (settingsPanel.classList.contains('snapped-right')) return 'right';
    return 'left';
}

// Clear saved layout (for debugging)
function clearSavedLayout() {
    localStorage.removeItem(LAYOUT_STORAGE_KEY);
    console.log('Saved layout cleared');
}

// Add emergency reset functionality for off-screen windows
document.addEventListener('keydown', function(e) {
    // Ctrl+Shift+R to reset window layout
    if (e.ctrlKey && e.shiftKey && e.key === 'R') {
        e.preventDefault();
        console.log('Emergency layout reset triggered');
        resetWindowLayout();
    }
    
    // Ctrl+Shift+B to bring all windows back into view (rescue mode)
    if (e.ctrlKey && e.shiftKey && e.key === 'B') {
        e.preventDefault();
        console.log('Emergency rescue mode triggered');
        rescueOffScreenWindows();
    }
    
    // Escape key to close model selection dialog
    if (e.key === 'Escape') {
        const dialog = document.getElementById('modelSelectionDialog');
        if (dialog && dialog.style.display === 'flex') {
            closeAddModelDialog();
        }
    }
});

// Emergency function to bring off-screen windows back into view
function rescueOffScreenWindows() {
    console.log('Rescuing off-screen windows...');
    
    const windows = [
        { element: document.getElementById('chatWindow'), name: 'Chat' },
        { element: document.getElementById('peoplePanel'), name: 'People' },
        { element: document.getElementById('settingsPanel'), name: 'Settings' }
    ];
    
    windows.forEach(({ element, name }) => {
        if (!element) return;
        
        const rect = element.getBoundingClientRect();
        const isOffScreen = rect.left < 0 || rect.top < 0 || 
                           rect.right > window.innerWidth || 
                           rect.bottom > window.innerHeight;
        
        if (isOffScreen) {
            console.log(`Rescuing ${name} window from off-screen position`);
            
            // Reset positioning and place in safe area
            element.style.left = '';
            element.style.right = '';
            element.style.top = '';
            element.style.bottom = '';
            element.style.transform = '';
            element.style.position = 'fixed';
            
            // Place in center-ish safe area
            const safeX = Math.max(20, Math.min(window.innerWidth - 300, 100));
            const safeY = Math.max(20, Math.min(window.innerHeight - 200, 100));
            
            element.style.left = safeX + 'px';
            element.style.top = safeY + 'px';
            
            // Make sure it's visible
            element.classList.add('open');
            if (name === 'Chat') chatOpen = true;
            if (name === 'People') peopleOpen = true;
            if (name === 'Settings') settingsOpen = true;
        }
    });
    
    updateNavIconStates();
    saveWindowLayout(); // Save the rescued positions
    console.log('Window rescue complete');
}

// Navigation functions
function updateNavIconStates() {
    const navIcons = document.querySelectorAll('.nav-icon');
    navIcons.forEach(icon => {
        icon.classList.remove('active');
    });
    
    if (chatOpen) {
        const chatIcon = document.querySelector('.nav-icon[onclick="openChat()"]');
        if (chatIcon) chatIcon.classList.add('active');
    }
    
    if (peopleOpen) {
        const peopleIcon = document.querySelector('.nav-icon[onclick="openPeople()"]');
        if (peopleIcon) peopleIcon.classList.add('active');
    }
    
    if (settingsOpen) {
        const settingsIcon = document.querySelector('.nav-icon[onclick="openSettings()"]');
        if (settingsIcon) settingsIcon.classList.add('active');
    }
}

// Chat functions
function openChat() {
    // Toggle chat window
    chatOpen = !chatOpen;
    const chatWindow = document.getElementById('chatWindow');
    
    if (chatOpen) {
        chatWindow.classList.add('open');
    } else {
        chatWindow.classList.remove('open');
    }
    
    updateNavIconStates();
    saveWindowLayout(); // Save layout when window opens/closes
}

function showChat() {
    // Only open chat window, don't toggle
    if (!chatOpen) {
        chatOpen = true;
        const chatWindow = document.getElementById('chatWindow');
        chatWindow.classList.add('open');
        updateNavIconStates();
        saveWindowLayout();
    }
}

function closeChat() {
    chatOpen = false;
    const chatWindow = document.getElementById('chatWindow');
    chatWindow.classList.remove('open');
    updateNavIconStates();
    saveWindowLayout(); // Save layout when window closes
}

function toggleChatSnap() {
    const chatWindow = document.getElementById('chatWindow');
    const pinButton = chatWindow.querySelector('.control-btn[onclick="toggleChatSnap()"]');
    chatSnapped = !chatSnapped;
    
    if (chatSnapped) {
        // Pin the window in its current position instead of snapping to bottom
        chatWindow.style.position = 'fixed';
        chatWindow.style.transform = 'none'; // Remove any transform
        chatWindow.classList.add('pinned'); // Add visual indicator
        if (pinButton) pinButton.classList.add('pinned');
    } else {
        // Unpin the window
        chatWindow.style.position = 'fixed';
        chatWindow.classList.remove('pinned'); // Remove visual indicator
        if (pinButton) pinButton.classList.remove('pinned');
    }
    
    // Save layout when snap state changes
    saveWindowLayout();
}

// People functions
function openPeople() {
    // Toggle people panel
    peopleOpen = !peopleOpen;
    const peoplePanel = document.getElementById('peoplePanel');
    
    if (peopleOpen) {
        peoplePanel.classList.add('open');
        populatePeopleModels();
    } else {
        peoplePanel.classList.remove('open');
    }
    
    updateNavIconStates();
    saveWindowLayout(); // Save layout when window opens/closes
}

function showPeople() {
    // Only open people panel, don't toggle
    if (!peopleOpen) {
        peopleOpen = true;
        const peoplePanel = document.getElementById('peoplePanel');
        peoplePanel.classList.add('open');
        populatePeopleModels();
        updateNavIconStates();
        saveWindowLayout();
    }
}

function closePeople() {
    peopleOpen = false;
    const peoplePanel = document.getElementById('peoplePanel');
    peoplePanel.classList.remove('open');
    updateNavIconStates();
    saveWindowLayout(); // Save layout when window closes
}

function togglePeopleSnap() {
    const peoplePanel = document.getElementById('peoplePanel');
    const pinButton = peoplePanel.querySelector('.control-btn[onclick="togglePeopleSnap()"]');
    peopleSnapped = !peopleSnapped;
    
    if (peopleSnapped) {
        // Pin the window in its current position
        peoplePanel.style.position = 'fixed';
        peoplePanel.classList.add('pinned'); // Add visual indicator
        if (pinButton) pinButton.classList.add('pinned');
    } else {
        // Unpin the window
        peoplePanel.style.position = 'fixed';
        peoplePanel.classList.remove('pinned'); // Remove visual indicator
        if (pinButton) pinButton.classList.remove('pinned');
    }
    
    // Save layout when snap state changes
    saveWindowLayout();
}

// Settings functions
function openSettings() {
    // Toggle settings panel
    settingsOpen = !settingsOpen;
    const settingsPanel = document.getElementById('settingsPanel');
    
    if (settingsOpen) {
        settingsPanel.classList.add('open');
    } else {
        settingsPanel.classList.remove('open');
    }
    
    updateNavIconStates();
    saveWindowLayout(); // Save layout when window opens/closes
}

function showSettings() {
    // Only open settings panel, don't toggle
    if (!settingsOpen) {
        settingsOpen = true;
        const settingsPanel = document.getElementById('settingsPanel');
        settingsPanel.classList.add('open');
        updateNavIconStates();
        saveWindowLayout();
    }
}

function closeSettings() {
    settingsOpen = false;
    const settingsPanel = document.getElementById('settingsPanel');
    settingsPanel.classList.remove('open');
    updateNavIconStates();
    saveWindowLayout(); // Save layout when window closes
}

function toggleSettingsSnap() {
    const settingsPanel = document.getElementById('settingsPanel');
    const pinButton = settingsPanel.querySelector('.control-btn[onclick="toggleSettingsSnap()"]');
    settingsSnapped = !settingsSnapped;
    
    if (settingsSnapped) {
        // Pin the window in its current position
        settingsPanel.style.position = 'fixed';
        settingsPanel.classList.add('pinned'); // Add visual indicator
        if (pinButton) pinButton.classList.add('pinned');
    } else {
        // Unpin the window
        settingsPanel.style.position = 'fixed';
        settingsPanel.classList.remove('pinned'); // Remove visual indicator
        if (pinButton) pinButton.classList.remove('pinned');
    }
    
    // Save layout when snap state changes
    saveWindowLayout();
}

// Additional navigation functions
function toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
    }
}

function toggleHelp() {
    // Show help modal or tooltip
    console.log('Help functionality - to be implemented');
    // This could open a help panel or show keyboard shortcuts
}

// People panel functionality
function populatePeopleModels() {
    const modelsList = document.getElementById('peopleModelsList');
    
    // Clear existing models
    modelsList.innerHTML = '';
    
    // Get loaded models from multi-model manager
    if (!live2dMultiModelManager) {
        modelsList.innerHTML = '<div style="text-align: center; padding: 20px; color: #aaa;">No models loaded</div>';
        return;
    }
    
    const loadedModels = live2dMultiModelManager.getAllModels();
    
    if (loadedModels.length === 0) {
        modelsList.innerHTML = '<div style="text-align: center; padding: 20px; color: #aaa;">No models loaded</div>';
        return;
    }
    
    loadedModels.forEach(modelData => {
        const isActive = live2dMultiModelManager.activeModelId === modelData.id;
        
        const modelItem = document.createElement('div');
        modelItem.className = `people-model-item ${isActive ? 'active' : ''}`;
        modelItem.innerHTML = `
            <div class="people-model-avatar">${modelData.characterImage ? `<img src="${modelData.characterImage}" alt="${modelData.name}">` : '👤'}</div>
            <div class="people-model-info">
                <div class="people-model-name">${modelData.name}</div>
                <div class="people-model-status">${isActive ? 'Active' : 'Inactive'}</div>
            </div>
            <button class="people-model-remove" onclick="event.stopPropagation(); removeModel('${modelData.id}')">×</button>
        `;
        
        modelItem.addEventListener('click', (e) => {
            if (!e.target.classList.contains('people-model-remove')) {
                if (live2dMultiModelManager) {
                    live2dMultiModelManager.setActiveModel(modelData.id);
                    // Refresh the panel to update active states
                    populatePeopleModels();
                }
            }
        });
        
        modelsList.appendChild(modelItem);
    });
}

function selectModel(modelId) {
    // Update active model
    document.querySelectorAll('.people-model-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Set the clicked model as active
    event.currentTarget.classList.add('active');
    
    // Update model name in settings
    const modelSelect = document.getElementById('modelSelect');
    if (modelSelect) {
        modelSelect.value = modelId;
        onModelChange();
    }
}

function removeModel(modelId) {
    // Remove model from multi-model manager
    if (live2dMultiModelManager) {
        live2dMultiModelManager.removeModel(modelId);
    }
    
    // Refresh the people panel
    populatePeopleModels();
}

function showAddModelDialog() {
    console.log('Opening add model dialog...');
    const dialog = document.getElementById('modelSelectionDialog');
    if (dialog) {
        dialog.style.display = 'flex';
        loadAvailableModelsForDialog();
    }
}

function closeAddModelDialog() {
    console.log('Closing add model dialog...');
    const dialog = document.getElementById('modelSelectionDialog');
    if (dialog) {
        dialog.style.display = 'none';
    }
}

async function loadAvailableModelsForDialog() {
    console.log('Loading available models for dialog...');
    const modelGrid = document.getElementById('modelGrid');
    
    try {
        // Use the already-loaded model list from the multi-model manager
        if (!live2dMultiModelManager || !live2dMultiModelManager.modelList || live2dMultiModelManager.modelList.length === 0) {
            // If not loaded yet, try to load
            await live2dMultiModelManager.loadAvailableModels();
        }
        
        const availableModels = live2dMultiModelManager.modelList;
        
        if (!availableModels || availableModels.length === 0) {
            modelGrid.innerHTML = '<div style="text-align: center; padding: 20px; color: #aaa;">No models available. Please check your model directory.</div>';
            return;
        }
        
        // Create model cards
        modelGrid.innerHTML = '';
        availableModels.forEach(model => {
            const modelCard = document.createElement('div');
            modelCard.className = 'model-card';
            modelCard.onclick = () => selectModelFromDialog(model.name, model.name);
            
            modelCard.innerHTML = `
                <div class="model-preview">
                    <div class="model-icon">🎭</div>
                </div>
                <div class="model-info">
                    <div class="model-name">${model.name}</div>
                    <div class="model-description">Live2D Model</div>
                </div>
            `;
            
            modelGrid.appendChild(modelCard);
        });
        
    } catch (error) {
        console.error('Error loading models for dialog:', error);
        modelGrid.innerHTML = '<div style="text-align: center; padding: 20px; color: #f44;">Error loading models. Please try again.</div>';
    }
}

function selectModelFromDialog(modelValue, modelName) {
    console.log('Selected model from dialog:', modelName, modelValue);
    
    // Add model using the multi-model manager
    if (live2dMultiModelManager) {
        live2dMultiModelManager.addModel(modelName).then(() => {
            console.log('Model added successfully:', modelName);
            // The people panel will be refreshed automatically by the multi-model manager
        }).catch(error => {
            console.error('Failed to add model:', error);
            addSystemMessage(`Failed to add model: ${error.message}`, 'error');
        });
    } else {
        console.error('Multi-model manager not available');
        addSystemMessage('Live2D system not ready', 'error');
    }
    
    // Close dialog
    closeAddModelDialog();
}

function addModelToPeoplePanel(modelValue, modelName) {
    const modelsList = document.getElementById('peopleModelsList');
    
    // Check if model already exists
    const existingModels = modelsList.querySelectorAll('.people-model-item');
    for (let model of existingModels) {
        if (model.dataset.modelValue === modelValue) {
            console.log('Model already in people panel');
            return;
        }
    }
    
    // Create new model item
    const modelItem = document.createElement('div');
    modelItem.className = 'people-model-item';
    modelItem.dataset.modelValue = modelValue;
    modelItem.onclick = () => {
        // Remove active class from all models
        const allModels = modelsList.querySelectorAll('.people-model-item');
        allModels.forEach(m => m.classList.remove('active'));
        
        // Add active class to clicked model
        modelItem.classList.add('active');
        
        // Load the model
        const modelSelect = document.getElementById('modelSelect');
        modelSelect.value = modelValue;
        onModelChange();
    };
    
    modelItem.innerHTML = `
        <div class="people-model-avatar">🎭</div>
        <div class="people-model-info">
            <div class="people-model-name">${modelName}</div>
            <div class="people-model-status">Ready</div>
        </div>
        <button class="people-model-remove" onclick="removeModelFromPeoplePanel(event, '${modelValue}')" title="Remove model">×</button>
    `;
    
    modelsList.appendChild(modelItem);
    console.log('Added model to people panel:', modelName);
}

function removeModelFromPeoplePanel(event, modelValue) {
    event.stopPropagation(); // Prevent triggering the model selection
    
    const modelsList = document.getElementById('peopleModelsList');
    const modelItem = modelsList.querySelector(`.people-model-item[data-model-value="${modelValue}"]`);
    
    if (modelItem) {
        modelItem.remove();
        console.log('Removed model from people panel:', modelValue);
    }
}

// Draggable functionality
function initializeDraggable() {
    const draggableElements = [
        { element: document.getElementById('chatWindow'), header: '.chat-header' },
        { element: document.getElementById('peoplePanel'), header: '.people-header' },
        { element: document.getElementById('settingsPanel'), header: '.settings-header' }
    ];
    
    draggableElements.forEach(({ element, header }) => {
        const headerElement = element.querySelector(header);
        if (headerElement) {
            headerElement.addEventListener('mousedown', (e) => startDrag(e, element));
        }
    });
    
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', stopDrag);
}

function startDrag(e, element) {
    // Check if the element is pinned and prevent dragging
    const pinButton = element.querySelector('.control-btn[onclick*="Snap"]');
    const isPinned = pinButton && pinButton.classList.contains('pinned');
    
    if (isPinned) {
        return; // Don't allow dragging if pinned
    }
    
    isDragging = true;
    currentDragElement = element;
    
    const rect = element.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;
    
    element.style.zIndex = '300';
    document.body.style.cursor = 'move';
}

function drag(e) {
    if (!isDragging || !currentDragElement) return;
    
    const x = e.clientX - dragOffset.x;
    const y = e.clientY - dragOffset.y;
    
    // Constrain to viewport
    const maxX = window.innerWidth - currentDragElement.offsetWidth;
    const maxY = window.innerHeight - currentDragElement.offsetHeight;
    
    const constrainedX = Math.max(0, Math.min(x, maxX));
    const constrainedY = Math.max(0, Math.min(y, maxY));
    
    currentDragElement.style.left = constrainedX + 'px';
    currentDragElement.style.top = constrainedY + 'px';
    currentDragElement.style.right = 'auto';
    currentDragElement.style.bottom = 'auto';
    currentDragElement.style.transform = 'none';
}

function stopDrag() {
    if (isDragging) {
        isDragging = false;
        if (currentDragElement) {
            currentDragElement.style.zIndex = '200';
        }
        currentDragElement = null;
        document.body.style.cursor = 'default';
        
        // Save layout when dragging stops
        saveWindowLayout();
    }
}

// Chat functionality
function handleChatKeyPress(event) {
    if (event.key === 'Enter') {
        sendMessage();
    }
}

function sendMessage() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();
    
    if (message) {
        // Add message to chat
        addMessageToChat('user', message);
        input.value = '';
        
        // Send to AI backend via SocketIO
        sendMessage(message);
    }
}

function addMessageToChat(sender, message) {
    const messagesContainer = document.getElementById('chatMessages');
    const messageElement = document.createElement('div');
    messageElement.className = `chat-message ${sender}`;
    messageElement.innerHTML = `
        <div class="message-content">${message}</div>
        <div class="message-time">${new Date().toLocaleTimeString()}</div>
    `;
    messagesContainer.appendChild(messageElement);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    // Load and apply saved window layout
    const savedLayout = loadWindowLayout();
    applyWindowLayout(savedLayout);
    
    // Initialize draggable functionality
    initializeDraggable();
    
    // Initialize navigation states
    updateNavIconStates();
    
    // Wait for all libraries to load properly
    setTimeout(async function() {
        console.log('Libraries loaded, checking availability...');
        
        // Check library availability
        if (typeof PIXI === 'undefined') {
            console.error('PIXI.js not loaded');
            return;
        }
        
        if (typeof EventEmitter === 'undefined') {
            console.error('EventEmitter not available');
            return;
        }
        
        console.log('PIXI version:', PIXI.VERSION);
        console.log('EventEmitter available:', typeof EventEmitter !== 'undefined');
        
        // Initialize the Live2D system
        await initializeLive2D();
    }, 1000); // Increased delay to ensure libraries are loaded
});

// Save layout on window resize and before page unload
window.addEventListener('resize', function() {
    // Debounce resize events to avoid excessive saves
    clearTimeout(window.resizeTimeout);
    window.resizeTimeout = setTimeout(saveWindowLayout, 500);
});

window.addEventListener('beforeunload', function() {
    saveWindowLayout();
});

// ===============================================================================
// ENHANCED AI COMPANION FUNCTIONALITY
// ===============================================================================

// Voice Recording System
let isRecording = false;
let mediaRecorder = null;
let audioChunks = [];

async function toggleVoiceRecording() {
    const voiceButton = document.getElementById('voiceButton');
    
    if (!isRecording) {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            audioChunks = [];
            
            mediaRecorder.ondataavailable = event => {
                audioChunks.push(event.data);
            };
            
            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                await sendAudioToServer(audioBlob);
                
                // Stop all tracks to turn off microphone
                stream.getTracks().forEach(track => track.stop());
            };
            
            mediaRecorder.start();
            isRecording = true;
            voiceButton.innerHTML = '🛑';
            voiceButton.style.backgroundColor = '#ff4444';
            console.log('🎤 Voice recording started');
            
        } catch (error) {
            console.error('Error accessing microphone:', error);
            addSystemMessage('Microphone access denied or not available', 'error');
        }
    } else {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
        }
        isRecording = false;
        voiceButton.innerHTML = '🎤';
        voiceButton.style.backgroundColor = '';
        console.log('🛑 Voice recording stopped');
    }
}

async function sendAudioToServer(audioBlob) {
    try {
        const formData = new FormData();
        formData.append('audio', audioBlob, 'recording.wav');
        
        // Use the same fallback system as other API calls
        let apiBaseUrl = window.ai2d_chat_CONFIG?.API_BASE_URL;
        let response;
        
        // Try primary API URL first
        if (apiBaseUrl) {
            try {
                response = await fetch(`${apiBaseUrl}/api/speech-to-text`, {
                    method: 'POST',
                    body: formData
                });
                if (response.ok) {
                    const data = await response.json();
                    if (data.text) {
                        document.getElementById('chatInput').value = data.text;
                        addSystemMessage(`Voice transcribed: "${data.text}"`, 'success');
                    }
                    return;
                }
            } catch (error) {
                console.warn(`Speech-to-text API failed with primary URL ${apiBaseUrl}:`, error.message);
            }
        }
        
        // Try fallback URLs if primary failed
        const fallbackUrls = window.ai2d_chat_CONFIG?.FALLBACK_URLS || [];
        for (const fallbackUrl of fallbackUrls) {
            try {
                console.log(`Trying speech-to-text API fallback URL: ${fallbackUrl}`);
                response = await fetch(`${fallbackUrl}/api/speech-to-text`, {
                    method: 'POST',
                    body: formData
                });
                if (response.ok) {
                    console.log(`Speech-to-text API successful with fallback URL: ${fallbackUrl}`);
                    // Update the working URL for future requests
                    window.ai2d_chat_CONFIG.API_BASE_URL = fallbackUrl;
                    const data = await response.json();
                    if (data.text) {
                        document.getElementById('chatInput').value = data.text;
                        addSystemMessage(`Voice transcribed: "${data.text}"`, 'success');
                    }
                    return;
                }
            } catch (error) {
                console.warn(`Speech-to-text API fallback failed with ${fallbackUrl}:`, error.message);
            }
        }
        
        // If all URLs failed, throw error
        throw new Error('All speech-to-text API endpoints failed');
        
    } catch (error) {
        console.error('Error sending audio to server:', error);
        addSystemMessage('Failed to process voice recording', 'error');
    }
}

// Enhanced Chat System
function handleChatKeyPress(event) {
    if (event.key === 'Enter') {
        sendMessage();
    }
}

async function sendMessage() {
    const chatInput = document.getElementById('chatInput');
    const chatMessages = document.getElementById('chatMessages');
    const text = chatInput.value.trim();
    
    if (!text) return;
    
    // Add user message to chat
    addChatMessage('user', text);
    chatInput.value = '';
    
    try {
        // Use the same fetchWithFallback system as Live2D models
        let apiBaseUrl = window.ai2d_chat_CONFIG?.API_BASE_URL;
        let response;
        
        // Try primary API URL first
        if (apiBaseUrl) {
            try {
                response = await fetch(`${apiBaseUrl}/api/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: text })
                });
                if (response.ok) {
                    const data = await response.json();
                    
                    // Add AI response to chat
                    addChatMessage('ai', data.reply || '[No reply]');
                    
                    // Play TTS if available
                    if (data.tts_data) {
                        playEmotionalTTSAudio(data.tts_data);
                    }
                    
                    // Trigger Live2D emotion/motion if available
                    if (data.emotion && window.live2dIntegration) {
                        triggerEmotionalResponse(data.emotion, data.intensity || 0.5);
                    }
                    return;
                }
            } catch (error) {
                console.warn(`Enhanced chat API failed with primary URL ${apiBaseUrl}:`, error.message);
            }
        }
        
        // Try fallback URLs if primary failed
        const fallbackUrls = window.ai2d_chat_CONFIG?.FALLBACK_URLS || [];
        for (const fallbackUrl of fallbackUrls) {
            try {
                console.log(`Trying enhanced chat API fallback URL: ${fallbackUrl}`);
                response = await fetch(`${fallbackUrl}/api/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: text })
                });
                if (response.ok) {
                    console.log(`Enhanced chat API successful with fallback URL: ${fallbackUrl}`);
                    // Update the working URL for future requests
                    window.ai2d_chat_CONFIG.API_BASE_URL = fallbackUrl;
                    const data = await response.json();
                    
                    // Add AI response to chat
                    addChatMessage('ai', data.reply || '[No reply]');
                    
                    // Play TTS if available
                    if (data.tts_data) {
                        playEmotionalTTSAudio(data.tts_data);
                    }
                    
                    // Trigger Live2D emotion/motion if available
                    if (data.emotion && window.live2dIntegration) {
                        triggerEmotionalResponse(data.emotion, data.intensity || 0.5);
                    }
                    return;
                }
            } catch (error) {
                console.warn(`Enhanced chat API fallback failed with ${fallbackUrl}:`, error.message);
            }
        }
        
        // If all URLs failed, throw error
        throw new Error('All enhanced chat API endpoints failed');
        
    } catch (error) {
        console.error('Error sending message:', error);
        addChatMessage('system', `Failed to send message: ${error.message}`, 'error');
    }
}

function addChatMessage(sender, message, type = 'info') {
    const chatMessages = document.getElementById('chatMessages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `chat-message ${sender} ${type}`;
    
    const timestamp = new Date().toLocaleTimeString();
    messageDiv.innerHTML = `
        <div class="message-content">${escapeHtml(message)}</div>
        <div class="message-time">${timestamp}</div>
    `;
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Enhanced Debug Console
function toggleDebugConsole() {
    const debugPanel = document.getElementById('debugUIPanel');
    if (debugPanel.style.display === 'none' || !debugPanel.style.display) {
        debugPanel.style.display = 'block';
        console.log('🔍 Debug console opened');
    } else {
        debugPanel.style.display = 'none';
        console.log('🔍 Debug console closed');
    }
}

// Live2D Emotional Response Integration
function triggerEmotionalResponse(emotion, intensity = 0.5) {
    if (!window.live2dIntegration || !window.live2dIntegration.motionManager) {
        console.warn('Live2D integration not available for emotional response');
        return;
    }
    
    // Map emotions to Live2D motions
    const emotionMotionMap = {
        'happy': 'idle',
        'excited': 'head',
        'sad': 'body',
        'surprised': 'expression',
        'curious': 'special',
        'thoughtful': 'talk'
    };
    
    const motionType = emotionMotionMap[emotion] || 'idle';
    
    console.log(`🎭 Triggering emotional response: ${emotion} (${motionType})`);
    
    // Trigger motion via Live2D integration
    if (typeof window.triggerMotion === 'function') {
        window.triggerMotion(motionType);
    }
}

// SocketIO Integration
let socket = null;

function initializeSocketIO() {
    if (typeof io !== 'undefined') {
        socket = io();
        
        socket.on('connect', function() {
            console.log('🔌 Connected to server via SocketIO');
            addSystemMessage('Connected to AI live2d chat server', 'success');
        });
        
        socket.on('disconnect', function() {
            console.log('🔌 Disconnected from server');
            addSystemMessage('Disconnected from server', 'warning');
        });
        
        socket.on('ai_response', function(data) {
            console.log('📨 Received AI response via SocketIO:', data);
            addChatMessage('ai', data.message);
            
            if (data.tts_data) {
                playEmotionalTTSAudio(data.tts_data);
            }
            
            if (data.emotion) {
                triggerEmotionalResponse(data.emotion, data.intensity);
            }
        });
        
        socket.on('motion_trigger', function(data) {
            console.log('🎭 Received motion trigger:', data);
            if (data.motion_type && typeof window.triggerMotion === 'function') {
                window.triggerMotion(data.motion_type);
            }
        });
        
        console.log('🔌 SocketIO initialized');
    } else {
        console.warn('⚠️ SocketIO not available');
    }
}

// Performance Testing Functions
function testLoadingPerformance() {
    console.log('Testing model loading performance...');
    if (live2dMultiModelManager) {
        // Test loading performance with current models
        console.log('Performance test: Measuring model loading times');
        // Implementation would go here - for now just log
    } else {
        console.log('No Live2D manager available for performance testing');
    }
}

function benchmarkModelSwitching() {
    console.log('Benchmarking model switching performance...');
    if (live2dMultiModelManager) {
        // Test model switching speed
        console.log('Performance test: Measuring model switching speed');
        // Implementation would go here - for now just log
    } else {
        console.log('No Live2D manager available for benchmarking');
    }
}

function displayPerformanceStats() {
    console.log('Displaying performance statistics...');
    if (live2dMultiModelManager) {
        // Display performance statistics
        const models = live2dMultiModelManager.getAllModels();
        console.log(`Performance Stats:
- Total models loaded: ${models.length}
- Active model: ${live2dMultiModelManager.activeModelId || 'None'}
- Memory usage: ${(performance.memory ? performance.memory.usedJSHeapSize / 1024 / 1024 : 'Unknown')} MB`);
    } else {
        console.log('No Live2D manager available for performance stats');
    }
}

function clearPerformanceCache() {
    console.log('Clearing performance cache...');
    // Clear any cached performance data
    // Implementation would go here - for now just log
    console.log('Performance cache cleared');
}

// System Utility Functions
function addSystemMessage(message, type = 'info') {
    addChatMessage('system', message, type);
}

// Initialize enhanced features when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    console.log('🚀 Initializing AI Companion enhanced features...');
    
    // Initialize SocketIO after a short delay
    setTimeout(() => {
        initializeSocketIO();
    }, 2000);
    
    console.log('✅ AI Companion enhanced features initialized');
});

</script>
</body>
</html>
