<!--
  index.html
  Modern two-column layout: model on the left (centered vertically), controls on the right.
  Based on working backup as of 2025-06-10.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Companion - Live2D Model Viewer</title>
    <link rel="stylesheet" href="/static/css/demo.css">
    <style>
        body {
            /* background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); */
            min-height: 100vh;
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }
        .main-layout {
            display: flex;
            height: 100vh;
            position: relative;
        }
        
        .control-column {
            flex: 1; /* Take remaining space */
            background: rgba(255,255,255,0.92);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: stretch;
            padding: 2.5rem 2rem;
            min-width: 400px;
            box-shadow: -4px 0 24px rgba(102,126,234,0.08);
            z-index: 10; /* Ensure control column is above model */
            position: relative;
        }
        
        .model-column {
            flex: 0 0 600px; /* Fixed 800px width */
            width: 600px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.92);
            min-width: 0;
            height: 100vh;
            flex-direction: column;
        }
        .canvas-container {
            position: relative;
            width: 100%; /* Take full width of parent model column */
            max-width: none; /* Remove max-width restriction */
            min-width: 0;
            height: 80vh; /* Use viewport height instead of fixed height */
            max-height: none; /* Remove max-height restriction */
            aspect-ratio: 7/6; /* maintain aspect ratio for large models */
            /* Remove background, border-radius, and box-shadow for no box effect */
            margin: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            background: none;
            border-radius: 0;
            box-shadow: none;
            overflow: hidden; /* Prevent model from overflowing container */
        }
        #live2d2, #live2d4 {
            position: absolute;
            top: 0; left: 0;
            width: 600px;
            height: 100%;
            z-index: -1; /* Move model behind other UI elements */
            transform: scale(2) translateX(-50px); /* Scale model larger and move 100px left (50px at 2x scale) */
            transform-origin: center center; /* Scale from center */
            image-rendering: -webkit-optimize-contrast; /* Webkit browsers */
            filter: contrast(1.1) brightness(1.05) saturate(1.1); /* Enhance clarity */
            -webkit-font-smoothing: antialiased;
            cursor: pointer; /* Show pointer cursor for interaction */
        }
        #live2d4 {
            /* Remove debug background and border */
            background: none;
            border: none;
            z-index: -1; /* Move model behind other UI elements */
            transform: scale(2) translateX(-50px); /* Scale model larger and move 100px left (50px at 2x scale) */
            transform-origin: center center; /* Scale from center */
            image-rendering: -webkit-optimize-contrast; /* Webkit browsers */
            filter: contrast(1.1) brightness(1.05) saturate(1.1); /* Enhance clarity */
            -webkit-font-smoothing: antialiased;
            cursor: pointer; /* Show pointer cursor for interaction */
        }
        .canvas-overlay {
            position: absolute;
            top: 10px; left: 10px;
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 0.9rem;
            z-index: 2;
        }
        /* Center status bar and model selector horizontally in control column */
        .status-and-selector {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1em;
            margin-top: 1.2em;
            margin-bottom: 0.5em;
        }
        .status-bar {
            margin: 0;
            text-align: center;
            font-size: 1rem;
        }
        .model-selector {
            margin: 0;
            background: none;
            box-shadow: none;
            padding: 0;
            text-align: left;
        }
        .model-selector label {
            color: #333;
            font-weight: 500;
            margin-right: 0.5em;
        }
        .header {
            margin-bottom: 2rem;
            text-align: center;
        }
        .header h1 {
            color: #333;
            font-size: 2rem;
            font-weight: 400;
        }
        .chat-section {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        #chat-window {
            flex: 1;
            background: #fff;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            overflow-y: auto;
            margin-bottom: 1rem;
            z-index: 5;
            position: relative;
        }
        .debug-panel {
            margin-top: 1.5rem;
            background: #222;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            border-radius: 6px;
            padding: 1rem;
            min-height: 80px;
            max-height: 180px;
            overflow-y: auto;
            display: none;
        }
        .debug-panel.visible { display: block; }
        
        /* Enhanced Debug UI Panel */
        .debug-ui-panel {
            margin-top: 1rem;
            background: rgba(0, 0, 0, 0.9);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            border-radius: 8px;
            padding: 1rem;
            border: 2px solid #333;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 5;
            position: relative;
        }
        
        .debug-header {
            color: #00ffff;
            font-weight: bold;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid #333;
            padding-bottom: 0.3rem;
        }
        
        .debug-section {
            margin-bottom: 0.8rem;
        }
        
        .debug-section h4 {
            color: #ffff00;
            margin: 0 0 0.3rem 0;
            font-size: 0.9rem;
        }
        
        .debug-item {
            margin: 0.2rem 0;
            padding-left: 1rem;
        }
        
        .debug-status-ok { color: #00ff00; }
        .debug-status-warn { color: #ffaa00; }
        .debug-status-error { color: #ff0000; }
        
        .debug-log {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            border-radius: 4px;
            padding: 0.5rem;
            max-height: 120px;
            overflow-y: auto;
            font-size: 0.75rem;
        }
        
        .debug-controls {
            margin-top: 0.5rem;
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .debug-btn {
            background: #333;
            color: #00ff00;
            border: 1px solid #555;
            border-radius: 3px;
            padding: 0.3rem 0.6rem;
            font-size: 0.75rem;
            font-family: 'Segoe UI', 'Arial', sans-serif;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .debug-btn:hover {
            background: #444;
            border-color: #777;
        }
        /* Chat Message Styles */
        .message {
            margin-bottom: 1rem;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s ease;
        }
        .message.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .message.user {
            text-align: right;
        }
        .message.ai {
            text-align: left;
        }
        .message.system {
            text-align: center;
            opacity: 0.7;
        }
        .message-content {
            display: inline-block;
            max-width: 85%;
            padding: 0.75rem 1rem;
            border-radius: 18px;
            background: #f0f0f0;
            color: #333;
        }
        .message.user .message-content {
            background: #667eea;
            color: white;
        }
        .message.ai .message-content {
            background: #e8f0ff;
            color: #333;
        }
        .message.system .message-content {
            background: #ffeb3b;
            color: #333;
            font-size: 0.9rem;
        }
        .message.system.error .message-content {
            background: #f44336;
            color: white;
        }
        .message-header {
            font-size: 0.8rem;
            margin-bottom: 0.3rem;
            opacity: 0.8;
        }
        .timestamp {
            font-weight: normal;
            margin-left: 0.5rem;
        }
        .message-text {
            line-height: 1.4;
        }
        /* Input and Button Styles */
        #user-input {
            padding: 0.75rem 1rem;
            border: 2px solid #ddd;
            border-radius: 25px;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.3s ease;
        }
        #user-input:focus {
            border-color: #667eea;
        }
        #send-button, #voice-button {
            padding: 0.75rem 1.5rem;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        #send-button:hover, #voice-button:hover {
            background: #5a6fd8;
        }
        /* Status Indicator */
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }
        .status-indicator.success { background: #4caf50; }
        .status-indicator.error { background: #f44336; }
        .status-indicator.info { background: #2196f3; }
        /* Loading Spinner */
        .loading-spinner {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            z-index: 3;
        }
        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }
        /* Live2D Waifu Widget Styles */
        #waifu {
            position: relative;
            width: 100%;
            height: 600px;
            z-index: 1;
        }
        #waifu-message {
            position: absolute;
            top: 10px;
            left: 10px;
            max-width: 300px;
            min-height: 40px;
            padding: 8px 12px;
            background-color: rgba(76,191,255,0.8);
            color: white;
            border-radius: 12px;
            box-shadow: 0 3px 15px 2px rgba(16,51,49,0.3);
            font-size: 14px;
            line-height: 1.4;
            z-index: 999;
            display: none;
            word-wrap: break-word;
        }
        .waifu-tool {
            position: absolute;
            top: 130px;
            left: 10px;
            display: none;
            flex-direction: column;
            gap: 8px;
            z-index: 998;
        }
        #waifu:hover .waifu-tool {
            display: flex;
        }
        .waifu-tool > span {
            display: block;
            width: 32px;
            height: 32px;
            background: rgba(0,150,255,0.8);
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 32px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 16px;
        }
        .waifu-tool > span:hover {
            background: rgba(67,203,255,0.9);
            transform: scale(1.1);
        }
        .waifu-tool > span.hide {
            display: none;
        }
        #waifu.hide {
            display: none;
        }
        /* Icon fonts for waifu tools */
        .icon-next::before { content: "🔄"; }
        .icon-home::before { content: "🏠"; }
        .icon-message::before { content: "💬"; }
        .icon-camera::before { content: "📷"; }
        .icon-volumeup::before { content: "🔊"; }
        .icon-volumedown::before { content: "🔉"; }
        .icon-about::before { content: "🔍"; }
        .icon-cross::before { content: "❌"; }
    </style>
</head>
<body>
<div class="main-layout">
    <div class="model-column">
        <div class="canvas-container">
            <!-- Live2D Widget Structure Required by waifu-tips.js -->
            <div id="waifu">
                <div id="waifu-message"></div>
                <div class="waifu-tool">
                    <span class="icon-next" title="Switch Model"></span>
                    <span class="icon-home" title="Home"></span>
                    <span class="icon-message" title="Message"></span>
                    <span class="icon-camera" title="Screenshot"></span>
                    <span class="icon-volumeup" title="Volume Up"></span>
                    <span class="icon-volumedown" title="Volume Down"></span>
                    <span class="icon-about" title="Debug Motions"></span>
                    <span class="icon-cross" title="Close"></span>
                </div>
                <canvas id="live2d2" width="800" height="600"></canvas>
                <canvas id="live2d4" width="800" height="600"></canvas>
            </div>
            <div class="loading-spinner" id="loadingSpinner"></div>
        </div>
    </div>
    <div class="control-column">
        <div class="header"><h1>🤖 AI Companion Chat</h1></div>
        <div class="chat-section">
            <div id="chat-window"></div>
            <div style="display:flex;gap:0.5em;margin-top:1em;">
                <input type="text" id="user-input" placeholder="Type your message..." style="flex:1;" />
                <button id="send-button">Send</button>
                <button id="voice-button">🎤</button>
            </div>
        </div>
        <div class="status-and-selector">
            <div class="status-bar">
                <span class="status-indicator info" id="statusIndicator"></span>
                <span id="statusText">Ready</span>
            </div>
        </div>
        <div class="debug-panel" id="debugPanel"></div>
        
        <!-- Enhanced Debug Console -->
        <div class="debug-ui-panel" id="debugUIPanel" style="display: none;">
            <div class="debug-header">
                🔍 Live2D AI Companion Debug Console
                <button class="debug-close-btn" onclick="toggleDebugConsole()" style="float: right; background: none; border: none; color: #ff4444; cursor: pointer; font-size: 16px;">✕</button>
            </div>
            
            <div class="debug-section">
                <h4>System Status</h4>
                <div class="debug-item" id="debug-sdk-status">SDK: <span class="debug-status-warn">Checking...</span></div>
                <div class="debug-item" id="debug-canvas-status">Canvas: <span class="debug-status-warn">Initializing...</span></div>
            </div>
            
            <div class="debug-section">
                <h4>Model Info</h4>
                <div class="debug-item" id="debug-model-name">Name: <span id="debug-current-model">None</span></div>
                <div class="debug-item" id="debug-motion-groups">Motion Groups: <span id="debug-motion-count">0</span></div>
                <div class="debug-item" id="debug-last-motion">Last Motion: <span id="debug-last-motion-name">None</span></div>
                <div class="debug-item" id="debug-available-models">Available Models: <span id="debug-models-list">Loading...</span></div>
            </div>
            
            <div class="debug-section">
                <h4>Database Info</h4>
                <div class="debug-item" id="debug-db-models">DB Models: <span id="debug-db-model-count">-</span></div>
                <div class="debug-item" id="debug-db-motions">DB Motions: <span id="debug-db-motion-count">-</span></div>
                <div class="debug-item" id="debug-db-status">DB Connection: <span id="debug-db-connection">Unknown</span></div>
            </div>
            
            <div class="debug-section">
                <h4>System Operations</h4>
                <div class="debug-controls" style="flex-wrap: wrap; gap: 0.25rem;">
                    <button class="debug-btn" onclick="debugRefreshAll()" title="Refresh all status information">🔄 Refresh All</button>
                    <button class="debug-btn" onclick="debugTestSystem()" title="Run comprehensive system test">🧪 System Test</button>
                    <button class="debug-btn" onclick="debugDatabaseInfo()" title="Load database information">💾 DB Info</button>
                    <button class="debug-btn" onclick="debugClearDatabase()" title="Clear database (WARNING: Destructive)" style="background: #ff4444;">🗑 Clear DB</button>
                    <button class="debug-btn" onclick="debugReimportData()" title="Re-import all models and motions" style="background: #ff9800;">📥 Re-import</button>
                </div>
            </div>
            
            <div class="debug-section">
                <h4>Model Operations</h4>
                <div class="debug-controls" style="flex-wrap: wrap; gap: 0.25rem;">
                    <button class="debug-btn" onclick="debugTestMotion()" title="Test a random motion">🎭 Test Motion</button>
                    <button class="debug-btn" onclick="debugLogMotions()" title="Log available motions to console">📝 Log Motions</button>
                    <button class="debug-btn" onclick="debugModelStructure()" title="Analyze model structure">🔍 Structure</button>
                    <button class="debug-btn" onclick="debugLive2D()" title="Debug Live2D system">🔍 Debug L2D</button>
                    <button class="debug-btn" onclick="debugLoadDefaultModel()" title="Load default model" id="debug-load-default-model" style="display:none;background:#4caf50;">📦 Load Model</button>
                </div>
            </div>
            
            <div class="debug-section">
                <h4>Real-time Log</h4>
                <div class="debug-log" id="debug-realtime-log">
                    🔍 Debug console initialized. Use buttons above to run tests...
                </div>
                <div class="debug-controls" style="margin-top: 0.5rem;">
                    <button class="debug-btn" onclick="debugClearLog()" title="Clear debug log">🗑 Clear Log</button>
                    <button class="debug-btn" onclick="debugToggleVerbose()" title="Toggle verbose logging">💬 Verbose</button>
                    <button class="debug-btn" onclick="debugExportLog()" title="Export log to console">📤 Export Log</button>
                </div>
            </div>
        </div>
        
    </div>
</div>
<script src="/static/js/live2d_config.js"></script>
<script src="/static/dist/live2d_bundle.js"></script>
<!-- <script type="module" src="/static/js/waifu-tips.js"></script> -->
<script src="https://cdn.socket.io/4.5.0/socket.io.min.js"></script>
<script>
// Global variables
let currentModel = null;
let lastInteractionTime = Date.now();

// Debug system variables - initialize early to prevent "before initialization" errors
let debugLogBuffer = [];
let debugLastMotionName = null;
let debugVerboseMode = false;
const MAX_DEBUG_LOG_ENTRIES = 50;

// DOM element references - declare early so they're available to all functions
let modelInfo, statusText, statusIndicator, debugPanel, loadingSpinner;
let chatWindow, userInput, sendButton, voiceButton;

// Debug UI Elements
let debugSDKStatus, debugModelStatus, debugCanvasStatus;
let debugCurrentModel, debugMotionCount;
let debugRealtimeLog;

// Initialize DOM references after page loads
function initDOMReferences() {
    modelInfo = document.getElementById('statusText'); // Use statusText as modelInfo equivalent
    statusText = document.getElementById('statusText');
    statusIndicator = document.getElementById('statusIndicator');
    debugPanel = document.getElementById('debugPanel');
    loadingSpinner = document.getElementById('loadingSpinner');
    chatWindow = document.getElementById('chat-window');
    userInput = document.getElementById('user-input');
    sendButton = document.getElementById('send-button');
    voiceButton = document.getElementById('voice-button');
}

// --- PATCH: Ensure waifu-tips.json is loaded from the correct path ---
if (window.live2d_settings) {
    window.live2d_settings.tipsMessage = '/static/js/waifu-tips.json';
    window.live2d_settings.modelUrl = '/static/assets';
}
if (window.live2d_models) {
    // Patch model list to use correct configFile for kanade
    for (const model of window.live2d_models) {
        if (model.name === 'kanade' || model.name === 'v2_kanade') {
            model.configFile = '17kanade_unit2_t04.model3.json';
        }
        if (model.name === 'miku') {
            model.configFile = 'miku_t01.model3.json';
        }
        if (model.name === 'kuromi') {
            model.configFile = 'sub_sanrio_kuromi_t10.model3.json';
        }
    }
}
// Patch waifu-tips.js loadModel to always use configFile if present
if (window.live2dv4 && window.live2d_models) {
    const origLoadModel = window.loadModel;
    window.loadModel = function(modelName) {
        const modelObj = window.live2d_models.find(m => m.name === modelName);
        const configFile = modelObj && modelObj.configFile ? modelObj.configFile : `${modelName}.model3.json`;
        window.live2dv4.load('live2d4', `/static/assets/${modelName}`, configFile);
    };
}

// --- Live2D Model Path Fix ---

function loadModel(modelName) {
    // Clear previous model first
    if (currentModel && window.live2dv4) {
        try {
            // Proper model disposal to fix switching issues
            window.live2dv4.release();
            console.log(`🗑️ Released previous model: ${currentModel}`);
        } catch (e) {
            console.warn('Failed to release previous model:', e);
        }
    }
    
    // Do NOT hide both canvases here (fixes flashing/disappearing)
    // Only set the correct canvas to display:block
    const canvas2D = document.getElementById('live2d2');
    const canvas4D = document.getElementById('live2d4');
    // Always show SDK4 canvas for all current models
    canvas4D.style.display = 'block';
    canvas2D.style.display = 'none';
    modelInfo.textContent = `Loading model: ${modelName}...`;
    
    // Save to localStorage as last used model
    setLastUsedModel(modelName);
    
    // Get model config from database API instead of hardcoded mapping
    console.log('[Live2D DEBUG] Fetching model config from database...');
    fetch(`/api/live2d/models`)
        .then(response => response.json())
        .then(models => {
            const modelData = models.find(m => m.model_name === modelName);
            if (!modelData) {
                throw new Error(`Model ${modelName} not found in database`);
            }
            
            const modelJsonFile = modelData.config_file;
            const modelFolder = `/static/assets/${modelName}`;
            console.log('[Live2D DEBUG] Loading model:', modelName, 'from', modelFolder, 'with JSON', modelJsonFile);
            
            // Use Live2dOnWeb global API with improved loading detection
            if (window.live2dv4 && window.live2dv4.load) {
                showLoadingSpinner();
                console.log('🚀 Starting Live2D model load...');
                
                // Start the load process
                window.live2dv4.load('live2d4', modelFolder, modelJsonFile);
                
                // Enhanced polling for model load completion
                let pollCount = 0;
                const maxPolls = 150; // 15s at 100ms interval (increased timeout)
                const pollInterval = setInterval(() => {
                    pollCount++;
                    
                    // Multiple detection methods
                    const detectionMethods = [
                        // Method 1: Check if _model exists (REQUIRED for motion detection)
                        () => window.live2dv4._model,
                        // Method 2: Check if we can find the Cubism model instance
                        () => {
                            if (window.Live2DCubismFramework && window.Live2DCubismFramework.CubismFramework) {
                                const framework = window.Live2DCubismFramework.Cubism.Framework;
                                if (framework.isInitialized && framework.isInitialized()) {
                                    console.log('🎯 Cubism Framework detected and initialized');
                                    return true;
                                }
                            }
                            return false;
                        },
                        // Method 3: Check if startMotion exists
                        () => window.live2dv4.startMotion,
                        // Method 4: Check for canvas content (model rendered)
                        () => {
                            const canvas = document.getElementById('live2d4');
                            if (canvas) {
                                const ctx = canvas.getContext('2d');
                                if (ctx) {
                                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                                    for (let i = 3; i < imageData.data.length; i += 4) {
                                        if (imageData.data[i] > 0) {
                                            console.log('🎯 Model detected via canvas rendering');
                                            return true;
                                        }
                                    }
                                }
                            }
                            return false;
                        },
                        // Method 5: Check if isModelLoaded exists and returns true
                        () => window.live2dv4.isModelLoaded && window.live2dv4.isModelLoaded()
                    ];
                    
                    let isLoaded = false;
                    let modelExists = false;
                    let otherMethodPassed = false;
                    
                    try {
                        modelExists = detectionMethods[0]();
                        if (modelExists) {
                            console.log('✅ Method 1: window.live2dv4._model exists');
                        }
                    } catch (e) {}
                    
                    for (let i = 1; i < detectionMethods.length; i++) {
                        try {
                            if (detectionMethods[i]()) {
                                otherMethodPassed = true;
                                console.log(`✅ Model load detected via method ${i + 1}`);
                                break;
                            }
                        } catch (e) {}
                    }
                    
                    isLoaded = modelExists && otherMethodPassed;
                    
                    if (isLoaded) {
                        console.log('🎉 Model load completed with _model available!');
                        clearInterval(pollInterval);
                        hideLoadingSpinner();
                        
                        console.log('🎉 Model load completed successfully!');
                        console.log('🔍 Available Live2D methods:', Object.keys(window.live2dv4));
                        
                        // Patch motion API
                        patchMotionAPI();
                        
                        modelInfo.textContent = `Model loaded: ${modelName}`;
                        statusText.textContent = 'Model loaded';
                        statusIndicator.className = 'status-indicator success';
                        currentModel = modelName;
                        
                        // Update debug/status panels
                        if (typeof updateModelInfo === 'function') updateModelInfo();
                        if (typeof updateDatabaseInfo === 'function') updateDatabaseInfo();
                        if (typeof updateDebugUIPanel === 'function') updateDebugUIPanel();
                        
                        setTimeout(() => {
                            console.log('🖱️ Setting up mouse tracking...');
                            setupMouseTracking();
                        }, 500);
                        
                        setTimeout(() => {
                            console.log('🎭 Starting idle motion system...');
                            startIdleMotionSystem();
                        }, 1000);
                        
                        setTimeout(() => {
                            console.log('🔍 Debugging model structure...');
                            debugModelStructure();
                        }, 1500);
                        
                        setTimeout(() => {
                            console.log('📋 Logging available motions...');
                            logAvailableMotions();
                        }, 2000);
                        
                        setTimeout(() => {
                            console.log('🧪 Running Live2D debug...');
                            if (window.debugLive2D) {
                                window.debugLive2D();
                            }
                        }, 3000);
                        
                        setTimeout(() => {
                            console.log('🎭 Testing motion functionality...');
                            testMotionMethods();
                        }, 4000);
                        
                    } else if (pollCount > maxPolls) {
                        clearInterval(pollInterval);
                        hideLoadingSpinner();
                        
                        console.error('❌ Model load timeout after 15 seconds');
                        console.log('🔍 Available Live2D methods:', Object.keys(window.live2dv4 || {}));
                        
                        modelInfo.textContent = `Failed to load model: ${modelName}`;
                        statusText.textContent = 'Model load failed';
                        statusIndicator.className = 'status-indicator error';
                        currentModel = null;
                        if (typeof updateModelInfo === 'function') updateModelInfo();
                        if (typeof updateDatabaseInfo === 'function') updateDatabaseInfo();
                        if (typeof updateDebugUIPanel === 'function') updateDebugUIPanel();
                    } else if (pollCount % 20 === 0) {
                        console.log(`⏳ Model loading... (${pollCount/10}s elapsed)`);
                        console.log(`   _model exists: ${!!window.live2dv4?._model}`);
                        console.log(`   startMotion exists: ${!!window.live2dv4?.startMotion}`);
                        console.log(`   Framework initialized: ${!!(window.Live2DCubismFramework?.CubismFramework?.isInitialized?.())}`);
                    }
                }, 100);
            } else {
                modelInfo.textContent = 'Live2D SDK not loaded';
                statusText.textContent = 'Live2D SDK not loaded';
                statusIndicator.className = 'status-indicator error';
                if (debugPanel) {
                    debugPanel.innerText = 'Live2D SDK not loaded. Check live2d_bundle.js.';
                    debugPanel.classList.add('visible');
                }
                return;
            }
        })
        .catch(error => {
            modelInfo.textContent = `Failed to load model: ${modelName}`;
            statusText.textContent = 'Model load failed';
            statusIndicator.className = 'status-indicator error';
            currentModel = null;
            if (typeof updateModelInfo === 'function') updateModelInfo();
            if (typeof updateDatabaseInfo === 'function') updateDatabaseInfo();
            if (typeof updateDebugUIPanel === 'function') updateDebugUIPanel();
            console.error('❌ Error loading model config:', error);
            if (debugPanel) {
                debugPanel.innerText = `Error loading model config: ${error.message}`;
                debugPanel.classList.add('visible');
            }
        });
}

// Local storage functions for last used model
function getLastUsedModel() {
    try {
        return localStorage.getItem('lastUsedModel');
    } catch (e) {
        return null;
    }
}

function setLastUsedModel(modelName) {
    try {
        localStorage.setItem('lastUsedModel', modelName);
    } catch (e) {
        console.warn('Failed to save last used model to localStorage');
    }
}

// Available models list (based on actual assets directory)
const availableModels = ['kanade', 'kanade_2', 'kuromi', 'miku_2', 'saki_child'];

// Random model selection for waifu switch button
function switchToRandomModel() {
    // Filter out current model from available options
    const otherModels = availableModels.filter(model => model !== currentModel);
    
    if (otherModels.length === 0) {
        console.warn('No other models available to switch to');
        return;
    }
    
    // Select random model
    const randomIndex = Math.floor(Math.random() * otherModels.length);
    const randomModel = otherModels[randomIndex];
    
    console.log(`🔄 Switching from ${currentModel} to ${randomModel}`);
    
    // Load the random model
    loadModel(randomModel);
}

// Auto-load last used model or default on page load
window.addEventListener('DOMContentLoaded', () => {
    // Initialize DOM references first
    initDOMReferences();
    
    initCanvas();
    
    // Setup mouse tracking for Live2D model
    setupMouseTracking();
    
    // Setup waifu tool event handlers
    setupWaifuToolHandlers();
    
    // Setup chat functionality event listeners
    if (sendButton && userInput) {
        sendButton.addEventListener('click', sendMessage);
        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                updateLastInteractionTime();
                sendMessage();
            }
        });
    } else {
        console.warn('⚠️ Chat elements not found during initialization');
    }
    
    // Try to load last used model or fallback to default
    const lastUsedModel = getLastUsedModel();
    const defaultModel = 'kanade';
    const modelToLoad = lastUsedModel || defaultModel;
    
    console.log(`📱 Loading model: ${modelToLoad} ${lastUsedModel ? '(last used)' : '(default)'}`);
    
    // Always update debug/status UI after model load attempt
    loadModel(modelToLoad);
    setTimeout(() => {
        if (typeof updateModelInfo === 'function') updateModelInfo();
        if (typeof updateDatabaseInfo === 'function') updateDatabaseInfo();
        if (typeof updateDebugUIPanel === 'function') updateDebugUIPanel();
        // Show Load Default Model button if no model loaded
        const loadBtn = document.getElementById('debug-load-default-model');
        if (loadBtn) {
            if (!currentModel || !window.live2dv4 || !window.live2dv4._model) {
                loadBtn.style.display = 'inline-block';
            } else {
                loadBtn.style.display = 'none';
            }
        }
    }, 2500);
});

// Setup mouse tracking for Live2D model
function setupMouseTracking() {
    if (!window.live2dv4 || !currentModel) {
        console.log('⚠️ Cannot setup mouse tracking: Live2D not ready');
        return;
    }
    
    const canvas = document.getElementById('live2d4');
    if (!canvas) {
        console.log('⚠️ Cannot setup mouse tracking: Canvas not found');
        return;
    }
    
    console.log('🖱️ Setting up mouse tracking for canvas');
    
    // Remove any existing listeners to avoid duplicates
    canvas.removeEventListener('click', handleCanvasClick);
    canvas.removeEventListener('mousemove', handleMouseMove);
    canvas.removeEventListener('mouseleave', handleMouseLeave);
    
    // Add mouse event handlers
    canvas.addEventListener('click', handleCanvasClick);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseleave', handleMouseLeave);
    
    console.log('🖱️ Mouse tracking enabled with head-centered tracking');
    
    // Start the idle motion system
    startIdleMotionSystem();
}

// Handle mouse movement for Live2D tracking (centered on head)
function handleMouseMove(e) {
    if (!window.live2dv4 || !currentModel) return;
    
    const canvas = e.target;
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // === PATCH: Use true canvas center for head tracking and allow per-model tuning ===
    const modelOffsets = {
        // Example: 'kanade': { x: 0, y: 0, xScale: 1, yScale: 1 },
    };
    const offset = modelOffsets[currentModel] || { x: 0, y: 0, xScale: 1, yScale: 1 };
    const headCenterX = rect.width / 2 + offset.x;
    const headCenterY = rect.height * 0.25 + offset.y;
    
    // Calculate offset from head center using canvas coordinates
    let offsetX = (mouseX - headCenterX) / (rect.width * 0.3); // Tracking sensitivity
    let offsetY = (mouseY - headCenterY) / (rect.height * 0.2); // Smaller vertical range
    
    // Apply per-model scaling if set
    offsetX *= offset.xScale || 1;
    offsetY *= offset.yScale || 1;
    
    // Clamp to reasonable range (no negative sign)
    const normalizedX = Math.max(-1, Math.min(1, offsetX));
    const normalizedY = Math.max(-1, Math.min(1, offsetY));
    
    // Debug logging (enable to see coordinates)
    console.log(`🖱️ Mouse: (${mouseX.toFixed(0)}, ${mouseY.toFixed(0)}), Head: (${headCenterX.toFixed(0)}, ${headCenterY.toFixed(0)}), Normalized: (${normalizedX.toFixed(2)}, ${normalizedY.toFixed(2)})`);
    
    // Apply mouse tracking to Live2D model
    try {
        if (window.live2dv4.setMousePosition) {
            window.live2dv4.setMousePosition(normalizedX, normalizedY);
        } else if (window.live2dv4._view && window.live2dv4._view.onTouchesMoved) {
            window.live2dv4._view.onTouchesMoved([{x: normalizedX, y: normalizedY}]);
        } else if (window.live2dv4.onMouseMove) {
            window.live2dv4.onMouseMove(normalizedX, normalizedY);
        }
    } catch (error) {
        console.error('Mouse tracking error:', error);
    }
}

// Handle mouse leaving canvas
function handleMouseLeave(e) {
    if (!window.live2dv4 || !currentModel) return;
    
    // Reset to neutral position when mouse leaves
    try {
        if (window.live2dv4.setMousePosition) {
            window.live2dv4.setMousePosition(0, 0);
        } else if (window.live2dv4._view && window.live2dv4._view.onTouchesMoved) {
            window.live2dv4._view.onTouchesMoved([{x: 0, y: 0}]);
        } else if (window.live2dv4.onMouseMove) {
            window.live2dv4.onMouseMove(0, 0);
        }
    } catch (error) {
        // Silently handle errors
    }
}

// Handle canvas clicks to trigger motions
function handleCanvasClick(e) {
    if (!window.live2dv4 || !currentModel) return;
    
    updateLastInteractionTime();
    
    const canvas = e.target;
    const rect = canvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;
    
    // Normalize click position
    const normalizedX = clickX / rect.width;
    const normalizedY = clickY / rect.height;
    
    console.log(`🖱️ Canvas clicked at (${clickX.toFixed(1)}, ${clickY.toFixed(1)})`);
    
    // Trigger different motions based on click location
    if (normalizedY < 0.3) {
        // Head area - trigger head/face related motions
        triggerHeadAreaMotion();
    } else if (normalizedY > 0.7) {
        // Lower body area - trigger body motions
        triggerBodyAreaMotion();
    } else {
        // Middle area - trigger general motions
        triggerRandomMotion();
    }
    
    // Show feedback message
    showWaifuMessage('Thanks for the interaction! ✨', 1500);
}

function triggerHeadAreaMotion() {
    const availableMotions = getAvailableMotions();
    
    // Filter for head-type motions
    const headMotions = availableMotions.filter(motion => 
        motion.type === 'head' || 
        motion.group.toLowerCase().includes('head') ||
        motion.group.toLowerCase().includes('nod') ||
        motion.group.toLowerCase().includes('tilt') ||
        motion.group.toLowerCase().includes('think')
    );
    
    // If no head motions found, use general motions
    const motions = headMotions.length > 0 ? headMotions : availableMotions.slice(0, 5);
    const motion = motions[Math.floor(Math.random() * motions.length)];
    
    try {
        console.log(`🎭 Triggering head motion: ${motion.group}[${motion.index}] (type: ${motion.type || 'unknown'})`);
        
        if (window.live2dv4.startMotion) {
            const result = window.live2dv4.startMotion(motion.group, motion.index);
            console.log(`🎭 Head motion result:`, result);
        } else if (window.live2dv4._model && window.live2dv4._model.startMotion) {
            const result = window.live2dv4._model.startMotion(motion.group, motion.index, 2);
            console.log(`🎭 Head motion (_model) result:`, result);
        }
    } catch (error) {
        console.warn('Failed to trigger head motion:', error);
    }
}

function triggerBodyAreaMotion() {
    const availableMotions = getAvailableMotions();
    
    // Filter for body-type motions
    const bodyMotions = availableMotions.filter(motion => 
        motion.type === 'body' || 
        motion.group.toLowerCase().includes('body') ||
        motion.group.toLowerCase().includes('pose') ||
        motion.group.toLowerCase().includes('arm') ||
        motion.group.toLowerCase().includes('hand') ||
        motion.group.toLowerCase().includes('wave')
    );
    
    // If no body motions found, use general motions
    const motions = bodyMotions.length > 0 ? bodyMotions : availableMotions.slice(0, 5);
    const motion = motions[Math.floor(Math.random() * motions.length)];
    
    try {
        console.log(`🎭 Triggering body motion: ${motion.group}[${motion.index}] (type: ${motion.type || 'unknown'})`);
        
        if (window.live2dv4.startMotion) {
            const result = window.live2dv4.startMotion(motion.group, motion.index);
            console.log(`🎭 Body motion result:`, result);
        } else if (window.live2dv4._model && window.live2dv4._model.startMotion) {
            const result = window.live2dv4._model.startMotion(motion.group, motion.index, 2);
            console.log(`🎭 Body motion (_model) result:`, result);
        }
    } catch (error) {
        console.warn('Failed to trigger body motion:', error);
    }
}

// Mouse tracking functions removed

function initCanvas() {
    const canvasContainer = document.querySelector('.canvas-container');
    if (!canvasContainer) {
        console.warn('No .canvas-container found for canvas sizing');
        return;
    }
    // Use fixed container dimensions instead of viewport-based sizing
    const containerHeight = 800; // Fixed height to match CSS
    const aspect = 7/6;
    const containerWidth = Math.round(containerHeight * aspect);
    
    canvasContainer.style.width = containerWidth + 'px';
    canvasContainer.style.height = containerHeight + 'px';
    
    const canvas2D = document.getElementById('live2d2');
    const canvas4D = document.getElementById('live2d4');
    // Set canvas size to match container
    canvas2D.width = containerWidth;
    canvas2D.height = containerHeight;
    canvas4D.width = containerWidth;
    canvas4D.height = containerHeight;
    canvas2D.style.width = '100%';
    canvas2D.style.height = '100%';
    canvas4D.style.width = '100%';
    canvas4D.style.height = '100%';
    // Removed all attempts to scale/zoom model here
}

function clearModel() {
    // Stop idle motion system
    stopIdleMotionSystem();
    
    const canvas2D = document.getElementById('live2d2');
    const canvas4D = document.getElementById('live2d4');
    canvas2D.getContext('2d').clearRect(0, 0, canvas2D.width, canvas2D.height);
    canvas4D.getContext('2d').clearRect(0, 0, canvas4D.width, canvas4D.height);
    // Only hide both canvases when explicitly clearing
    canvas2D.style.display = 'none';
    canvas4D.style.display = 'none';
    currentModel = null;
    modelInfo.textContent = 'No model loaded';
    statusText.textContent = 'Model cleared';
    statusIndicator.className = 'status-indicator info';
}

function handleEmotionalResponse(personalityState, animationTriggers) {
    if (!window.live2dv4 || !currentModel) {
        console.log('⚠️ No Live2D model loaded for emotion animation');
        debugLog('⚠️ No Live2D model for emotion animation', 'warn');
        return;
    }
    
    const { primary_emotion, intensity, emotion_tags } = animationTriggers;
    const { bonding_level, emotional_state, energy_level } = personalityState;
    
    debugLog(`🎭 Emotion: ${primary_emotion} (${(intensity * 100).toFixed(0)}%)`);
    debugLog(`💝 Bonding: ${bonding_level.toFixed(2)}, Energy: ${energy_level.toFixed(2)}`);
    
    // Map emotions to Live2D animations
    const emotionAnimationMap = {
        // High-energy positive emotions
        'excited': { expression: 'happy', motion: 'wave', intensity: 1.0 },
        'ecstatic': { expression: 'happy', motion: 'wave', intensity: 1.0 },
        'thrilled': { expression: 'happy', motion: 'wave', intensity: 1.0 },
        
        // Moderate positive emotions
        'happy': { expression: 'happy', motion: 'idle', intensity: 0.8 },
        'joyful': { expression: 'happy', motion: 'idle', intensity: 0.9 },
        'cheerful': { expression: 'happy', motion: 'idle', intensity: 0.7 },
        
        // Surprise/wonder emotions
        'surprised': { expression: 'surprised', motion: 'tap_head', intensity: 0.9 },
        'amazed': { expression: 'surprised', motion: 'tap_head', intensity: 0.8 },
        'curious': { expression: 'neutral', motion: 'idle', intensity: 0.4 },
        
        // Empathetic/caring emotions
        'empathetic': { expression: 'sad', motion: 'idle', intensity: 0.6 },
        'supportive': { expression: 'neutral', motion: 'idle', intensity: 0.5 },
        'caring': { expression: 'neutral', motion: 'idle', intensity: 0.5 },
        
        // Sad/melancholy emotions
        'sad': { expression: 'sad', motion: 'idle', intensity: 0.4 },
        'disappointed': { expression: 'sad', motion: 'idle', intensity: 0.5 },
        
        // Default/neutral
        'neutral': { expression: 'neutral', motion: 'idle', intensity: 0.3 },
        'thinking': { expression: 'neutral', motion: 'idle', intensity: 0.3 }
    };
    
    // Get animation config for primary emotion
    const animConfig = emotionAnimationMap[primary_emotion] || emotionAnimationMap['neutral'];
    
    // Adjust intensity based on bonding level and energy
    const finalIntensity = Math.min(
        intensity * (bonding_level / 10.0 + 0.3) * energy_level,
        1.0
    );
    
    // Apply the animation
    triggerEmotionAnimation(animConfig, finalIntensity, emotion_tags);
    
    // Log the animation trigger
    console.log(`🎭 Triggering ${primary_emotion} animation:`, {
        expression: animConfig.expression,
        motion: animConfig.motion,
        intensity: finalIntensity.toFixed(2),
        bondLevel: bonding_level,
        energyLevel: energy_level
    });
    
    // Log to debug UI
    debugLog(`🎭 Animation: ${animConfig.motion || 'default'} for ${primary_emotion}`);
    debugLog(`📊 Intensity: ${(finalIntensity * 100).toFixed(0)}%, Bond: ${bonding_level.toFixed(1)}`);
}

function triggerEmotionAnimation(animConfig, intensity, emotionTags) {
    if (!window.live2dv4 || !currentModel) return;
    
    debugLog(`🎭 Triggering emotion animation: ${animConfig.motion || 'none'}`);
    
    try {
        // Set facial expression
        if (animConfig.expression && animConfig.expression !== 'neutral') {
            triggerExpressionByName(animConfig.expression);
            debugLog(`😊 Expression: ${animConfig.expression}`);
        }
        
        // Trigger motion if specified
        if (animConfig.motion && animConfig.motion !== 'idle') {
            triggerMotionByName(animConfig.motion);
            debugLog(`🎬 Motion: ${animConfig.motion}`);
            
            // Update last motion in debug UI
            if (debugLastMotionName) {
                debugLastMotionName.textContent = `${animConfig.motion} (emotion)`;
            }
        } else if (intensity > 0.6) {
            // High intensity emotions trigger random motion
            debugLog(`⚡ High intensity (${(intensity * 100).toFixed(0)}%) - triggering random motion`);
            triggerRandomMotion();
        }
        
        // Handle special emotion combinations
        if (emotionTags.includes('excited') && emotionTags.includes('happy')) {
            // Double positive emotions = extra animation
            setTimeout(() => {
                if (window.live2dv4 && currentModel) {
                    triggerRandomMotion();
                }
            }, 1500);
        }
        
        // Automatic return to neutral after animation
        setTimeout(() => {
            if (window.live2dv4 && currentModel) {
                resetToNeutralExpression();
            }
        }, 3000 + (intensity * 2000)); // Longer display for higher intensity
        
    } catch (error) {
        console.error('Error triggering emotion animation:', error);
    }
}

// Animation trigger functions for Live2D expressions and motions
function triggerExpressionByName(expressionName) {
    if (!window.live2dv4 || !currentModel) return;
    
    try {
        // Map expression names to Live2D expression indices or IDs
        const expressionMap = {
            'happy': 0,
            'surprised': 1, 
            'sad': 2,
            'angry': 3,
            'neutral': -1  // Default expression
        };
        
        const expressionId = expressionMap[expressionName];
        if (expressionId !== undefined && expressionId >= 0) {
            window.live2dv4.setExpression(expressionId);
            console.log(`🎭 Set expression: ${expressionName} (ID: ${expressionId})`);
        }
    } catch (error) {
        console.warn('Failed to set expression:', error);
    }
}

function triggerMotionByName(motionName) {
    if (!window.live2dv4 || !currentModel) return;
    
    try {
        // Map motion names to Live2D motion groups or specific motions
        const motionMap = {
            'wave': 'greeting',
            'nod': 'affirmation',
            'shake': 'negation',
            'bow': 'greeting',
            'dance': 'happy',
            'idle': 'idle'
        };
        
        const motionGroup = motionMap[motionName] || 'idle';
        window.live2dv4.startMotion(motionGroup, 0); // Start first motion in group
        console.log(`🎭 Triggered motion: ${motionName} (group: ${motionGroup})`);
    } catch (error) {
        console.warn('Failed to trigger motion:', error);
    }
}

// Random motion triggering system - Enhanced with multiple API approaches
function triggerRandomMotion() {
    if (!window.live2dv4 || !currentModel) return;
    
    try {
        console.log('🎭 === ATTEMPTING TO TRIGGER RANDOM MOTION ===');
        debugLog('🎭 Triggering random motion...');
        
        // Get available motions with enhanced detection
        const availableMotions = getAvailableMotions();
        const randomMotion = availableMotions[Math.floor(Math.random() * availableMotions.length)];
        
        console.log(`🎭 Selected motion: ${randomMotion.group}[${randomMotion.index}]`);
        debugLog(`🎲 Selected: ${randomMotion.group}[${randomMotion.index}]`);
        
        // Update last motion in debug UI
        if (debugLastMotionName) {
            debugLastMotionName.textContent = `${randomMotion.group}[${randomMotion.index}]`;
        }
        
        // Method 1: Try direct startMotion
        if (window.live2dv4.startMotion && typeof window.live2dv4.startMotion === 'function') {
            console.log('🎭 Trying startMotion...');
            const result = window.live2dv4.startMotion(randomMotion.group, randomMotion.index);
            console.log('🎭 startMotion result:', result);
            if (result !== false) {
                debugLog(`✅ Motion triggered: ${randomMotion.group}[${randomMotion.index}]`);
                return true;
            }
        }
        
        // Method 2: Try with priority parameter
        if (window.live2dv4.startMotion && typeof window.live2dv4.startMotion === 'function') {
            console.log('🎭 Trying startMotion with priority...');
            const result = window.live2dv4.startMotion(randomMotion.group, randomMotion.index, 2);
            console.log('🎭 startMotion with priority result:', result);
            if (result !== false) return true;
        }
        
        // Method 3: Try _model.startMotion
        if (window.live2dv4._model && window.live2dv4._model.startMotion) {
            console.log('🎭 Trying _model.startMotion...');
            const result = window.live2dv4._model.startMotion(randomMotion.group, randomMotion.index, 2);
            console.log('🎭 _model.startMotion result:', result);
            if (result !== false) return true;
        }
        
        // Method 4: Try startRandomMotion
        if (window.live2dv4.startRandomMotion && typeof window.live2dv4.startRandomMotion === 'function') {
            console.log('🎭 Trying startRandomMotion...');
            const result = window.live2dv4.startRandomMotion(randomMotion.group, 2);
            console.log('🎭 startRandomMotion result:', result);
            if (result !== false) return true;
        }
        
        // Method 5: Try motion manager directly
        if (window.live2dv4._model && window.live2dv4._model._motionManager) {
            const motionMgr = window.live2dv4._model._motionManager;
            console.log('🎭 Trying motion manager methods...');
            
            if (motionMgr.startMotionPriority && typeof motionMgr.startMotionPriority === 'function') {
                console.log('🎭 Trying motionManager.startMotionPriority...');
                const result = motionMgr.startMotionPriority(randomMotion.group, randomMotion.index, 2);
                console.log('🎭 startMotionPriority result:', result);
                if (result !== false) return true;
            }
            
            if (motionMgr.startMotion && typeof motionMgr.startMotion === 'function') {
                console.log('🎭 Trying motionManager.startMotion...');
                const result = motionMgr.startMotion(randomMotion.group, randomMotion.index);
                console.log('🎭 motionManager.startMotion result:', result);
                if (result !== false) return true;
            }
        }
        
        // Method 6: Force trigger with available API methods
        console.log('🎭 Trying force trigger...');
        return forceMotionTrigger(randomMotion);
        
    } catch (error) {
        console.error('🎭 Failed to trigger random motion:', error);
        return false;
    }
}

// Force motion trigger using any available method
function forceMotionTrigger(motion) {
    try {
        // Try all possible API calls
        const apiCalls = [
            () => window.live2dv4?.startMotion?.(motion.group, motion.index),
            () => window.live2dv4?.startMotion?.(motion.group, motion.index, 2),
            () => window.live2dv4?._model?.startMotion?.(motion.group, motion.index, 2),
            () => window.live2dv4?.startRandomMotion?.(motion.group, 2),
            () => window.live2dv4?._model?._motionManager?.startMotionPriority?.(motion.group, motion.index, 2),
            () => window.live2dv4?._model?._motionManager?.startMotion?.(motion.group, motion.index),
            // Try common motion names as fallback
            () => window.live2dv4?.startMotion?.('Idle', 0),
            () => window.live2dv4?.startMotion?.('idle', 0),
            () => window.live2dv4?.startMotion?.('TapBody', 0),
            () => window.live2dv4?.startMotion?.('tap_body', 0)
        ];
        
        for (let i = 0; i < apiCalls.length; i++) {
            try {
                const result = apiCalls[i]();
                if (result !== false && result !== undefined) {
                    console.log(`🎭 Force trigger succeeded with method ${i + 1}:`, result);
                    return true;
                }
            } catch (e) {
                // Continue to next method
            }
        }
        
        console.warn('🎭 All force trigger methods failed');
        return false;
    } catch (error) {
        console.error('🎭 Force motion trigger error:', error);
        return false;
    }
}

function tryDirectModelMotionTrigger() {
    try {
        if (window.live2dv4._model) {
            const model = window.live2dv4._model;
            console.log('🎭 Available model methods:', Object.keys(model));
            
            // Try different motion triggering approaches
            const motionMethods = [
                'startMotion',
                'startRandomMotion', 
                'setRandomExpression',
                'startMotionByGroup',
                'playMotion'
            ];
            
            for (const method of motionMethods) {
                if (typeof model[method] === 'function') {
                    console.log(`🎭 Found method: ${method}`);
                    try {
                        if (method === 'startRandomMotion') {
                            model[method]('Idle', 2);
                        } else if (method === 'startMotion') {
                            model[method]('Idle', 0, 2);
                        } else {
                            model[method]();
                        }
                        console.log(`🎭 Successfully called ${method}`);
                        break;
                    } catch (e) {
                        console.log(`🎭 ${method} failed:`, e.message);
                    }
                }
            }
        }
    } catch (error) {
        console.warn('🎭 Direct model motion trigger failed:', error);
    }
}

function getAvailableMotions() {
    console.log('🔍 === getAvailableMotions() called ===');
    console.log('🔍 window.live2dv4 exists:', !!window.live2dv4);
    console.log('🔍 window.live2dv4._model exists:', !!(window.live2dv4 && window.live2dv4._model));
    console.log('🔍 currentModel:', currentModel);
    
    // First, try to dynamically detect motions from the loaded model
    if (window.live2dv4 && window.live2dv4._model) {
        try {
            console.log('🔍 Dynamically detecting motions from loaded model...');
            
            const model = window.live2dv4._model;
            const motions = [];
            
            console.log('🔍 Model object:', model);
            console.log('🔍 Model keys:', Object.keys(model));
            
            // Check if model has settings with motion groups
            if (model._modelSetting || model.modelSetting) {
                const settings = model._modelSetting || model.modelSetting;
                console.log('🎭 Found model settings:', settings);
                console.log('🎭 Settings keys:', Object.keys(settings));
                
                // Try to get motion group names
                if (settings.getMotionGroupCount && settings.getMotionGroupName && settings.getMotionCount) {
                    console.log('🎭 All required methods found on settings!');
                    const groupCount = settings.getMotionGroupCount();
                    console.log(`🎭 Found ${groupCount} motion groups`);
                    
                    for (let i = 0; i < groupCount; i++) {
                        const groupName = settings.getMotionGroupName(i);
                        const motionCount = settings.getMotionCount(groupName);
                        console.log(`🎭 Group "${groupName}" has ${motionCount} motions`);
                        
                        for (let j = 0; j < motionCount; j++) {
                            motions.push({ 
                                group: groupName, 
                                index: j,
                                type: classifyMotionType(groupName) 
                            });
                        }
                    }
                    
                    if (motions.length > 0) {
                        console.log('🎭 Using dynamically detected motions:', motions);
                        console.log('🎭 About to register with backend, currentModel:', currentModel);
                        
                        // Register these motions with the backend
                        registerMotionsWithBackend(currentModel, motions);
                        
                        return motions;
                    } else {
                        console.warn('🎭 No motions were collected despite having groups');
                    }
                } else {
                    console.warn('🎭 Required methods missing on settings:');
                    console.warn('   getMotionGroupCount:', !!settings.getMotionGroupCount);
                    console.warn('   getMotionGroupName:', !!settings.getMotionGroupName);
                    console.warn('   getMotionCount:', !!settings.getMotionCount);
                }
            }
        } catch (error) {
            console.warn('🎭 Error detecting model motions dynamically:', error);
        }
    }
    
    // Fallback: try to get motions from backend
    if (currentModel) {
        try {
            // Make synchronous request to get cached motions
            const xhr = new XMLHttpRequest();
            xhr.open('GET', `/api/live2d/model/${currentModel}/motions`, false);
            xhr.send();
            
            if (xhr.status === 200) {
                const backendMotions = JSON.parse(xhr.responseText);
                if (backendMotions.length > 0) {
                    console.log('🎭 Using cached motions from backend:', backendMotions);
                    return backendMotions.map(m => ({
                        group: m.motion_group,
                        index: m.motion_index,
                        type: m.motion_type || 'body'
                    }));
                }
            }
        } catch (error) {
            console.warn('🎭 Error fetching motions from backend:', error);
        }
    }
    
    // Last resort: return minimal safe fallback
    console.log('🎭 Using minimal safe fallback motions');
    return [
        { group: 'Idle', index: 0, type: 'body' },
        { group: 'Idle', index: 1, type: 'body' },
        { group: 'TapBody', index: 0, type: 'body' }
    ];
}

// Helper function to classify motion types based on group names
function classifyMotionType(groupName) {
    const name = groupName.toLowerCase();
    
    if (name.includes('head') || name.includes('nod') || name.includes('tilt') || name.includes('think')) {
        return 'head';
    } else if (name.includes('body') || name.includes('pose') || name.includes('arm') || name.includes('hand')) {
        return 'body';
    } else if (name.includes('expression') || name.includes('blink') || name.includes('emotion')) {
        return 'expression';
    } else if (name.includes('special') || name.includes('dance') || name.includes('wave')) {
        return 'special';
    } else {
        return 'body'; // Default to body
    }
}

// Register detected motions with the backend for caching
async function registerMotionsWithBackend(modelName, motions) {
    console.log('🔄 === registerMotionsWithBackend() called ===');
    console.log('🔄 modelName:', modelName);
    console.log('🔄 motions count:', motions ? motions.length : 'null/undefined');
    console.log('🔄 motions:', motions);
    
    if (!modelName || !motions || motions.length === 0) {
        console.warn('🔄 Early return: missing modelName or motions');
        return;
    }
    
    try {
        const motionsData = motions.map(m => ({
            group: m.group,
            index: m.index,
            name: `${m.group}_${m.index}`,
            type: m.type
        }));
        
        console.log('🔄 Prepared motions data:', motionsData);
        console.log('🔄 Making POST request to:', `/api/live2d/model/${modelName}/register_motions`);
        
        const response = await fetch(`/api/live2d/model/${modelName}/register_motions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ motions: motionsData })
        });
        
        console.log('🔄 Response status:', response.status);
        
        if (response.ok) {
            const result = await response.json();
            console.log(`✅ Registered ${motions.length} motions for ${modelName} with backend`);
            console.log('✅ Server response:', result);
        } else {
            const errorText = await response.text();
            console.warn('⚠️ Failed to register motions with backend. Status:', response.status);
            console.warn('⚠️ Error text:', errorText);
        }
    } catch (error) {
        console.error('⚠️ Error registering motions with backend:', error);
    }
}

// Automatic idle motion system
let idleMotionInterval = null;
let blinkInterval = null;

function startIdleMotionSystem() {
    // Clear existing intervals
    if (idleMotionInterval) {
        clearInterval(idleMotionInterval);
    }
    if (blinkInterval) {
        clearInterval(blinkInterval);
    }
    
    console.log('🎭 Starting aggressive idle motion system...');
    
    // Start eye blinking system
    startBlinkingSystem();
    
    // Immediately trigger a body/idle motion after model load (multiple attempts)
    setTimeout(() => {
        console.log('🎭 First body motion attempt...');
        triggerBodyIdleMotion();
    }, 500);
    
    setTimeout(() => {
        console.log('🎭 Second body motion attempt...');
        triggerBodyIdleMotion();
    }, 1500);
    
    setTimeout(() => {
        console.log('🎭 Third body motion attempt...');
        triggerBodyIdleMotion();
    }, 3000);
    
    // Start new interval - check every 2 seconds for idle motion
    idleMotionInterval = setInterval(() => {
        const timeSinceLastInteraction = Date.now() - lastInteractionTime;
        
        // If no interaction for 3+ seconds, trigger body/arm motion
        if (timeSinceLastInteraction > 3000 && currentModel) {
            console.log('🎭 Interval body motion trigger...');
            triggerBodyIdleMotion();
        }
    }, 2000); // Fixed 2-second intervals
    
    console.log('🎭 Aggressive idle motion system started with body/arm motions');
}

// Eye blinking system for more lifelike animation
function startBlinkingSystem() {
    console.log('👁️ Starting eye blinking system...');
    
    // Schedule random blinks every 2-4 seconds
    function scheduleNextBlink() {
        const delay = 2000 + Math.random() * 2000; // 2-4 seconds
        blinkInterval = setTimeout(() => {
            triggerBlink();
            scheduleNextBlink();
        }, delay);
    }
    
    scheduleNextBlink();
}

function triggerBlink() {
    if (!window.live2dv4 || !currentModel) return;
    
    try {
        // Try different blinking methods
        if (window.live2dv4.setExpression) {
            // Quick blink by setting expression
            window.live2dv4.setExpression('blink');
            setTimeout(() => {
                window.live2dv4.setExpression('normal');
            }, 150);
        } else if (window.live2dv4._model && window.live2dv4._model.setExpression) {
            window.live2dv4._model.setExpression('blink');
            setTimeout(() => {
                window.live2dv4._model.setExpression('normal');
            }, 150);
        } else if (window.live2dv4.startMotion) {
            // Try blink motion - many models have this
            window.live2dv4.startMotion('Blink', 0);
        }
    } catch (error) {
        // Silently handle blink errors
    }
}

function stopIdleMotionSystem() {
    if (idleMotionInterval) {
        clearInterval(idleMotionInterval);
        idleMotionInterval = null;
        console.log('🎭 Idle motion system stopped');
    }
    if (blinkInterval) {
        clearInterval(blinkInterval);
        blinkInterval = null;
        console.log('👁️ Eye blinking system stopped');
    }
}

function triggerBodyIdleMotion() {
    if (!window.live2dv4 || !currentModel) return;
    
    console.log('🎭 === FORCING BODY IDLE MOTION ===');
    
    try {
        // Get available motions dynamically
        const availableMotions = getAvailableMotions();
        
        // Filter for body and idle type motions
        const bodyMotions = availableMotions.filter(motion => 
            motion.type === 'body' || 
            motion.group.toLowerCase().includes('idle') ||
            motion.group.toLowerCase().includes('pose') ||
            motion.group.toLowerCase().includes('body') ||
            motion.group.toLowerCase().includes('nod') ||
            motion.group.toLowerCase().includes('think') ||
            motion.group.toLowerCase().includes('shakehand') ||
            motion.group.toLowerCase().includes('tap')
        );
        
        // If we have specific body motions, use them, otherwise use any available motion
        const motionsToTry = bodyMotions.length > 0 ? bodyMotions : availableMotions;
        
        if (motionsToTry.length === 0) {
            console.warn('🎭 No motions available for body idle animation');
            return false;
        }
        
        const randomMotion = motionsToTry[Math.floor(Math.random() * motionsToTry.length)];
        
        console.log(`🎭 FORCE Triggering body motion: ${randomMotion.group}[${randomMotion.index}] (type: ${randomMotion.type || 'unknown'})`);
        
        // Try the most direct approaches first
        if (window.live2dv4.startMotion) {
            const result = window.live2dv4.startMotion(randomMotion.group, randomMotion.index);
            console.log(`🎭 Direct startMotion result:`, result);
            if (result !== false) return true;
        }
        
        if (window.live2dv4._model && window.live2dv4._model.startMotion) {
            const result = window.live2dv4._model.startMotion(randomMotion.group, randomMotion.index, 2);
            console.log(`🎭 _model.startMotion result:`, result);
            if (result !== false) return true;
        }
        
        // Force trigger any motion if body motions fail
        console.log('🎭 Body motions failed, trying any motion...');
        if (availableMotions.length > 0) {
            const fallbackMotion = availableMotions[0];
            if (window.live2dv4.startMotion) {
                window.live2dv4.startMotion(fallbackMotion.group, fallbackMotion.index);
            }
        }
        
        return true;
        
    } catch (error) {
        console.warn('Failed to trigger body idle motion:', error);
        return false;
    }
}

// Debug function to log available motions
function logAvailableMotions() {
    console.log('🔍 === COMPREHENSIVE MOTION DEBUG ===');
    
    if (!window.live2dv4) {
        console.log('❌ window.live2dv4 not available');
        return;
    }
    
    console.log('✅ window.live2dv4 available:', window.live2dv4);
    console.log('🔍 Live2D methods:', Object.keys(window.live2dv4));
    
    if (!window.live2dv4._model) {
        console.log('❌ window.live2dv4._model not available');
        return;
    }
    
    console.log('✅ window.live2dv4._model available:', window.live2dv4._model);
    console.log('🔍 Model methods:', Object.keys(window.live2dv4._model));
    
    const settings = window.live2dv4._model._modelSetting;
    if (settings && settings.getMotionGroupCount && settings.getMotionGroupName && settings.getMotionCount) {
        console.log('🎭 === AVAILABLE MOTION GROUPS ===');
        const groupCount = settings.getMotionGroupCount();
        console.log(`Total motion groups: ${groupCount}`);
        
        for (let i = 0; i < groupCount; i++) {
            const groupName = settings.getMotionGroupName(i);
            const motionCount = settings.getMotionCount(groupName);
            console.log(`📁 Group: "${groupName}" (${motionCount} motions)`);
            for (let j = 0; j < motionCount; j++) {
                console.log(`  ⚡ ${groupName}[${j}]`);
            }
        }
        console.log('🎭 === END MOTION GROUPS ===');
        
        // Test trigger first available motion
        if (groupCount > 0) {
            const firstGroup = settings.getMotionGroupName(0);
            console.log(`🧪 Testing first motion: ${firstGroup}[0]`);
            testSingleMotion(firstGroup, 0);
        }
    } else {
        console.warn('❌ Could not access model settings to log motions');
        console.log('🔍 Available on _model:', Object.keys(window.live2dv4._model));
        if (window.live2dv4._model._modelSetting) {
            console.log('🔍 Available on _modelSetting:', Object.keys(window.live2dv4._model._modelSetting));
        }
    }
}

// Test a single motion with all possible methods
function testSingleMotion(group, index) {
    console.log(`🧪 === TESTING MOTION ${group}[${index}] ===`);
    
    // Method 1: Direct startMotion
    try {
        if (window.live2dv4.startMotion) {
            console.log('🧪 Method 1: window.live2dv4.startMotion');
            const result1 = window.live2dv4.startMotion(group, index);
            console.log(`   Result:`, result1);
        }
    } catch (e) {
        console.log('   Failed:', e.message);
    }
    
    // Method 2: Model startMotion
    try {
        if (window.live2dv4._model && window.live2dv4._model.startMotion) {
            console.log('🧪 Method 2: window.live2dv4._model.startMotion');
            const result2 = window.live2dv4._model.startMotion(group, index, 2);
            console.log(`   Result:`, result2);
        }
    } catch (e) {
        console.log('   Failed:', e.message);
    }
    
    // Method 3: Motion manager
    try {
        if (window.live2dv4._model && window.live2dv4._model._motionManager) {
            console.log('🧪 Method 3: window.live2dv4._model._motionManager.startMotionPriority');
            const result3 = window.live2dv4._model._motionManager.startMotionPriority(group, index, 2);
            console.log(`   Result:`, result3);
        }
    } catch (e) {
        console.log('   Failed:', e.message);
    }
    
    console.log(`🧪 === END TEST ${group}[${index}] ===`);
}

// Test ALL available motions to see which ones actually work
window.testAllMotions = function() {
    if (!window.live2dv4 || !window.live2dv4._model) {
        console.log('❌ Live2D model not available');
        return;
    }
    
    const settings = window.live2dv4._model._modelSetting;
    if (!settings || !settings.getMotionGroupCount) {
        console.log('❌ Model settings not available');
        return;
    }
    
    console.log('🧪 === TESTING ALL MOTIONS ===');
    const groupCount = settings.getMotionGroupCount();
    
    let testIndex = 0;
    const allTests = [];
    
    // Collect all motions to test
    for (let i = 0; i < groupCount; i++) {
        const groupName = settings.getMotionGroupName(i);
        const motionCount = settings.getMotionCount(groupName);
        
        for (let j = 0; j < motionCount; j++) {
            allTests.push({ group: groupName, index: j });
        }
    }
    
    console.log(`Found ${allTests.length} total motions to test`);
    
    // Test each motion with a delay to see them clearly
    function testNext() {
        if (testIndex >= allTests.length) {
            console.log('🧪 === ALL MOTION TESTS COMPLETE ===');
            return;
        }
        
        const motion = allTests[testIndex];
        console.log(`🧪 Testing ${testIndex + 1}/${allTests.length}: ${motion.group}[${motion.index}]`);
        
        // Try to trigger the motion
        try {
            if (window.live2dv4.startMotion) {
                const result = window.live2dv4.startMotion(motion.group, motion.index);
                console.log(`✅ Motion ${motion.group}[${motion.index}] triggered:`, result);
            }
        } catch (e) {
            console.log(`❌ Motion ${motion.group}[${motion.index}] failed:`, e.message);
        }
        
        testIndex++;
        setTimeout(testNext, 2000); // Wait 2 seconds between tests
    }
    
    testNext();
};

function triggerSubtleIdleMotion() {
    // Simple fallback function if not defined elsewhere
    if (typeof triggerBodyIdleMotion === 'function') {
        return triggerBodyIdleMotion();
    } else {
        return triggerRandomMotion();
    }
}

// Update last interaction time on user activity
function updateLastInteractionTime() {
    lastInteractionTime = Date.now();
}

// Global debug function accessible from browser console
window.debugLive2D = function() {
    console.log('🔍 === MANUAL DEBUG TRIGGER ===');
    console.log('🔍 window.live2dv4 exists:', !!window.live2dv4);
    console.log('🔍 window.live2dv4:', window.live2dv4);
    console.log('🔍 currentModel:', currentModel);
    
    if (window.live2dv4) {
        console.log('🔍 live2dv4 methods:', Object.keys(window.live2dv4));
        console.log('🔍 live2dv4._model exists:', !!window.live2dv4._model);
        
        if (window.live2dv4._model) {
            console.log('🔍 _model:', window.live2dv4._model);
            console.log('🔍 _model methods:', Object.keys(window.live2dv4._model));
        }
        
        debugModelStructure();
        logAvailableMotions();
        console.log('🔍 Attempting to trigger test motion...');
        triggerRandomMotion();
        
        // Also show debug info in the debug panel
        const debugPanel = document.getElementById('debugPanel');
        if (debugPanel) {
            let debugInfo = '🔍 === LIVE2D DEBUG INFO ===\n';
            debugInfo += `Live2D SDK: ${window.live2dv4 ? 'Available' : 'Missing'}\n`;
            debugInfo += `Model loaded: ${currentModel || 'None'}\n`;
            debugInfo += `_model object: ${window.live2dv4?._model ? 'Available' : 'Missing'}\n`;
            
            if (window.live2dv4?._model?._modelSetting) {
                const settings = window.live2dv4._model._modelSetting;
                if (settings.getMotionGroupCount) {
                    const groupCount = settings.getMotionGroupCount();
                    debugInfo += `Motion Groups: ${groupCount}\n`;
                    
                    for (let i = 0; i < groupCount; i++) {
                        if (settings.getMotionGroupName) {
                            const groupName = settings.getMotionGroupName(i);
                            const motionCount = settings.getMotionCount ? settings.getMotionCount(groupName) : 'unknown';
                            debugInfo += `  ${i}: "${groupName}" (${motionCount} motions)\n`;
                        }
                    }
                } else {
                    debugInfo += 'Could not access motion groups\n';
                }
            } else {
                debugInfo += 'Model or settings not accessible\n';
            }
            
            debugInfo += '\nCheck browser console (F12) for detailed logs';
            debugPanel.textContent = debugInfo;
            debugPanel.classList.add('visible');
        }
    } else {
        console.log('❌ Live2D not loaded');
        const debugPanel = document.getElementById('debugPanel');
        if (debugPanel) {
            debugPanel.textContent = '❌ Live2D SDK not loaded!\nCheck if live2d_bundle.js is loading correctly.';
            debugPanel.classList.add('visible');
        }
    }
};

// Simple test function to check basic Live2D functionality
window.testBasicLive2D = function() {
    console.log('🧪 === BASIC LIVE2D TEST ===');
    console.log('🧪 Checking window.live2dv4:', window.live2dv4);
    
    if (!window.live2dv4) {
        console.log('❌ window.live2dv4 is not available');
        return false;
    }
    
    console.log('✅ window.live2dv4 is available');
    console.log('🧪 Available methods:', Object.keys(window.live2dv4));
    
    if (window.live2dv4.startMotion) {
        console.log('✅ startMotion method is available');
        console.log('🧪 Testing startMotion call...');
        try {
            const result = window.live2dv4.startMotion('test', 0);
            console.log('🧪 startMotion test result:', result);
        } catch (e) {
            console.log('❌ startMotion test failed:', e);
        }
    } else {
        console.log('❌ startMotion method is not available');
    }
    
    return true;
};

// Debug function to inspect model structure
function debugModelStructure() {
    if (!window.live2dv4 || !currentModel) {
        console.log('🔍 No model to debug');
        return;
    }
    
    console.log('🔍 === DEBUGGING LIVE2D MODEL STRUCTURE ===');
    console.log('🔍 window.live2dv4:', window.live2dv4);
    console.log('🔍 Available methods on live2dv4:', Object.keys(window.live2dv4));
    
    if (window.live2dv4._model) {
        console.log('🔍 _model found:', window.live2dv4._model);
        console.log('🔍 _model methods:', Object.keys(window.live2dv4._model));
        
        const model = window.live2dv4._model;
        
        // Check for motion manager
        if (model._motionManager) {
            console.log('🔍 _motionManager found:', model._motionManager);
            console.log('🔍 _motionManager methods:', Object.keys(model._motionManager));
        }
        
        // Check for model setting
        if (model._modelSetting) {
            console.log('🔍 _modelSetting found:', model._modelSetting);
            console.log('🔍 _modelSetting methods:', Object.keys(model._modelSetting));
            
            const settings = model._modelSetting;
            if (settings.getMotionGroupCount) {
                const groupCount = settings.getMotionGroupCount();
                console.log(`🔍 Motion groups count: ${groupCount}`);
                
                for (let i = 0; i < Math.min(groupCount, 3); i++) {
                    const groupName = settings.getMotionGroupName(i);
                    const motionCount = settings.getMotionCount ? settings.getMotionCount(groupName) : 'unknown';
                    console.log(`🔍 Group ${i}: "${groupName}" (${motionCount} motions)`);
                }
            }
        }
    }
    
    // Try to trigger a test motion
    console.log('🔍 Testing motion trigger...');
    try {
        if (window.live2dv4.startMotion) {
            const result = window.live2dv4.startMotion('Idle', 0);
            console.log('🔍 Test motion result:', result);
        }
    } catch (error) {
        console.log('🔍 Test motion failed:', error);
    }
    
    console.log('🔍 === END MODEL DEBUG ===');
}

// Test available motion methods and APIs
function testMotionMethods() {
    console.log('🧪 === TESTING MOTION METHODS ===');
    
    if (!window.live2dv4) {
        console.log('❌ window.live2dv4 not available');
        return;
    }
    
    console.log('✅ window.live2dv4 available:', window.live2dv4);
    console.log('🔍 Available methods:', Object.keys(window.live2dv4));
    
    // Test direct methods on live2dv4
    const methodsToTest = ['startMotion', 'startRandomMotion', 'setExpression', 'playMotion'];
    
    console.log('🔍 Testing direct methods on window.live2dv4:');
    methodsToTest.forEach(method => {
        if (typeof window.live2dv4[method] === 'function') {
            console.log(`✅ ${method}: function available`);
        } else {
            console.log(`❌ ${method}: not available`);
        }
    });
    
    // Test _model object
    if (window.live2dv4._model) {
        console.log('✅ _model available:', window.live2dv4._model);
        console.log('🔍 _model methods:', Object.keys(window.live2dv4._model));
    } else {
        console.log('❌ window.live2dv4._model not available');
    }
    
    console.log('🧪 === END MOTION METHODS TEST ===');
}

// Patch the Live2D motion API to make it compatible with our motion system
function patchMotionAPI() {
    console.log('🔧 === PATCHING MOTION API ===');
    
    try {
        // Try to find the actual Cubism model instance
        let cubismModel = null;
        
        // Method 1: Check global Cubism objects
        if (window.Live2DCubismFramework) {
            console.log('🔍 Found Live2DCubismFramework');
            // Try to find model through the framework
        }
        
        // Method 2: Check if live2dv4 has internal references
        if (window.live2dv4.app || window.live2dv4.model || window.live2dv4._app) {
            const app = window.live2dv4.app || window.live2dv4.model || window.live2dv4._app;
            console.log('🔍 Found app object:', app);
            if (app && app._model) {
                cubismModel = app._model;
                console.log('✅ Found Cubism model via app._model');
            }
        }
        
        // Method 3: Try to access the model through canvas or renderer
        const canvas = document.getElementById('live2d4');
        if (canvas && canvas._live2dModel) {
            cubismModel = canvas._live2dModel;
            console.log('✅ Found Cubism model via canvas._live2dModel');
        }
        
        // If we found a model, patch the API
        if (cubismModel) {
            console.log('🎯 Patching motion API with found model:', cubismModel);
            
            // Add startMotion method to live2dv4
            window.live2dv4.startMotion = function(group, index, priority = 2) {
                console.log(`🎭 Patched startMotion called: ${group}[${index}]`);
                try {
                    if (cubismModel.startMotion) {
                        return cubismModel.startMotion(group, index, priority);
                    } else if (cubismModel._motionManager && cubismModel._motionManager.startMotionPriority) {
                        return cubismModel._motionManager.startMotionPriority(group, index, priority);
                    } else {
                        console.log('❌ No motion method found on cubism model');
                        return false;
                    }
                } catch (error) {
                    console.error('❌ Patched startMotion error:', error);
                    return false;
                }
            };
            
            // Add model reference for direct access
            window.live2dv4._model = cubismModel;
            
            console.log('✅ Motion API patched successfully!');
            console.log('🔍 Updated live2dv4 methods:', Object.keys(window.live2dv4));
            
        } else {
            console.log('⚠️ Could not find Cubism model to patch API');
            
            // Add a dummy startMotion that tries various approaches
            window.live2dv4.startMotion = function(group, index, priority = 2) {
                console.log(`🎭 Dummy startMotion called: ${group}[${index}]`);
                console.log('🔍 Trying alternative motion trigger methods...');
                
                // Try any motion methods we can find
                const attempts = [
                    () => window.live2dv4.setPreLoadMotion && window.live2dv4.setPreLoadMotion(group, index),
                    () => window.live2dv4.change && window.live2dv4.change(group),
                    () => console.log('📝 Motion request logged (no actual implementation available)')
                ];
                
                for (let i = 0; i < attempts.length; i++) {
                    try {
                        const result = attempts[i]();
                        if (result !== false && result !== undefined) {
                            console.log(`✅ Motion triggered via method ${i + 1}`);
                            return true;
                        }
                    } catch (e) {
                        // Continue to next method
                    }
                }
                
                return false;
            };
        }
        
    } catch (error) {
        console.error('❌ Error patching motion API:', error);
    }
    
    console.log('🔧 === END MOTION API PATCH ===');
}

// === Chat Functions ===

// Global test function to manually trigger motion detection
window.testMotionDetection = function() {
    console.log('🧪 === MANUAL MOTION DETECTION TEST ===');
    
    // First check model state
    console.log('🔍 Checking model state...');
    console.log('   window.live2dv4 exists:', !!window.live2dv4);
    console.log('   window.live2dv4._model exists:', !!(window.live2dv4 && window.live2dv4._model));
    console.log('   currentModel:', currentModel);
    
    if (window.live2dv4 && window.live2dv4._model) {
        console.log('✅ Model is available, testing motion detection...');
        
        // Call getAvailableMotions() and see what happens
        const motions = getAvailableMotions();
        console.log('🎭 getAvailableMotions() returned:', motions);
        
        // Also directly test motion detection
        try {
            const model = window.live2dv4._model;
            console.log('🔍 Direct model inspection:');
            console.log('   model:', model);
            console.log('   model keys:', Object.keys(model));
            
            if (model._modelSetting) {
                const settings = model._modelSetting;
                console.log('   settings:', settings);
                console.log('   settings keys:', Object.keys(settings));
                
                if (settings.getMotionGroupCount) {
                    const groupCount = settings.getMotionGroupCount();
                    console.log('   motion groups:', groupCount);
                    
                    for (let i = 0; i < Math.min(groupCount, 3); i++) {
                        const groupName = settings.getMotionGroupName(i);
                        const motionCount = settings.getMotionCount(groupName);
                        console.log(`   group ${i}: "${groupName}" (${motionCount} motions)`);
                    }
                }
            }
        } catch (error) {
            console.error('❌ Error during direct inspection:', error);
        }
    } else {
        console.error('❌ Model not available for testing');
        console.log('🔍 Available on window:', Object.keys(window).filter(k => k.includes('live2d')));
    }
};

// === Chat Functions ===

function addMessage(sender, message, type = 'info') {
    if (!chatWindow) {
        console.warn('Chat window not found');
        return;
    }
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${sender} ${type}`.trim();
    const timestamp = new Date().toLocaleTimeString();
    
    messageDiv.innerHTML = `
        <div class="message-content">
            <div class="message-header">
                <strong>${sender === 'user' ? 'You' : 'AI Companion'}</strong>
                <span class="timestamp">${timestamp}</span>
            </div>
            <div class="message-text">${formatMessage(message)}</div>
        </div>
    `;
    chatWindow.appendChild(messageDiv);
    chatWindow.scrollTop = chatWindow.scrollHeight;
    setTimeout(() => { messageDiv.classList.add('visible'); }, 10);
}

function formatMessage(message) {
    return message
        .replace(/\n/g, '<br>')
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>');
}

async function sendMessage() {
    if (!userInput || !userInput.value) {
        console.warn('User input not available');
        return;
    }
    
    const message = userInput.value.trim();
    if (!message) return;
    
    addMessage('user', message);
    userInput.value = '';
    
    if (statusText) statusText.textContent = 'Thinking...';
    
    try {
        const response = await fetch('/api/v1/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message })
        });
        
        const data = await response.json();
        addMessage('ai', data.response);
        
        if (statusText) statusText.textContent = 'Ready';
        
    } catch (err) {
        addMessage('system', 'Error: ' + err.message, 'error');
        console.error('Chat error:', err);
    }
}

// --- Chat Backend Integration ---
function addMessage(sender, message, type = '') {
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${sender} ${type}`.trim();
    const timestamp = new Date().toLocaleTimeString();
    messageDiv.innerHTML = `
        <div class="message-content">
            <div class="message-header">
                <strong>${sender === 'user' ? 'You' : 'AI Companion'}</strong>
                <span class="timestamp">${timestamp}</span>
            </div>
            <div class="message-text">${formatMessage(message)}</div>
        </div>
    `;
    chatWindow.appendChild(messageDiv);
    chatWindow.scrollTop = chatWindow.scrollHeight;
}

function addSystemMessage(message, type = 'info') {
    const messageDiv = document.createElement('div');
    messageDiv.className = `message system ${type}`;
    messageDiv.innerHTML = `
        <div class="message-content">
            <div class="message-text">${message}</div>
        </div>
    `;
    chatWindow.appendChild(messageDiv);
    chatWindow.scrollTop = chatWindow.scrollHeight;
}

function formatMessage(message) {
    return message
        .replace(/\n/g, '<br>')
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>');
}

// Enhanced sendMessage function to handle personality data
async function sendMessage() {
    const message = userInput.value.trim();
    if (!message) return;
    
    // Update interaction time
    updateLastInteractionTime();
    
    addMessage('user', message);
    userInput.value = '';
    statusText.textContent = 'Thinking...';
    statusIndicator.className = 'status-indicator info';
    
    debugLog(`💬 User message: "${message.substring(0, 30)}${message.length > 30 ? '...' : ''}"`);
    
    // Trigger thinking gesture
    if (Math.random() < 0.4) { // 40% chance
        setTimeout(() => triggerSubtleIdleMotion(), 500);
    }
    
    try {
        const response = await fetch('/api/v1/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message })
        });
        
        const data = await response.json();
        
        // Add AI response to chat
        addMessage('ai', data.response);
        debugLog(`🤖 AI response received (${data.response.length} chars)`);
        
        // Handle emotional response and trigger animations
        if (data.personality_state && data.animation_triggers) {
            debugLog(`🧠 Personality data received`);
            handleEmotionalResponse(data.personality_state, data.animation_triggers);
        } else {
            // If no specific emotion data, trigger a random speaking motion
            debugLog(`🎭 No emotion data - triggering random motion`);
            setTimeout(() => triggerRandomMotion(), 300);
        }
        
        // Handle emotional TTS audio playback
        if (data.tts_audio && data.tts_audio.audio_data) {
            playEmotionalTTSAudio(data.tts_audio);
        }
        
        // Update status
        statusText.textContent = 'Ready';
        statusIndicator.className = 'status-indicator success';
        
        // Log personality data for debugging
        console.log('🧠 Personality State:', data.personality_state);
        console.log('🎭 Animation Triggers:', data.animation_triggers);
        if (data.tts_audio) {
            console.log('🔊 TTS Audio:', data.tts_audio.emotion, 'intensity:', data.tts_audio.intensity);
        }
        
    } catch (err) {
        addSystemMessage('Error contacting AI backend', 'error');
        statusText.textContent = 'Error';
        statusIndicator.className = 'status-indicator error';
        console.error('Chat error:', err);
    }
}

/**
 * Enhanced API Documentation:
 * POST /api/v1/chat
 *   Request: { message: string }
 *   Response: {
 *     response: string,
 *     personality_state: {
 *       bonding_level: number,
 *       relationship_stage: string,
 *       dominant_traits: [[string, number], ...],
 *       emotional_state: string,
 *       energy_level: number,
 *       mood_stability: number
 *     },
 *     animation_triggers: {
 *       primary_emotion: string,
 *       emotion_tags: string[],
 *       intensity: number
 *     },
 *     personality: object,
 *     timestamp: number
 *   }
 *
 * The backend now provides enhanced personality data for Live2D avatar animations
 * and emotional expression mapping.
 */

window.addEventListener('resize', initCanvas);

// Add keyboard shortcuts for debugging
window.addEventListener('keydown', (e) => {
    // Ctrl+D = debug
    if (e.ctrlKey && e.key === 'd') {
        e.preventDefault();
        console.log('🔍 Keyboard shortcut: Ctrl+D - Running debug...');
        if (window.debugLive2D) {
            window.debugLive2D();
        }
    }
    // Ctrl+T = test all motions
    if (e.ctrlKey && e.key === 't') {
        e.preventDefault();
        console.log('🧪 Keyboard shortcut: Ctrl+T - Testing all motions...');
        if (window.testAllMotions) {
            window.testAllMotions();
        }
    }
    // Ctrl+R = trigger random motion
    if (e.ctrlKey && e.key === 'r') {
        e.preventDefault();
        console.log('🎭 Keyboard shortcut: Ctrl+R - Random motion...');
        triggerRandomMotion();
    }
});

// Setup waifu tool button event handlers
function setupWaifuToolHandlers() {
    // Wait a bit for DOM to be ready
    setTimeout(() => {
        // Switch model button (icon-next) - random model selection
        const switchButton = document.querySelector('.waifu-tool .icon-next');
        if (switchButton) {
            // Remove any existing listeners
            switchButton.removeEventListener('click', handleSwitchModel);
            switchButton.addEventListener('click', handleSwitchModel);
            console.log('🔄 Waifu switch model button handler set up');
        } else {
            console.warn('🔄 Switch model button not found');
        }
        
        // Home button
        const homeButton = document.querySelector('.waifu-tool .icon-home');
        if (homeButton) {
            homeButton.addEventListener('click', (e) => {
                e.preventDefault();
                window.location.reload();
            });
        }
        
        // Message button
        const messageButton = document.querySelector('.waifu-tool .icon-message');
        if (messageButton) {
            messageButton.addEventListener('click', (e) => {
                e.preventDefault();
                showRandomWaifuMessage();
            });
        }
        
        // Camera/Screenshot button
        const cameraButton = document.querySelector('.waifu-tool .icon-camera');
        if (cameraButton) {
            cameraButton.addEventListener('click', (e) => {
                e.preventDefault();
                takeModelScreenshot();
            });
        }
        
        // Close button
        const closeButton = document.querySelector('.waifu-tool .icon-cross');
        if (closeButton) {
            closeButton.addEventListener('click', (e) => {
                e.preventDefault();
                hideWaifu();
            });
        }
        
        // Debug button (repurposed About button)
        const debugButton = document.querySelector('.waifu-tool .icon-about');
        if (debugButton) {
            debugButton.addEventListener('click', (e) => {
                e.preventDefault();
                console.log('🔍 Debug button clicked - Running motion debugging...');
                if (window.debugLive2D) {
                    window.debugLive2D();
                } else {
                    console.log('🔍 Running manual debugging...');
                    debugModelStructure();
                    logAvailableMotions();
                    triggerRandomMotion();
                }
                showWaifuMessage('Debug info logged to console! Check F12 → Console 🔍', 3000);
            });
        }
    }, 1000); // Wait 1 second for DOM to be ready
}

// Handler function for switch model button
function handleSwitchModel(e) {
    e.preventDefault();
    console.log('🔄 Switch model button clicked!');
    switchToRandomModel();
}

// Show random waifu message
function showRandomWaifuMessage() {
    const messages = [
        "Hello! I'm your Live2D companion! 👋",
        "Click on me to see my animations! ✨", 
        "I can express different emotions! 😊",
        "Try switching between different models! 🔄",
        "Debug mode shows detailed information! 🔍",
        `Currently loaded: ${currentModel || 'Unknown'} 🤖`,
        "Hope you're having a great day! 💕"
    ];
    
    const randomMessage = messages[Math.floor(Math.random() * messages.length)];
    showWaifuMessage(randomMessage, 3000);
}

// Show waifu message
function showWaifuMessage(text, duration = 3000) {
    const messageElement = document.getElementById('waifu-message');
    if (messageElement) {
        messageElement.textContent = text;
        messageElement.style.display = 'block';
        
        setTimeout(() => {
            messageElement.style.display = 'none';
        }, duration);
    }
}

// Take model screenshot
function takeModelScreenshot() {
    if (!currentModel) {
        showWaifuMessage('No model loaded for screenshot! 📷❌', 2000);
        return;
    }
    
    try {
        if (window.live2dv4 && typeof window.live2dv4.CaptureCanvas === 'function') {
            window.live2dv4.CaptureCanvas();
            showWaifuMessage(`Screenshot taken of ${currentModel}! 📷✨`, 2000);
        } else {
            showWaifuMessage('Screenshot feature not available! 📷❌', 2000);
        }
    } catch (error) {
        console.error('Screenshot error:', error);
        showWaifuMessage('Screenshot failed! 📷❌', 2000);
    }
}

// Hide waifu
function hideWaifu() {
    const waifuElement = document.getElementById('waifu');
    if (waifuElement) {
        try {
            sessionStorage.setItem('waifuHide', '1');
        } catch (e) {
            console.warn('Failed to save waifu hide state');
        }
        
        waifuElement.style.transition = 'opacity 0.5s ease';
        waifuElement.style.opacity = '0';
        
        setTimeout(() => {
            waifuElement.classList.add('hide');
            waifuElement.style.opacity = '';
            waifuElement.style.transition = '';
        }, 500);
        
        showWaifuMessage('Goodbye! Click to show me again! 👋', 1000);
    }
}

function resetToNeutralExpression() {
    if (!window.live2dv4 || !currentModel) return;
    
    try {
        // Reset to neutral/default expression (usually index -1 or 0)
        window.live2dv4.setExpression(-1); // -1 typically resets to default
        console.log('🎭 Reset to neutral expression');
    } catch (error) {
        console.warn('Failed to reset expression:', error);
    }
}

// --- Emotional TTS Audio Playback System ---

function playEmotionalTTSAudio(ttsData) {
    try {
        const { audio_data, emotion, intensity, voice } = ttsData;
        
        if (!audio_data || audio_data.length === 0) {
            console.warn('No TTS audio data to play');
            return;
        }
        
        // Create audio context if not exists
        if (!window.audioContext) {
            window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        // Convert audio data to Float32Array
        const audioArray = new Float32Array(audio_data);
        
        // Create audio buffer
        const audioBuffer = window.audioContext.createBuffer(1, audioArray.length, 24000); // 24kHz sample rate
        audioBuffer.copyToChannel(audioArray, 0);
        
        // Create audio source
        const source = window.audioContext.createBufferSource();
        source.buffer = audioBuffer;
        
        // Apply emotional audio effects based on emotion
        const { gainNode, filterNode } = createEmotionalAudioEffects(emotion, intensity);
        
        // Connect audio graph: source -> effects -> output
        source.connect(gainNode);
        gainNode.connect(filterNode);
        filterNode.connect(window.audioContext.destination);
        
        // Play audio
        source.start(0);
        
        console.log(`🔊 Playing emotional TTS: ${emotion} (intensity: ${intensity})`);
        
        // Show TTS playback indicator
        showTTSPlaybackIndicator(emotion, intensity);
        
    } catch (error) {
        console.error('Error playing emotional TTS audio:', error);
        // Fallback: try to play via simple audio element
        fallbackTTSPlayback(ttsData);
    }
}

function createEmotionalAudioEffects(emotion, intensity) {
    const audioContext = window.audioContext;
    
    // Create gain node for volume control
    const gainNode = audioContext.createGain();
    
    // Create filter node for tone shaping
    const filterNode = audioContext.createBiquadFilter();
    
    // Apply emotion-specific audio processing
    switch (emotion) {
        case 'excited':
        case 'happy':
        case 'joyful':
            // Brighter, more energetic sound
            gainNode.gain.value = 1.0 + (intensity * 0.2);
            filterNode.type = 'highpass';
            filterNode.frequency.value = 100 + (intensity * 50);
            break;
            
        case 'sad':
        case 'disappointed':
        case 'empathetic':
            // Warmer, softer sound
            gainNode.gain.value = 0.8 - (intensity * 0.1);
            filterNode.type = 'lowpass';
            filterNode.frequency.value = 3000 - (intensity * 500);
            break;
            
        case 'surprised':
        case 'amazed':
            // Sharp, attention-grabbing sound
            gainNode.gain.value = 1.1 + (intensity * 0.3);
            filterNode.type = 'peaking';
            filterNode.frequency.value = 2000;
            filterNode.Q.value = 2;
            filterNode.gain.value = intensity * 6;
            break;
            
        case 'curious':
        case 'thoughtful':
            // Clear, focused sound
            gainNode.gain.value = 0.9 + (intensity * 0.1);
            filterNode.type = 'peaking';
            filterNode.frequency.value = 1500;
            filterNode.Q.value = 1;
            filterNode.gain.value = intensity * 3;
            break;
            
        default: // neutral, calm
            gainNode.gain.value = 1.0;
            filterNode.type = 'allpass';
            filterNode.frequency.value = 1000;
            break;
    }
    
    return { gainNode, filterNode };
}

function fallbackTTSPlayback(ttsData) {
    try {
        // Create a simple audio element as fallback
        const audio = new Audio();
        
        // Convert audio data to blob
        const audioArray = new Float32Array(ttsData.audio_data);
        const audioBuffer = new ArrayBuffer(audioArray.length * 4);
        const view = new DataView(audioBuffer);
        
        for (let i = 0; i < audioArray.length; i++) {
            view.setFloat32(i * 4, audioArray[i], true);
        }
        
        const blob = new Blob([audioBuffer], { type: 'audio/wav' });
        const url = URL.createObjectURL(blob);
        
        audio.src = url;
        audio.play();
        
        // Clean up
        audio.addEventListener('ended', () => {
            URL.revokeObjectURL(url);
        });
        
        console.log('🔊 TTS playback via fallback method');
        
    } catch (error) {
        console.error('Fallback TTS playback failed:', error);
    }
}

function showTTSPlaybackIndicator(emotion, intensity) {
    // Create or update TTS status indicator
    let ttsIndicator = document.getElementById('tts-indicator');
    
    if (!ttsIndicator) {
        ttsIndicator = document.createElement('div');
        ttsIndicator.id = 'tts-indicator';
        ttsIndicator.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 123, 255, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 1000;
            transition: opacity 0.3s ease;
        `;
        document.body.appendChild(ttsIndicator);
    }
    
    // Update indicator content
    ttsIndicator.textContent = `🔊 ${emotion} (${(intensity * 100).toFixed(0)}%)`;
    ttsIndicator.style.opacity = '1';
    
    // Hide after 3 seconds
    setTimeout(() => {
        ttsIndicator.style.opacity = '0';
    }, 3000);
}

// Show and hide loading spinner
function showLoadingSpinner() {
    if (loadingSpinner) loadingSpinner.style.display = 'block';
}
function hideLoadingSpinner() {
    if (loadingSpinner) loadingSpinner.style.display = 'none';
}

// =============================================================================
// Enhanced Debug UI System
// =============================================================================

// Initialize debug UI elements
function initDebugUI() {
    // Ensure global debug variables exist
    if (!window.debugLogBuffer) {
        window.debugLogBuffer = [];
    }
    if (!window.debugLastMotionName) {
        window.debugLastMotionName = null;
    }
    
    debugSDKStatus = document.querySelector('#debug-sdk-status span');
    debugCanvasStatus = document.querySelector('#debug-canvas-status span');
    debugCurrentModel = document.getElementById('debug-current-model');
    debugMotionCount = document.getElementById('debug-motion-count');
    debugLastMotionName = document.getElementById('debug-last-motion-name');
    debugRealtimeLog = document.getElementById('debug-realtime-log');
    
    // Start periodic status updates
    setInterval(updateDebugStatus, 2000);
    
    // Initial status update
    updateDebugStatus();
    
    debugLog('🔍 Debug UI initialized');
}

// Add entry to debug log
function debugLog(message, type = 'info') {
    // Ensure debugLogBuffer exists
    if (!window.debugLogBuffer) {
        window.debugLogBuffer = [];
    }
    
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = {
        timestamp,
        message,
        type,
        full: `[${timestamp}] ${message}`
    };
    
    window.debugLogBuffer.push(logEntry);
    
    // Keep buffer size manageable
    if (window.debugLogBuffer.length > MAX_DEBUG_LOG_ENTRIES) {
        window.debugLogBuffer.shift();
    }
    
    // Update real-time log display
    updateDebugLogDisplay();
    
    // Also log to console if verbose mode
    if (debugVerboseMode) {
        console.log(`[DEBUG UI] ${message}`);
    }
}

// Update the debug log display
function updateDebugLogDisplay() {
    if (!debugRealtimeLog) return;
    
    // Ensure debugLogBuffer exists
    if (!window.debugLogBuffer) {
        window.debugLogBuffer = [];
    }
    
    const logHtml = window.debugLogBuffer
        .slice(-10) // Show last 10 entries
        .map(entry => {
            const typeClass = entry.type === 'error' ? 'debug-status-error' : 
                             entry.type === 'warn' ? 'debug-status-warn' : 
                             'debug-status-ok';
            return `<div class="${typeClass}">${entry.full}</div>`;
        })
        .join('');
    
    debugRealtimeLog.innerHTML = logHtml;
    debugRealtimeLog.scrollTop = debugRealtimeLog.scrollHeight;
}

// Update debug status indicators
function updateDebugStatus() {
    // Check SDK status
    if (window.live2dv4) {
        setDebugStatus(debugSDKStatus, 'Live2D SDK Loaded', 'ok');
    } else {
        setDebugStatus(debugSDKStatus, 'SDK Missing', 'error');
    }
    
    // Check canvas status
    const canvas = document.getElementById('live2d4');
    if (canvas && canvas.getContext) {
        try {
            const ctx = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (ctx) {
                setDebugStatus(debugCanvasStatus, 'WebGL Ready', 'ok');
            } else {
                setDebugStatus(debugCanvasStatus, 'WebGL Failed', 'error');
            }
        } catch (e) {
            setDebugStatus(debugCanvasStatus, 'Canvas Error', 'error');
        }
    } else {
        setDebugStatus(debugCanvasStatus, 'Canvas Missing', 'error');
    }
    
    // Update model info section (separate from system status)
    updateModelInfo();
}

// Set debug status with color coding
function setDebugStatus(element, text, status) {
    if (!element) return;
    
    element.textContent = text;
    element.className = `debug-status-${status}`;
}

// Update model info section
function updateModelInfo() {
    const currentModelEl = document.getElementById('debug-current-model');
    const motionCountEl = document.getElementById('debug-motion-count');
    const lastMotionEl = document.getElementById('debug-last-motion-name');
    const modelsListEl = document.getElementById('debug-models-list');
    
    if (!currentModelEl || !motionCountEl || !lastMotionEl || !modelsListEl) {
        debugLog('⚠️ Model info elements not found');
        return;
    }
    
    // Update current model info
    if (window.live2dv4 && window.live2dv4._currentModel) {
        currentModelEl.textContent = window.live2dv4._currentModel;
        
        // Get motion groups count
        if (window.live2dv4._motionGroups) {
            const groupCount = Object.keys(window.live2dv4._motionGroups).length;
            motionCountEl.textContent = groupCount;
        } else {
            motionCountEl.textContent = '0';
        }
        
        // Get last motion
        if (window.live2dv4._lastMotion) {
            lastMotionEl.textContent = window.live2dv4._lastMotion;
        } else {
            lastMotionEl.textContent = 'None';
        }
    } else {
        currentModelEl.textContent = 'None';
        motionCountEl.textContent = '0';
        lastMotionEl.textContent = 'None';
    }
    
    // Load available models from API
    fetch('/api/live2d/models')
        .then(response => response.json())
        .then(data => {
            // API returns models directly as array, not wrapped in data.models
            if (data && data.length > 0) {
                const modelNames = data.map(m => m.model_name).join(', ');
                modelsListEl.textContent = modelNames;
                // Suppress log spam: only log if model list changed
                if (!updateModelInfo._lastLoggedModelNames || updateModelInfo._lastLoggedModelNames !== modelNames) {
                    debugLog(`📦 Available models: ${modelNames}`);
                    updateModelInfo._lastLoggedModelNames = modelNames;
                }
            } else {
                modelsListEl.textContent = 'No models found';
            }
        })
        .catch(error => {
            modelsListEl.textContent = 'Error loading';
            debugLog(`❌ Error loading database info: ${error.message}`);
        });
}

// Update database info section
function updateDatabaseInfo() {
    const dbModelCountEl = document.getElementById('debug-db-model-count');
    const dbMotionCountEl = document.getElementById('debug-db-motion-count');
    const dbConnectionEl = document.getElementById('debug-db-connection');
    
    if (!dbModelCountEl || !dbMotionCountEl || !dbConnectionEl) {
        debugLog('⚠️ Database info elements not found');
        return;
    }
    
    // Load database status from API
    fetch('/api/live2d/system_status')
        .then(response => response.json())
        .then(data => {
            if (data.database_connection) {
                dbConnectionEl.textContent = 'Connected';
                dbConnectionEl.className = 'debug-status-success';
                
                dbModelCountEl.textContent = data.models_count || '0';
                dbMotionCountEl.textContent = data.total_motions || '0';
                
                debugLog(`📊 DB Status: ${data.models_count} models, ${data.total_motions} motions`);
            } else {
                dbConnectionEl.textContent = 'Disconnected';
                dbConnectionEl.className = 'debug-status-error';
                dbModelCountEl.textContent = '-';
                dbMotionCountEl.textContent = '-';
                debugLog('❌ Database connection failed');
            }
        })
        .catch(error => {
            dbConnectionEl.textContent = 'Error';
            dbConnectionEl.className = 'debug-status-error';
            dbModelCountEl.textContent = '-';
            dbMotionCountEl.textContent = '-';
            debugLog(`❌ Error loading database info: ${error.message}`);
        });
}

// Debug control functions
function debugRefreshStatus() {
    debugLog('🔄 Manual status refresh requested');
    updateDebugStatus();
    updateModelInfo();
    updateDatabaseInfo();
    
    // Also refresh model info
    if (window.live2dv4) {
        debugLog(`📊 SDK Methods: ${Object.keys(window.live2dv4).length}`);
        if (window.live2dv4._model) {
            debugLog(`📊 Model Methods: ${Object.keys(window.live2dv4._model).length}`);
        }
    }
}

function debugTestMotion() {
    debugLog('🎭 Testing random motion...');
    const result = triggerRandomMotion();
    if (result) {
        debugLog('✅ Motion test completed');
    } else {
        debugLog('❌ Motion test failed', 'error');
    }
}

function debugLogMotions() {
    debugLog('📝 Logging available motions...');
    logAvailableMotions();
    
    if (window.live2dv4?._model?._modelSetting) {
        try {
            const settings = window.live2dv4._model._modelSetting;
            if (settings.getMotionGroupCount) {
                const groupCount = settings.getMotionGroupCount();
                debugLog(`📊 Found ${groupCount} motion groups`);
                
                for (let i = 0; i < Math.min(groupCount, 5); i++) {
                    const groupName = settings.getMotionGroupName(i);
                    const motionCount = settings.getMotionCount ? settings.getMotionCount(groupName) : '?';
                    debugLog(`  ${i + 1}. ${groupName} (${motionCount} motions)`);
                }
                
                if (groupCount > 5) {
                    debugLog(`  ... and ${groupCount - 5} more groups`);
                }
            }
        } catch (e) {
            debugLog('❌ Failed to log motions: ' + e.message, 'error');
        }
    } else {
        debugLog('❌ No model loaded for motion logging', 'error');
    }
}

function debugClearLog() {
    if (!window.debugLogBuffer) {
        window.debugLogBuffer = [];
    }
    window.debugLogBuffer = [];
    updateDebugLogDisplay();
    debugLog('🗑 Debug log cleared');
}

function debugToggleVerbose() {
    debugVerboseMode = !debugVerboseMode;
    debugLog(`💬 Verbose mode: ${debugVerboseMode ? 'ON' : 'OFF'}`);
}

// Make debug functions globally accessible
window.debugRefreshStatus = debugRefreshStatus;
window.debugTestMotion = debugTestMotion;
window.debugLogMotions = debugLogMotions;
window.debugClearLog = debugClearLog;
window.debugToggleVerbose = debugToggleVerbose;
window.debugLog = debugLog; // Make debugLog globally accessible

// Make debug variables globally accessible
window.debugLogBuffer = debugLogBuffer;
window.debugLastMotionName = debugLastMotionName;

// Hook into existing functions to add debug logging
const originalTriggerRandomMotion = triggerRandomMotion;
triggerRandomMotion = function() {
    const result = originalTriggerRandomMotion.apply(this, arguments);
    if (result && debugLastMotionName) {
        // Try to get the last motion name
        debugLastMotionName.textContent = 'Random Motion';
    }
    return result;
};

// Hook into model loading to update debug UI
const originalLoadModel = loadModel;
loadModel = function(modelName) {
    debugLog(`🔄 Loading model: ${modelName}`);
    const result = originalLoadModel.apply(this, arguments);
    
    // Update debug UI after a delay
    setTimeout(() => {
        updateDebugStatus();
        debugLog(`✅ Model load completed: ${modelName}`);
    }, 2000);
    
    return result;
};

// Initialize debug UI when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(initDebugUI, 1000);
    
    // Add a function to test if debug UI is working
    window.testDebugUI = function() {
        debugLog('🧪 Debug UI test function called!');
        console.log('🧪 Debug UI test function called!');
        alert('Debug UI is working! Check the debug log panel.');
        return true;
    };
    
    // Add function to load default model
    window.loadDefaultModel = function() {
        const defaultModel = 'kanade';
        debugLog('📦 Loading default model: ' + defaultModel);
        if (typeof loadModel === 'function') {
            loadModel(defaultModel);
        } else {
            debugLog('❌ loadModel function not available', 'error');
        }
        setTimeout(() => {
            updateDebugStatus();
            debugLog('✅ Model load attempt completed');
        }, 1500);
    };

    // Patch debug button handlers to check for model presence
    ['debugTestMotion', 'debugLogMotions', 'testBasicLive2D', 'debugLive2D', 'testAllMotions'].forEach(fn => {
        const orig = window[fn];
        if (typeof orig === 'function') {
            window[fn] = function() {
                if (!currentModel || !window.live2dv4 || !window.live2dv4._model) {
                    debugLog('❌ No model loaded. Please load a model first.', 'error');
                    const loadBtn = document.getElementById('debug-load-default-model');
                    if (loadBtn) loadBtn.style.display = 'inline-block';
                    return false;
                } else {
                    const loadBtn = document.getElementById('debug-load-default-model');
                    if (loadBtn) loadBtn.style.display = 'none';
                    return orig.apply(this, arguments);
                }
            }
        }
    });

    // Show/hide the load default model button based on model status
    function updateDebugStatusPatched() {
        if (typeof updateDebugStatus === 'function') {
            updateDebugStatus();
        }
        const loadBtn = document.getElementById('debug-load-default-model');
        if (loadBtn) {
            if (!currentModel || !window.live2dv4 || !window.live2dv4._model) {
                loadBtn.style.display = 'inline-block';
            } else {
                loadBtn.style.display = 'none';
            }
        }
    }
    
    // Update debug status more frequently and show load button when needed
    setInterval(updateDebugStatusPatched, 2000);
    
    // Add better error handling for button clicks
    window.addEventListener('error', function(e) {
        debugLog(`❌ JavaScript Error: ${e.message}`, 'error');
        console.error('JavaScript Error caught:', e);
    });
    
    // Debug button click handler
    window.handleDebugButtonClick = function(action) {
        try {
            debugLog(`🔘 Button clicked: ${action}`);
            switch(action) {
                case 'refresh':
                    debugRefreshStatus();
                    break;
                case 'test-motion':
                    debugTestMotion();
                    break;
                case 'log-motions':
                    debugLogMotions();
                    break;
                case 'clear-log':
                    debugClearLog();
                    break;
                case 'toggle-verbose':
                    debugToggleVerbose();
                    break;
                default:
                    debugLog(`❓ Unknown action: ${action}`, 'warn');
            }
        } catch (error) {
            debugLog(`❌ Error handling button click: ${error.message}`, 'error');
            console.error('Button click error:', error);
        }
    };

    // Enhanced debug console functions
    window.toggleDebugConsole = function() {
        const debugPanel = document.getElementById('debugUIPanel');
        if (!debugPanel) return;
        
        const isVisible = debugPanel.style.display !== 'none';
        debugPanel.style.display = isVisible ? 'none' : 'block';
        
        if (!isVisible) {
            debugLog('🔍 Debug console opened');
            debugRefreshAll();
        } else {
            debugLog('🔍 Debug console closed');
        }
    };

    window.debugRefreshAll = function() {
        debugLog('🔄 Refreshing all system status...');
        updateDebugStatus();
        updateDatabaseInfo();
        const modelsListElement = document.getElementById('debug-models-list');
        if (modelsListElement) {
            modelsListElement.textContent = availableModels.join(', ');
        }
        debugLog('✅ Status refresh completed');
    };

    window.debugTestSystem = async function() {
        debugLog('🧪 === Starting System Test ===');
        debugLog(window.live2dv4 ? '✅ Live2D SDK: Available' : '❌ Live2D SDK: Missing');
        debugLog(currentModel ? `✅ Model: ${currentModel}` : '❌ Model: None');
        const canvas = document.getElementById('live2d4');
        debugLog(canvas ? '✅ Canvas: Found' : '❌ Canvas: Missing');
        await testDatabaseConnection();
        debugLog('🎉 === System Test Complete ===');
    };

    window.debugDatabaseInfo = async function() {
        debugLog('💾 Loading database information...');
        try {
            const response = await fetch('/api/live2d/models');
            if (response.ok) {
                const models = await response.json();
                debugLog(`📦 Database models: ${models.length}`);
                document.getElementById('debug-db-model-count').textContent = models.length;
                document.getElementById('debug-db-connection').textContent = 'Connected';
            } else {
                throw new Error(`HTTP ${response.status}`);
            }
        } catch (error) {
            debugLog(`❌ Database error: ${error.message}`, 'error');
            document.getElementById('debug-db-connection').textContent = 'Error';
        }
    };

    window.debugClearDatabase = async function() {
        if (!confirm('⚠️ WARNING: Delete ALL database content?')) return;
        debugLog('🗑 Clearing database...');
        try {
            const response = await fetch('/api/live2d/clear_database', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            if (response.ok) {
                debugLog('✅ Database cleared');
                document.getElementById('debug-db-model-count').textContent = '0';
                document.getElementById('debug-db-motion-count').textContent = '0';
            }
        } catch (error) {
            debugLog(`❌ Clear error: ${error.message}`, 'error');
        }
    };

    window.debugReimportData = async function() {
        if (!confirm('📥 Re-import all models and motions?')) return;
        debugLog('📥 Starting re-import...');
        try {
            const response = await fetch('/api/live2d/reimport_all', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            if (response.ok) {
                const result = await response.json();
                debugLog(`✅ Imported: ${result.models_imported || 0} models, ${result.motions_imported || 0} motions`);
                await debugDatabaseInfo();
            }
        } catch (error) {
            debugLog(`❌ Import error: ${error.message}`, 'error');
        }
    };

    window.debugLoadDefaultModel = function() {
        debugLog('📦 Loading default model: kanade');
        loadModel('kanade');
    };

    window.debugExportLog = function() {
        console.log('📤 === EXPORTED DEBUG LOG ===');
        window.debugLogBuffer.forEach(entry => console.log(entry.full));
        console.log('📤 === END DEBUG LOG ===');
        debugLog(`📤 Exported ${window.debugLogBuffer.length} entries`);
    };

    async function testDatabaseConnection() {
        try {
            const response = await fetch('/api/live2d/models');
            if (response.ok) {
                debugLog('✅ Database: Connected');
                return true;
            } else {
                debugLog('❌ Database: Failed', 'error');
                return false;
            }
        } catch (error) {
            debugLog(`❌ Database: ${error.message}`, 'error');
            return false;
        }
    }

    // Connect debug button to toggle console
    setTimeout(() => {
        const debugButton = document.querySelector('.waifu-tool .icon-about');
        if (debugButton) {
            debugButton.addEventListener('click', (e) => {
                e.preventDefault();
                toggleDebugConsole();
            });
            debugLog('🔗 Debug console connected to waifu button');
        }
    }, 2000);
});
</script>
</body>
</html>
