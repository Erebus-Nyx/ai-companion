<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live2D AI Companion - Dual Architecture Testing Interface</title>
    <link rel="stylesheet" href="/static/css/live2d_test.css">
    <!-- Live2D AI Companion - Production-ready avatar system with dual runtime support -->
</head>
</head>
<body>
    <div class="app-container">
        <!-- Navigation Icons (Top Right) -->
        <nav class="nav-icons" id="navIcons">
            <button class="nav-icon" onclick="openChat()" title="Chat" data-tooltip="Chat">
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"/>
                </svg>
            </button>
            <button class="nav-icon" onclick="openPeople()" title="People" data-tooltip="People">
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                    <circle cx="9" cy="7" r="4"/>
                    <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                    <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                </svg>
            </button>
            <button class="nav-icon" onclick="openSettings()" title="Settings" data-tooltip="Settings">
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="3"/>
                    <path d="M12 1v6m0 6v6m11-7h-6m-6 0H1"/>
                </svg>
            </button>
            <div class="nav-divider"></div>
            <button class="nav-icon" onclick="toggleFullscreen()" title="Fullscreen" data-tooltip="Fullscreen">
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
                </svg>
            </button>
            <button class="nav-icon" onclick="toggleHelp()" title="Help" data-tooltip="Help">
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
                    <point cx="12" cy="17"/>
                </svg>
            </button>
        </nav>
        
        <!-- Chat Window -->
        <div class="chat-window" id="chatWindow">
            <div class="chat-header">
                <span class="chat-title">Chat</span>
                <div class="window-controls">
                    <button class="control-btn" onclick="toggleChatSnap()" title="Toggle Snap">📌</button>
                    <button class="close-btn" onclick="closeChat()">×</button>
                </div>
            </div>
            <div class="chat-content">
                <div class="chat-messages" id="chatMessages">
                    <!-- Chat messages will be populated here -->
                </div>
                <div class="chat-input-container">
                    <input type="text" class="chat-input" id="chatInput" placeholder="Type a message..." onkeypress="handleChatKeyPress(event)">
                    <button class="send-btn" onclick="sendMessage()">Send</button>
                    <button class="voice-btn" id="voiceButton" onclick="toggleVoiceRecording()" title="Voice Recording">🎤</button>
                </div>
            </div>
        </div>
        
        <!-- People Panel (Right Side) -->
        <div class="people-panel" id="peoplePanel">
            <div class="people-header">
                <span class="people-title">People</span>
                <div class="window-controls">
                    <button class="control-btn" onclick="togglePeopleSnap()" title="Toggle Snap">📌</button>
                    <button class="close-btn" onclick="closePeople()">×</button>
                </div>
            </div>
            <div class="people-content">
                <div class="people-models-list" id="peopleModelsList">
                    <!-- Model icons will be populated here vertically -->
                </div>
                <div class="people-controls">
                    <button class="add-model-btn" onclick="showAddModelDialog()" title="Add new model">
                        <span class="add-icon">+</span>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Settings Panel (Left Side Overlay) -->
        <div class="settings-panel" id="settingsPanel">
            <div class="settings-header">
                <span class="settings-title">Live2D Settings</span>
                <div class="window-controls">
                    <button class="control-btn" onclick="toggleSettingsSnap()" title="Toggle Snap">📌</button>
                    <button class="close-btn" onclick="closeSettings()">×</button>
                </div>
            </div>
            <div class="settings-content">
                <div class="settings-group">
                    <h4>Model Selection</h4>
                    <div class="setting-item">
                        <label for="modelSelect">Model:</label>
                        <select id="modelSelect" onchange="onModelChange()">
                            <option value="">Select a model...</option>
                        </select>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h4>Display Controls</h4>
                    <div class="setting-item">
                        <label for="zoomSlider">Scale: <span id="zoomValue">1.0</span></label>
                        <input type="range" id="zoomSlider" min="0.1" max="3.0" step="0.1" value="1.0" oninput="updateZoom(this.value); document.getElementById('zoomValue').textContent = this.value;">
                    </div>
                    <div class="setting-controls">
                        <button class="btn btn-secondary" onclick="resetZoom()">Reset</button>
                        <button class="btn btn-secondary" onclick="fitModel()">Fit</button>
                        <button class="btn btn-secondary" onclick="centerModel()">Center</button>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h4>Motions</h4>
                    <div class="setting-item">
                        <label for="motionGroupSelect">Motion Group:</label>
                        <select id="motionGroupSelect" onchange="onMotionGroupChange()">
                            <option value="">No motions available</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label for="motionSelect">Motion:</label>
                        <select id="motionSelect" onchange="onMotionTypeChange()">
                            <option value="">Select motion group first</option>
                        </select>
                    </div>
                    <div class="setting-controls">
                        <button class="btn btn-primary" onclick="playSelectedMotion()">Play Motion</button>
                        <button class="btn btn-secondary" onclick="playRandomMotion()">Random</button>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h4>Expressions</h4>
                    <div class="setting-item">
                        <label for="expressionSelect">Expression:</label>
                        <select id="expressionSelect" onchange="onExpressionChange()">
                            <option value="">No expressions available</option>
                        </select>
                    </div>
                    <div class="setting-controls">
                        <button class="btn btn-primary" onclick="playExpression()">Apply Expression</button>
                        <button class="btn btn-secondary" onclick="resetExpression()">Reset</button>
                    </div>
                </div>
                
                <div class="settings-group">
                    <h4>Actions</h4>
                    <div class="setting-controls">
                        <button class="btn btn-primary" onclick="testModel()">Test Model</button>
                        <button class="btn btn-warning" onclick="resetModel()">Reset</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Canvas Area -->
        <div class="canvas-container">
            <div class="canvas-frame">
                <div id="pixiContainer"></div>
            </div>
            <div class="loading-overlay" id="loadingOverlay" style="display: none;">
                <div class="loading-spinner"></div>
            </div>
        </div>
    </div>

    <!-- Model Selection Dialog -->
    <div class="model-selection-dialog" id="modelSelectionDialog" style="display: none;">
        <div class="dialog-overlay" onclick="closeAddModelDialog()"></div>
        <div class="dialog-content">
            <div class="dialog-header">
                <h3>Add Live2D Model</h3>
                <button class="dialog-close" onclick="closeAddModelDialog()">×</button>
            </div>
            <div class="dialog-body">
                <div class="model-grid" id="modelGrid">
                    <div style="text-align: center; padding: 20px; color: #aaa;">
                        Loading available models...
                    </div>
                </div>
            </div>
        </div>
    </div>

<!-- Load PIXI.js and Live2D libraries in correct order -->
<!-- Step 1: Load PIXI.js 6.5.10 from dist folder -->
<script src="/static/dist/pixi-6.5.10.min.js"></script>

<!-- Step 2: Load EventEmitter compatibility for PIXI v6 -->
<script src="/static/js/eventemitter-preloader-v6.js"></script>

<!-- Step 3: Load Live2D v2 Bundle for Cubism 2.x models -->
<script src="/static/dist/live2d_bundle.js"></script>

<!-- Step 4: Load Cubism 5 Core for modern models -->
<script src="/static/dist/CubismSdkForWeb-5-r.4/Core/live2dcubismcore.min.js"></script>

<!-- Step 6: Verify dual architecture setup -->
<script>
console.log('=== Dual Architecture Verification ===');
console.log('PIXI version:', typeof PIXI !== 'undefined' ? PIXI.VERSION : 'Not loaded');
console.log('EventEmitter available:', typeof EventEmitter !== 'undefined');
console.log('Live2D v2 Bundle loaded:', typeof window.Live2D !== 'undefined');
console.log('Cubism 5 Core loaded:', typeof window.Live2DCubismCore !== 'undefined');

// Debug Live2D v2 Bundle
if (typeof window.Live2D !== 'undefined') {
    console.log('✓ Live2D v2 Bundle ready for Cubism 2.x models');
    console.log('- window.Live2D:', typeof window.Live2D);
    console.log('- window.Live2DModelWebGL:', typeof window.Live2DModelWebGL);
    console.log('- window.live2dv2:', typeof window.live2dv2);
}

// Debug Cubism 5 Core
if (typeof window.Live2DCubismCore !== 'undefined') {
    console.log('✓ Cubism 5 Core ready for modern models');
    console.log('- Core version:', window.Live2DCubismCore.Version ? window.Live2DCubismCore.Version.csmGetVersion() : 'unknown');
}

console.log('=== End Verification ===');
</script>

<!-- Step 5: Load pixi-live2d-display (local for offline installation) -->
<script src="/static/dist/pixi-live2d-display-0.4.0.min.js"></script>

<!-- Step 5: Verify Live2D plugin initialization -->
<script>
// AI Companion API Configuration - Dynamic configuration loading
window.ai2d_chat_CONFIG = {
    // Default fallback configuration
    API_BASE_URL: (() => {
        const protocol = window.location.protocol;
        const hostname = window.location.hostname;
        const port = window.location.port;
        
        // Use current protocol and host
        if (port) {
            return `${protocol}//${hostname}:${port}`;
        }
        return `${protocol}//${hostname}`;
    })(),
    
    // Configuration loading status
    _configLoaded: false,
    _configPromise: null
};

// Function to load server configuration dynamically
async function loadServerConfig() {
    if (window.ai2d_chat_CONFIG._configLoaded) {
        return window.ai2d_chat_CONFIG;
    }
    
    if (window.ai2d_chat_CONFIG._configPromise) {
        return window.ai2d_chat_CONFIG._configPromise;
    }
    
    window.ai2d_chat_CONFIG._configPromise = (async () => {
        try {
            console.log('Loading server configuration from API...');
            
            // Try to fetch configuration from the server
            const configResponse = await fetch('/api/system/config');
            if (configResponse.ok) {
                const serverConfig = await configResponse.json();
                
                // Update the configuration
                window.ai2d_chat_CONFIG.API_BASE_URL = serverConfig.server.base_url;
                window.ai2d_chat_CONFIG.serverConfig = serverConfig;
                window.ai2d_chat_CONFIG._configLoaded = true;
                
                console.log('✅ Server configuration loaded successfully:', serverConfig.server.base_url);
                return window.ai2d_chat_CONFIG;
            } else {
                throw new Error(`Config API returned ${configResponse.status}`);
            }
        } catch (error) {
            console.warn('⚠️ Failed to load server config from API, using fallback:', error.message);
            
            // Fallback: use current location as base
            const protocol = window.location.protocol;
            const hostname = window.location.hostname;
            const port = window.location.port;
            
            window.ai2d_chat_CONFIG.API_BASE_URL = port ? 
                `${protocol}//${hostname}:${port}` : 
                `${protocol}//${hostname}`;
            
            window.ai2d_chat_CONFIG._configLoaded = true;
            
            console.log('Using fallback configuration:', window.ai2d_chat_CONFIG.API_BASE_URL);
            return window.ai2d_chat_CONFIG;
        }
    })();
    
    return window.ai2d_chat_CONFIG._configPromise;
}

// Initialize configuration
console.log('AI Companion API Config (initial):', window.ai2d_chat_CONFIG.API_BASE_URL);
console.log('Protocol detected:', window.location.protocol);

// Helper function for making API calls with proper config loading
window.makeApiCall = async function(endpoint, options = {}) {
    // Ensure config is loaded
    await loadServerConfig();
    
    const url = `${window.ai2d_chat_CONFIG.API_BASE_URL}${endpoint}`;
    console.log(`Making API call to: ${url}`);
    
    return fetch(url, options);
};
</script>

<script>
// Initialize Live2D plugin following Live2D Viewer Web pattern
console.log('Initializing Live2D plugin (Live2D Viewer Web compatible)...');

// Wait for all scripts to load
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(function() {
        console.log('Checking library compatibility...');
        
        // Verify libraries are loaded
        if (typeof PIXI === 'undefined') {
            console.error('PIXI.js not loaded');
            return;
        }
        
        if (typeof EventEmitter === 'undefined') {
            console.error('EventEmitter not available');
            return;
        }
        
        console.log('✓ PIXI version:', PIXI.VERSION);
        console.log('✓ EventEmitter type:', typeof EventEmitter);
        
        // Check if PIXI.utils.EventEmitter exists (Live2D Viewer Web pattern)
        if (PIXI.utils && PIXI.utils.EventEmitter) {
            console.log('✓ PIXI.utils.EventEmitter available (Live2D Viewer Web compatible)');
        }
        
        // Check if Live2D plugin is available
        if (typeof PIXI.live2d === 'undefined') {
            console.error('✗ PIXI.live2d not loaded - pixi-live2d-display may not be compatible');
            console.log('Available PIXI properties:', Object.keys(PIXI));
            
            // Try to diagnose the issue
            if (window.pixiLive2DLoadError) {
                console.error('Library loading error detected - check network tab');
            }
        } else {
            console.log('✓ PIXI.live2d loaded successfully');
            console.log('Available PIXI.live2d properties:', Object.keys(PIXI.live2d));
            
            // Check for Live2DModel
            if (PIXI.live2d.Live2DModel) {
                console.log('✓ Live2DModel class available');
                window.Live2DModel = PIXI.live2d.Live2DModel;
                
                // Test if it has the expected methods
                if (typeof PIXI.live2d.Live2DModel.from === 'function') {
                    console.log('✓ Live2DModel.from() method available');
                } else {
                    console.warn('Live2DModel.from() method not found');
                }
            } else {
                console.warn('Live2DModel not found in PIXI.live2d');
            }
            
            // Check for Live2DFactory
            if (PIXI.live2d.Live2DFactory) {
                console.log('✓ Live2DFactory available');
                window.Live2DFactory = PIXI.live2d.Live2DFactory;
            } else {
                console.warn('Live2DFactory not found in PIXI.live2d');
            }
        }
        
        console.log('Live2D plugin initialization check complete');
        console.log('System ready for Live2D model loading');
        
        // NOW INITIALIZE THE LIVE2D SYSTEM
        if (typeof initializeLive2D === 'function') {
            console.log('Starting Live2D modular system initialization...');
            
            // Load server configuration before initializing Live2D
            loadServerConfig().then(() => {
                console.log('Server configuration loaded, initializing Live2D...');
                return initializeLive2D();
            }).then(() => {
                console.log('Live2D system initialization complete!');
            }).catch(error => {
                console.error('Live2D system initialization failed:', error);
            });
        } else {
            console.error('initializeLive2D function not found!');
        }
        
    }, 500); // Increased delay to ensure all libraries are loaded
});
</script>

<!-- Step 5: Load Live2D modular system -->
</script>
    
    <script src="/static/js/live2d_config.js"></script>
    <script src="/static/js/live2d_core.js"></script>  
    <script src="/static/js/live2d_core_simple.js"></script>
    <script src="/static/js/live2d_integration.js"></script>
    <script src="/static/js/live2d_interaction.js"></script>
    <script src="/static/js/live2d_logger.js"></script>
    <script src="/static/js/live2d_model_loader.js"></script>
    <script src="/static/js/live2d_model_manager.js"></script>
    <script src="/static/js/live2d_motion_manager.js"></script>
    <script src="/static/js/live2d_motions.js"></script>
    <script src="/static/js/live2d_mouse_interaction.js"></script>    
    <script src="/static/js/live2d_multi_model_manager.js"></script>    
    <script src="/static/js/live2d_simple_fix.js"></script>    
    <script src="/static/js/live2d_tester.js"></script>
    <script src="/static/js/live2d_ui_controller.js"></script>

    <!-- UI components -->
    <script src="/static/js/ui_drawing_system.js"></script>
    <script src="/static/js/ui_icon_manager.js"></script>     
    <script src="/static/js/ui_panel_management.js"></script>
    <script src="/static/js/ui_people_panel.js"></script>
    <script src="/static/js/ui_panel_manager.js"></script>
    <script src="/static/js/ui_character_profiles.js"></script>
    <script src="/static/js/ui_debug_console.js"></script>
    <script src="/static/js/ui_debug_logger.js"></script>

    <!-- Audio Processing -->
    <script src="/static/js/audio_voice_recording.js"></script>
    <script src="/static/js/audio_tts.js"></script> 

    <!-- Additional Functionality -->
    <script src="/static/js/autonomous_avatars.js"></script>
    <script src="/static/js/chat_manager.js"></script>
    <script src="/static/js/db_manager.js"></script>
    <script src="/static/js/user_profile.js"></script>
    <script src="/static/js/config_api_helpers.js"></script>

    <!-- Compatibility Functions -->
    <script src="/static/js/compatibility_functions.js"></script>

    <!-- Debug Tools -->
    <script src="/static/js/debug_model_visibility.js"></script>
    <script src="/static/js/debug_stage_inspection.js"></script>

    <!-- Main Initialization System -->
    <script src="/static/js/main_initialization.js"></script>

    <!-- SocketIO for real-time communication -->
    <script src="https://cdn.socket.io/4.5.0/socket.io.min.js"></script>

<script>
// Global variables for the modular system
let live2dIntegration = null;
let uiController = null;
let live2dMultiModelManager = null; // Make available globally for remove buttons
let currentModel = null; // Add current model reference
let pixiApp = null; // Add PIXI app reference

// Function to update current model reference when active model changes
function updateCurrentModelReference() {
    if (live2dMultiModelManager) {
        const activeModelData = live2dMultiModelManager.getActiveModel();
        console.log('🔍 Active model check:', {
            hasActiveModelData: !!activeModelData,
            activeModelDataKeys: activeModelData ? Object.keys(activeModelData) : null,
            hasModel: activeModelData ? !!activeModelData.model : false,
            modelType: activeModelData && activeModelData.model ? typeof activeModelData.model : null,
            modelName: activeModelData ? activeModelData.name : null
        });
        
        if (activeModelData && activeModelData.model) {
            currentModel = activeModelData.model;
            console.log('🔄 Updated currentModel reference to:', activeModelData.name);
            
            // Update PIXI app reference from integration
            if (live2dIntegration && live2dIntegration.app) {
                pixiApp = live2dIntegration.app;
                console.log('🔄 Updated pixiApp reference from integration');
            }
            
            // Set up mouse interaction for the new current model (only if not already set up)
            if (currentModel && pixiApp && !currentModel._interactionSetup) {
                setupLive2DMouseInteraction(currentModel);
                currentModel._interactionSetup = true; // Mark as set up to prevent duplicates
            }
            
            return true;
        } else {
            // Try alternative method - get all models and find the active one
            const allModels = live2dMultiModelManager.getAllModels();
            console.log('🔍 Trying alternative method - all models:', allModels.length);
            
            for (let modelData of allModels) {
                if (modelData.model && modelData.model.visible) {
                    currentModel = modelData.model;
                    console.log('🔄 Found visible model:', modelData.name);
                    
                    // Update PIXI app reference
                    if (live2dIntegration && live2dIntegration.app) {
                        pixiApp = live2dIntegration.app;
                    }
                    
                    // Set up mouse interaction (only if not already set up)
                    if (currentModel && pixiApp && !currentModel._interactionSetup) {
                        setupLive2DMouseInteraction(currentModel);
                        currentModel._interactionSetup = true;
                    }
                    
                    return true;
                }
            }
            
            currentModel = null;
            console.log('❌ No active model found');
            return false;
        }
    }
    currentModel = null;
    return false;
}

// Initialize the modular Live2D system
async function initializeLive2D() {
    try {
        console.log('Initializing Live2D modular system...');
        
        // Check if modular classes are available, if not use fallback
        if (typeof Live2DIntegration === 'undefined') {
            console.warn('Live2DIntegration class not found, using fallback initialization');
            await initializeFallbackLive2D();
            return;
        }
        
        // Create integration instance
        live2dIntegration = new Live2DIntegration();
        
        // Initialize integration (canvas container)
        const success = await live2dIntegration.initialize('pixiContainer');
        
        if (!success) {
            throw new Error('Failed to initialize Live2D integration');
        }
        
        // Create UI controller
        uiController = new Live2DUIController(live2dIntegration);
        
        // Initialize UI controller
        await uiController.initialize();
        
        // Store reference to multi-model manager for global access
        live2dMultiModelManager = live2dIntegration.modelManager;
        
        // Store PIXI app reference from integration.core.app (correct location)
        pixiApp = live2dIntegration.core.app;
        
        // CRITICAL: Make globals available to other scripts
        window.live2dIntegration = live2dIntegration;
        window.live2dMultiModelManager = live2dMultiModelManager;
        window.uiController = uiController;
        window.pixiApp = pixiApp;
        
        // CRITICAL: Apply interaction fix immediately after initialization
        console.log('🔧 Applying PIXI interaction fix...');
        if (typeof fixPixiInteractionSystem === "function") fixPixiInteractionSystem();
        
        // Set up connection between multi-model manager and UI controller
        live2dMultiModelManager.setUIController(uiController);
        
        // Initialize the People panel with actual loaded models (clear any hardcoded data)
        populatePeopleModels();
        
        console.log('Live2D system initialized successfully!');
        
    } catch (error) {
        console.error('Failed to initialize Live2D system:', error);
        console.log('Attempting fallback initialization...');
        await initializeFallbackLive2D();
    }
}

// Fallback initialization with Direct Mouse Interaction Implementation
async function initializeFallbackLive2D() {
    try {
        console.log('Initializing fallback Live2D system with mouse interaction...');
        
        // Create basic PIXI application
        pixiApp = new PIXI.Application({
            width: window.innerWidth,
            height: window.innerHeight,
            backgroundColor: 0x000000, // Black background instead of blue
            transparent: true,
            antialias: true,
            resolution: window.devicePixelRatio || 1,
            autoDensity: true
        });
        
        // Add canvas to container
        const container = document.getElementById('pixiContainer');
        container.appendChild(pixiApp.view);
        
        // Set up stage interaction (CRITICAL for mouse events)
        pixiApp.stage.interactive = true;
        pixiApp.stage.hitArea = pixiApp.screen;
        
        // Make globals available
        window.pixiApp = pixiApp;
        window.currentModel = null;
        
        console.log('✅ Fallback Live2D system with mouse interaction initialized');
        
        // Set up model info display
        updateModelInfoDisplay('System ready - load a model to test mouse interaction');
        
        // Try to load a test model if available
        await tryLoadTestModel();
        
    } catch (error) {
        console.error('Failed to initialize fallback Live2D system:', error);
        updateModelInfoDisplay('❌ Failed to initialize Live2D system');
    }
}

// Try to load a test model for interaction testing
async function tryLoadTestModel() {
    try {
        // This would attempt to load a model from the server
        const response = await fetch('/api/live2d/models');
        if (response.ok) {
            const models = await response.json();
            if (models && models.length > 0) {
                console.log(`Found ${models.length} models available for testing`);
                updateModelInfoDisplay(`Found ${models.length} models - use People panel to load one`);
            }
        }
    } catch (error) {
        console.log('Could not fetch models for testing:', error.message);
        updateModelInfoDisplay('System ready - add models via People panel');
    }
}

// Live2D Viewer Web Mouse Interaction Implementation
function setupLive2DMouseInteraction(model) {
    if (!model || !pixiApp) {
        console.warn('Cannot setup mouse interaction: missing model or PIXI app');
        return;
    }
    
    console.log('🖱️ Setting up Live2D Viewer Web mouse interaction for model:', model.internalModel?.settings?.name || 'Unknown');
    
    // Enable interaction on the model (Live2D Viewer Web pattern)
    model.interactive = true;
    model.buttonMode = true;
    
    // Set up dragging variables
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let modelStart = { x: 0, y: 0 };
    
    // Mouse down - start dragging (Live2D Viewer Web pattern)
    model.removeAllListeners('pointerdown'); // Prevent duplicate listeners
    model.on('pointerdown', (event) => {
        isDragging = true;
        const position = event.data.global;
        dragStart.x = position.x;
        dragStart.y = position.y;
        modelStart.x = model.x;
        modelStart.y = model.y;
        
        // Prevent event bubbling
        event.stopPropagation();
        console.log('🖱️ Model drag started at:', position);
        
        // Update model info
        updateModelInfoDisplay(`Dragging model from (${Math.round(modelStart.x)}, ${Math.round(modelStart.y)})`);
    });
    
    // Mouse move - drag the model (use app stage for global movement)
    pixiApp.stage.removeAllListeners('pointermove'); // Prevent duplicate listeners
    pixiApp.stage.on('pointermove', (event) => {
        if (!isDragging) return;
        
        const position = event.data.global;
        const deltaX = position.x - dragStart.x;
        const deltaY = position.y - dragStart.y;
        
        model.x = modelStart.x + deltaX;
        model.y = modelStart.y + deltaY;
        
        // Update model info during drag
        updateModelInfoDisplay(`Position: (${Math.round(model.x)}, ${Math.round(model.y)}) Scale: ${model.scale.x.toFixed(2)}`);
    });
    
    // Mouse up - stop dragging
    pixiApp.stage.removeAllListeners('pointerup'); // Prevent duplicate listeners
    pixiApp.stage.on('pointerup', () => {
        if (isDragging) {
            isDragging = false;
            console.log('🖱️ Model drag ended at:', { x: model.x, y: model.y });
            updateModelInfoDisplay(`✅ Model positioned at (${Math.round(model.x)}, ${Math.round(model.y)})`);
        }
    });
    
    // Handle mouse leave canvas
    pixiApp.stage.removeAllListeners('pointerupoutside'); // Prevent duplicate listeners
    pixiApp.stage.on('pointerupoutside', () => {
        if (isDragging) {
            isDragging = false;
            console.log('🖱️ Model drag ended (outside canvas)');
            updateModelInfoDisplay(`✅ Model positioned at (${Math.round(model.x)}, ${Math.round(model.y)})`);
        }
    });
    
    // Set up mouse wheel scaling (Live2D Viewer Web pattern)
    setupModelScaling(model);
    
    // Set up hit area testing if available
    setupModelHitAreas(model);
    
    console.log('✅ Mouse interaction setup complete for model');
}

// Live2D Viewer Web scaling pattern implementation
function setupModelScaling(model) {
    if (!pixiApp?.view) {
        console.warn('Cannot setup model scaling: no canvas available');
        return;
    }
    
    const canvas = pixiApp.view;
    
    // Remove any existing wheel listeners to prevent duplicates
    const existingHandler = canvas._live2dWheelHandler;
    if (existingHandler) {
        canvas.removeEventListener('wheel', existingHandler);
    }
    
    // Create wheel handler
    function handleModelWheel(event) {
        event.preventDefault();
        
        if (!model || !model.scale) return;
        
        const scaleFactor = event.deltaY > 0 ? 0.9 : 1.1;
        const newScale = model.scale.x * scaleFactor;
        
        // Limit scale between 0.1 and 5.0 (Live2D Viewer Web limits)
        if (newScale >= 0.1 && newScale <= 5.0) {
            model.scale.set(newScale);
            console.log('🔍 Model scaled to:', newScale.toFixed(2));
            
            // Update UI slider if available
            const slider = document.getElementById('zoomSlider');
            const display = document.getElementById('zoomValue');
            if (slider) slider.value = newScale;
            if (display) display.textContent = newScale.toFixed(2);
            
            // Update model info
            updateModelInfoDisplay(`Position: (${Math.round(model.x)}, ${Math.round(model.y)}) Scale: ${newScale.toFixed(2)}`);
        }
    }
    
    // Store handler reference for cleanup
    canvas._live2dWheelHandler = handleModelWheel;
    
    // Add wheel event listener
    canvas.addEventListener('wheel', handleModelWheel, { passive: false });
    
    console.log('🔍 Mouse wheel scaling set up for model');
}

// Live2D Viewer Web hit area pattern implementation
function setupModelHitAreas(model) {
    if (!model?.internalModel) {
        console.log('Hit areas not available for this model');
        return;
    }
    
    model.removeAllListeners('pointerdown'); // Remove previous listeners
    model.on('pointerdown', (event) => {
        const point = event.data.global;
        
        // Convert global coordinates to model local coordinates
        const localPoint = model.toLocal(point);
        
        console.log('🎯 Hit test at:', localPoint);
        
        // Test hit areas if available (Live2D Viewer Web pattern)
        if (model.internalModel.hitTest) {
            try {
                const hitAreas = model.internalModel.hitTest(localPoint.x, localPoint.y);
                
                if (hitAreas && hitAreas.length > 0) {
                    console.log('🎯 Hit areas detected:', hitAreas);
                    updateModelInfoDisplay(`🎯 Hit: ${hitAreas.join(', ')}`);
                    
                    // Trigger motions based on hit areas
                    hitAreas.forEach(hitArea => {
                        console.log(`🎭 Hit area: ${hitArea}`);
                        // Add motion triggers here if needed
                    });
                } else {
                    console.log('🎯 No hit areas at this location');
                }
            } catch (error) {
                console.warn('Hit test failed:', error);
            }
        } else {
            console.log('🎯 Hit testing not available for this model');
        }
    });
}

// Enhanced model loading function with mouse interaction
async function loadLive2DModel(modelPath) {
    try {
        console.log('🎭 Loading Live2D model from:', modelPath);
        
        if (!pixiApp) {
            throw new Error('PIXI application not available');
        }
        
        updateModelInfoDisplay('Loading model...');
        
        // Clear existing model
        if (currentModel) {
            pixiApp.stage.removeChild(currentModel);
            currentModel.destroy();
            currentModel = null;
        }
        
        // Load new model using Live2D Viewer Web pattern
        currentModel = await Live2DModel.from(modelPath);
        
        if (!currentModel) {
            throw new Error('Failed to create Live2D model');
        }
        
        // Add to stage
        pixiApp.stage.addChild(currentModel);
        
        // Center the model
        currentModel.x = pixiApp.screen.width / 2;
        currentModel.y = pixiApp.screen.height / 2;
        
        // Set initial scale
        currentModel.scale.set(0.3);
        
        // CRITICAL: Enable mouse interactions using Live2D Viewer Web patterns
        setupLive2DMouseInteraction(currentModel);
        
        // Store globally
        window.currentModel = currentModel;
        
        console.log('✅ Model loaded successfully with mouse interaction:', currentModel);
        
        // Update model info display
        const modelName = currentModel.internalModel?.settings?.name || 'Unknown Model';
        updateModelInfoDisplay(`✅ ${modelName} loaded - drag to move, scroll to scale`);
        
        return currentModel;
        
    } catch (error) {
        console.error('❌ Error loading model:', error);
        updateModelInfoDisplay(`❌ Failed to load model: ${error.message}`);
        throw error;
    }
}

// Helper function to update model info display (disabled)
function updateModelInfoDisplay(message) {
    // Overlay display disabled - function is now a no-op
}

// Global drag state variables (make accessible across all functions)
window.dragState = {
    isDragging: false,
    dragStart: null,
    modelStart: null,
    activeModel: null,
    moveCount: 0,
    pointerId: undefined
};

// Integrated PIXI interaction system fix
function fixPixiInteractionSystem() {
    const pixiApp = window.live2dIntegration?.core?.app || window.pixiApp;
    if (!pixiApp) {
        console.error('❌ No PIXI app found for interaction fix');
        return;
    }
    
    console.log('🔧 Applying PIXI interaction system fix...');
    
    // Step 1: Destroy any corrupted interaction manager
    const interaction = pixiApp.renderer.plugins?.interaction;
    if (interaction) {
        try {
            // Clear corrupted event data
            if (interaction.eventData) {
                Object.keys(interaction.eventData).forEach(key => {
                    delete interaction.eventData[key];
                });
            }
            
            // Remove DOM listeners and destroy
            if (interaction.removeEvents) interaction.removeEvents();
            if (interaction.destroy) interaction.destroy();
            delete pixiApp.renderer.plugins.interaction;
            
            console.log('✅ Old interaction manager cleaned up');
        } catch (error) {
            console.log('⚠️ Error cleaning old interaction:', error.message);
        }
    }
    
    // Step 2: Create new interaction manager or manual fallback
    try {
        let newInteraction = null;
        
        if (PIXI.InteractionManager) {
            newInteraction = new PIXI.InteractionManager(pixiApp.renderer);
        } else if (PIXI.interaction?.InteractionManager) {
            newInteraction = new PIXI.interaction.InteractionManager(pixiApp.renderer);
        }
        
        if (newInteraction) {
            pixiApp.renderer.plugins.interaction = newInteraction;
            newInteraction.interactionDOMElement = pixiApp.view;
            console.log('✅ New PIXI interaction manager created');
        }
    } catch (error) {
        console.log('⚠️ PIXI interaction manager creation failed:', error.message);
    }
    
    // Step 3: Set up manual DOM event bridge with complete drag system
    const canvas = pixiApp.view;
    
    // CRITICAL: Remove existing manual handlers
    if (canvas._fixedPointerHandler) {
        canvas.removeEventListener('mousedown', canvas._fixedPointerHandler);
        canvas.removeEventListener('pointerdown', canvas._fixedPointerHandler);
        document.removeEventListener('mousemove', canvas._fixedMoveHandler);
        document.removeEventListener('mouseup', canvas._fixedUpHandler);
        document.removeEventListener('pointerup', canvas._fixedUpHandler);
    }
    
    // CRITICAL: Disable all existing Live2D interaction systems that might interfere
    console.log('🔧 DISABLING existing Live2D interaction systems...');
    
    // Disable PIXI stage interaction to prevent conflicts
    pixiApp.stage.interactive = false;
    pixiApp.stage.eventMode = 'passive';
    
    // Find any active models and disable their interaction systems
    const activeModel = window.live2dMultiModelManager?.getActiveModel();
    if (activeModel?.pixiModel) {
        console.log('🔧 Disabling interaction on active model:', activeModel.name);
        activeModel.pixiModel.interactive = false;
        activeModel.pixiModel.eventMode = 'passive';
        activeModel.pixiModel.removeAllListeners();
    }
    
    // Create comprehensive event handlers for full drag system
    canvas._fixedPointerHandler = function(event) {
        // Convert to canvas coordinates
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        // Test model hit and start drag
        const model = window.live2dMultiModelManager?.getActiveModel();
        if (model?.pixiModel) {
            const pixiModel = model.pixiModel;
            const bounds = pixiModel.getBounds();
            
            console.log('🔍 Hit test debug:', {
                canvasClick: { x: x, y: y },
                modelBounds: { 
                    x: bounds.x, 
                    y: bounds.y, 
                    width: bounds.width, 
                    height: bounds.height 
                },
                modelPosition: { x: pixiModel.x, y: pixiModel.y },
                modelName: model.name,
                withinBounds: x >= bounds.x && x <= bounds.x + bounds.width && 
                             y >= bounds.y && y <= bounds.y + bounds.height
            });
            
            // Check if click is within model bounds
            if (x >= bounds.x && x <= bounds.x + bounds.width && 
                y >= bounds.y && y <= bounds.y + bounds.height) {
                
                // Start drag operation using global state
                window.dragState.isDragging = true;
                window.dragState.dragStart = { x: event.clientX, y: event.clientY };
                window.dragState.modelStart = { x: pixiModel.x, y: pixiModel.y };
                window.dragState.activeModel = pixiModel;
                window.dragState.moveCount = 0; // Reset move counter for new drag
                
                // Visual feedback
                pixiModel.alpha = 0.8;
                
                console.log('🖱️ Drag started:', {
                    startPos: window.dragState.dragStart,
                    modelStart: window.dragState.modelStart,
                    modelName: model.name,
                    activeModelSet: !!window.dragState.activeModel,
                    pixiModelType: typeof pixiModel
                });
                
                // Test immediate mousemove detection with MULTIPLE elements and capture phases
                console.log('🧪 TESTING mousemove on multiple elements and capture phases...');
                
                const testMoveHandler = function(e) {
                    if (window.dragState.isDragging) {
                        console.log('✅ IMMEDIATE MOUSEMOVE TEST WORKS:', { 
                            x: e.clientX, 
                            y: e.clientY,
                            target: e.target.tagName,
                            phase: 'document'
                        });
                        // Don't remove immediately, let's see how many fire
                    }
                };
                
                const testBodyMoveHandler = function(e) {
                    if (window.dragState.isDragging) {
                        console.log('✅ BODY MOUSEMOVE TEST WORKS:', { 
                            x: e.clientX, 
                            y: e.clientY,
                            target: e.target.tagName,
                            phase: 'body'
                        });
                    }
                };
                
                const testWindowMoveHandler = function(e) {
                    if (window.dragState.isDragging) {
                        console.log('✅ WINDOW MOUSEMOVE TEST WORKS:', { 
                            x: e.clientX, 
                            y: e.clientY,
                            target: e.target.tagName,
                            phase: 'window'
                        });
                    }
                };
                
                // Add listeners with both capture and bubble phases
                document.addEventListener('mousemove', testMoveHandler, { passive: false, capture: true });
                document.addEventListener('mousemove', testMoveHandler, { passive: false, capture: false });
                document.body.addEventListener('mousemove', testBodyMoveHandler, { passive: false, capture: true });
                document.body.addEventListener('mousemove', testBodyMoveHandler, { passive: false, capture: false });
                window.addEventListener('mousemove', testWindowMoveHandler, { passive: false });
                
                console.log('🧪 Multiple mousemove test handlers added - will test ALL phases');
                
                // CRITICAL: Store pointerId for potential cleanup, but don't capture
                window.dragState.pointerId = event.pointerId;
                
                // CRITICAL DEBUG: Test if preventDefault is blocking events
                console.log('� CRITICAL DEBUG - Event details:', {
                    eventType: event.type,
                    pointerId: event.pointerId,
                    clientX: event.clientX,
                    clientY: event.clientY,
                    defaultPrevented: event.defaultPrevented,
                    cancelable: event.cancelable,
                    bubbles: event.bubbles,
                    target: event.target.tagName,
                    currentTarget: event.currentTarget.tagName
                });
                
                // CRITICAL: DO NOT PREVENT DEFAULT - this might be blocking mousemove
                console.log('🚫 NOT calling preventDefault() to test if this was blocking mousemove');
                // event.preventDefault(); // COMMENTED OUT
                // event.stopPropagation(); // COMMENTED OUT
                
                console.log('🚫 Pointer capture DISABLED to allow mousemove events');
            } else {
                console.log('🚫 Click outside model bounds');
            }
        } else {
            console.log('🚫 No active model or pixiModel found');
        }
    };
    
    // Mouse move handler for dragging - with enhanced diagnostics
    canvas._fixedMoveHandler = function(event) {
        // CRITICAL: Always log mousemove events during drag to diagnose the issue
        if (window.dragState.isDragging) {
            console.log('🔍 MOUSEMOVE EVENT RECEIVED during drag:', {
                eventType: event.type,
                clientX: event.clientX,
                clientY: event.clientY,
                hasActiveModel: !!window.dragState.activeModel,
                hasDragStart: !!window.dragState.dragStart,
                hasModelStart: !!window.dragState.modelStart
            });
        }
        
        // ONLY process if we have all required state
        if (!window.dragState.isDragging || !window.dragState.activeModel || !window.dragState.dragStart || !window.dragState.modelStart) {
            // Log why we're not processing (only during drag)
            if (window.dragState.isDragging) {
                console.log('� Cannot process mousemove - missing state:', {
                    isDragging: window.dragState.isDragging,
                    hasActiveModel: !!window.dragState.activeModel,
                    hasDragStart: !!window.dragState.dragStart,
                    hasModelStart: !!window.dragState.modelStart
                });
            }
            return;
        }
        
        // Calculate movement delta from original drag start position
        const deltaX = event.clientX - window.dragState.dragStart.x;
        const deltaY = event.clientY - window.dragState.dragStart.y;
        
        // Update model position in real-time
        const newX = window.dragState.modelStart.x + deltaX;
        const newY = window.dragState.modelStart.y + deltaY;
        
        window.dragState.activeModel.x = newX;
        window.dragState.activeModel.y = newY;
        
        // Increment and log move counter
        if (!window.dragState.moveCount) window.dragState.moveCount = 0;
        window.dragState.moveCount++;
        
        // Log every 10th mousemove to reduce spam but show it's working
        if (window.dragState.moveCount % 10 === 1) {
            console.log('🖱️ REAL-TIME DRAG:', {
                mousePos: { x: event.clientX, y: event.clientY },
                delta: { x: Math.round(deltaX), y: Math.round(deltaY) },
                modelPos: { x: Math.round(newX), y: Math.round(newY) },
                moveCount: window.dragState.moveCount
            });
        }
        
        event.preventDefault();
    };
    
    // Mouse up handler to end drag
    canvas._fixedUpHandler = function(event) {
        console.log('🔼 Mouse up event received:', { 
            type: event.type, 
            isDragging: window.dragState.isDragging, 
            hasActiveModel: !!window.dragState.activeModel 
        });
        
        if (window.dragState.isDragging && window.dragState.activeModel) {
            // End drag operation
            window.dragState.isDragging = false;
            window.dragState.activeModel.alpha = 1.0; // Restore opacity
            
            console.log('✅ Drag ended at position:', { 
                x: Math.round(window.dragState.activeModel.x), 
                y: Math.round(window.dragState.activeModel.y),
                totalMoves: window.dragState.moveCount || 0
            });
            
            // Release pointer capture if it was set
            if (canvas.releasePointerCapture && window.dragState.pointerId !== undefined) {
                try {
                    canvas.releasePointerCapture(window.dragState.pointerId);
                    console.log('✅ Released pointer capture for pointerId:', window.dragState.pointerId);
                } catch (e) {
                    console.log('⚠️ Failed to release pointer capture:', e.message);
                }
            }
            
            // Reset state
            window.dragState.dragStart = null;
            window.dragState.modelStart = null;
            window.dragState.activeModel = null;
            window.dragState.moveCount = 0;
            window.dragState.pointerId = undefined;
            
            event.preventDefault();
            event.stopPropagation();
        } else {
            console.log('🔼 Mouse up but not dragging or no active model');
        }
    };
    
    // Store handlers on canvas for cleanup (no need to reassign)
    // canvas._fixedMoveHandler and canvas._fixedUpHandler are already defined above
    
    // Remove any existing event listeners first to prevent duplicates
    canvas.removeEventListener('mousedown', canvas._fixedPointerHandler);
    canvas.removeEventListener('pointerdown', canvas._fixedPointerHandler);
    canvas.removeEventListener('mousemove', canvas._fixedMoveHandler);
    document.removeEventListener('mousemove', canvas._fixedMoveHandler);
    document.removeEventListener('mouseup', canvas._fixedUpHandler);
    document.removeEventListener('pointerup', canvas._fixedUpHandler);
    
    console.log('🔧 CRITICAL: Adding fresh event listeners...');
    
    // Add all event listeners (both mouse and pointer events)
    canvas.addEventListener('mousedown', canvas._fixedPointerHandler, { passive: false });
    canvas.addEventListener('pointerdown', canvas._fixedPointerHandler, { passive: false });
    
    // CRITICAL: REMOVE canvas mousemove to test if it's conflicting with document mousemove
    console.log('🧪 TESTING: Removing canvas mousemove listeners to prevent conflicts');
    // canvas.addEventListener('mousemove', canvas._fixedMoveHandler, { passive: false }); // REMOVED
    document.addEventListener('mousemove', canvas._fixedMoveHandler, { passive: false });
    
    document.addEventListener('mouseup', canvas._fixedUpHandler, { passive: false });
    document.addEventListener('pointerup', canvas._fixedUpHandler, { passive: false });
    
    console.log('✅ Event listeners added:', {
        canvasDown: 'mousedown + pointerdown',
        canvasMove: 'REMOVED - testing conflict',
        documentMove: 'mousemove', 
        documentUp: 'mouseup + pointerup'
    });
    
    // CRITICAL DIAGNOSTIC: Add global mousemove detector to test if ANY mousemove events fire
    let globalMoveCount = 0;
    document.addEventListener('mousemove', function(event) {
        if (window.dragState.isDragging) {
            globalMoveCount++;
            if (globalMoveCount <= 5) { // Only log first 5 to avoid spam
                console.log(`🌍 GLOBAL MOUSEMOVE ${globalMoveCount}:`, {
                    target: event.target.tagName,
                    clientX: event.clientX,
                    clientY: event.clientY,
                    isDragging: window.dragState.isDragging
                });
            }
        }
    }, { passive: false });
    
    console.log('🔍 Global mousemove detector added for diagnostics');
    
    // CRITICAL TEST: Add mousemove listeners to multiple elements to test event propagation
    console.log('🧪 Adding mousemove test listeners to multiple elements...');
    
    // Test on body
    document.body.addEventListener('mousemove', function(event) {
        if (window.dragState.isDragging && globalMoveCount <= 3) {
            console.log('🟢 BODY MOUSEMOVE:', { target: event.target.tagName, x: event.clientX, y: event.clientY });
        }
    }, { passive: false });
    
    // Test on document.documentElement (html)
    document.documentElement.addEventListener('mousemove', function(event) {
        if (window.dragState.isDragging && globalMoveCount <= 3) {
            console.log('🟠 HTML MOUSEMOVE:', { target: event.target.tagName, x: event.clientX, y: event.clientY });
        }
    }, { passive: false });
    
    // Test on window
    window.addEventListener('mousemove', function(event) {
        if (window.dragState.isDragging && globalMoveCount <= 3) {
            console.log('🔴 WINDOW MOUSEMOVE:', { target: event.target.tagName, x: event.clientX, y: event.clientY });
        }
    }, { passive: false });
    
    console.log('🧪 Multi-level mousemove test listeners added');
    
    // Configure canvas for optimal interaction
    canvas.style.touchAction = 'none';
    canvas.style.pointerEvents = 'auto';
    
    // CRITICAL: Force all CSS properties that might block mousemove events
    canvas.style.userSelect = 'none';
    canvas.style.webkitUserSelect = 'none';
    canvas.style.msUserSelect = 'none';
    canvas.style.mozUserSelect = 'none';
    canvas.style.webkitUserDrag = 'none';
    canvas.style.webkitTouchCallout = 'none';
    canvas.style.webkitTapHighlightColor = 'transparent';
    
    // CRITICAL: Force enable all mouse event types on canvas
    canvas.style.pointerEvents = 'auto';
    canvas.setAttribute('onmousemove', ''); // Force enable mousemove attribute
    
    // CRITICAL: Check for competing event handlers (DevTools only function removed)
    console.log('🔍 Event handler check complete (getEventListeners requires DevTools)');
    
    // CRITICAL: Keep stage interaction DISABLED to prevent conflicts with manual DOM handlers
    pixiApp.stage.interactive = false;
    pixiApp.stage.eventMode = 'passive';
    // Do NOT set hitArea to prevent stage from capturing events
    
    console.log('✅ PIXI interaction system fix applied successfully - manual DOM only');
}

// Add basic PIXI event diagnostics
function debugPixiEvents() {
    console.log('🔍 === TESTING BASIC PIXI EVENTS ===');
    
    // Debug: let's see what's actually available
    console.log('🔍 Debugging PIXI app location...');
    console.log('live2dIntegration object:', window.live2dIntegration);
    if (window.live2dIntegration) {
        console.log('live2dIntegration keys:', Object.keys(window.live2dIntegration));
        console.log('live2dIntegration.core:', window.live2dIntegration.core);
        if (window.live2dIntegration.core) {
            console.log('core keys:', Object.keys(window.live2dIntegration.core));
            console.log('core.app:', window.live2dIntegration.core.app);
        }
    }
    
    // Test if we can access the PIXI app - try multiple locations
    let pixiApp = null;
    
    // Try integration.core.app (likely correct location)
    if (window.live2dIntegration?.core?.app) {
        pixiApp = window.live2dIntegration.core.app;
        console.log('✅ Found PIXI app via live2dIntegration.core.app');
    }
    // Try integration.app 
    else if (window.live2dIntegration?.app) {
        pixiApp = window.live2dIntegration.app;
        console.log('✅ Found PIXI app via live2dIntegration.app');
    }
    // Try global pixiApp
    else if (window.pixiApp) {
        pixiApp = window.pixiApp;
        console.log('✅ Found PIXI app via window.pixiApp');
    }
    // Try integration.pixiApp (fallback)
    else if (window.live2dIntegration?.pixiApp) {
        pixiApp = window.live2dIntegration.pixiApp;
        console.log('✅ Found PIXI app via live2dIntegration.pixiApp');
    }
    
    if (!pixiApp) {
        console.error('❌ No PIXI app found in any location');
        console.log('Debug info:', {
            'live2dIntegration': !!window.live2dIntegration,
            'live2dIntegration.app': !!window.live2dIntegration?.app,
            'live2dIntegration.core': !!window.live2dIntegration?.core,
            'live2dIntegration.core.app': !!window.live2dIntegration?.core?.app,
            'live2dIntegration.pixiApp': !!window.live2dIntegration?.pixiApp,
            'window.pixiApp': !!window.pixiApp
        });
        return;
    }
    
    console.log('✅ PIXI app found:', pixiApp);
    console.log('📱 PIXI stage:', pixiApp.stage);
    
    // CRITICAL: Ensure this PIXI app is also set globally for other functions
    window.pixiApp = pixiApp;
    
    // Test stage events
    console.log('🧪 Adding stage event listeners...');
    
    // CRITICAL FIX: Force enable ALL interaction settings
    pixiApp.stage.interactive = true;
    pixiApp.stage.eventMode = 'static';
    pixiApp.stage.hitArea = pixiApp.screen;
    
    // ADDITIONAL FIX: Force enable interaction manager
    const interaction = pixiApp.renderer.plugins?.interaction;
    if (interaction) {
        console.log('🔧 Force configuring interaction manager...');
        interaction.interactionDOMElement = pixiApp.view;
        if (interaction.setTargetElement) {
            interaction.setTargetElement(pixiApp.view);
        }
        console.log('✅ Interaction manager configured');
    }
    
    const stageDownHandler = (event) => {
        console.log('🎯 STAGE POINTER DOWN:', {
            x: event.global.x,
            y: event.global.y,
            target: event.target.constructor.name,
            type: event.type
        });
    };
    
    const stageUpHandler = (event) => {
        console.log('🎯 STAGE POINTER UP:', {
            x: event.global.x,
            y: event.global.y,
            target: event.target.constructor.name,
            type: event.type
        });
    };
    
    // Remove any existing listeners first
    pixiApp.stage.off('pointerdown', stageDownHandler);
    pixiApp.stage.off('pointerup', stageUpHandler);
    
    // Add new listeners
    pixiApp.stage.on('pointerdown', stageDownHandler);
    pixiApp.stage.on('pointerup', stageUpHandler);
    
    console.log('✅ Stage event listeners added. Try clicking anywhere on the canvas.');
    console.log('📋 Expected: You should see STAGE POINTER events in console');
}

// Also add a canvas-level test
function debugCanvasEvents() {
    console.log('🔍 === TESTING CANVAS EVENTS ===');
    
    const canvas = document.querySelector('canvas');
    if (!canvas) {
        console.error('❌ No canvas found');
        return;
    }
    
    console.log('✅ Canvas found:', canvas);
    
    const canvasHandler = (event) => {
        console.log('🎯 CANVAS EVENT:', {
            type: event.type,
            x: event.clientX,
            y: event.clientY,
            target: event.target.tagName
        });
    };
    
    // Remove existing listeners
    canvas.removeEventListener('mousedown', canvasHandler);
    canvas.removeEventListener('mouseup', canvasHandler);
    
    // Add new listeners
    canvas.addEventListener('mousedown', canvasHandler);
    canvas.addEventListener('mouseup', canvasHandler);
    
    console.log('✅ Canvas event listeners added. Try clicking on the canvas.');
    console.log('📋 Expected: You should see CANVAS EVENT logs');
}

// Run all diagnostic tests in sequence
function runAllEventTests() {
    console.log('🚀 === RUNNING ALL EVENT DIAGNOSTICS ===');
    console.log('Testing event system from bottom to top...');
    
    // Test 1: Canvas-level DOM events
    debugCanvasEvents();
    
    // Test 2: PIXI stage events  
    debugPixiEvents();
    
    // Test 3: PIXI Interaction Manager test
    debugPixiInteractionManager();
    
    // Test 4: Model-specific events
    debugModelClickTest();
    
    console.log('🏁 All tests setup complete! Try clicking on:');
    console.log('1️⃣ Anywhere on canvas (should see CANVAS EVENT)');
    console.log('2️⃣ Empty area on stage (should see STAGE POINTER)');
    console.log('3️⃣ Directly on model (should see model move + CLICK details)');
    console.log('📋 Check console for which events fire to identify the issue');
}

// New diagnostic function to test PIXI's interaction manager
function debugPixiInteractionManager() {
    console.log('🔍 === TESTING PIXI INTERACTION MANAGER ===');
    
    const pixiApp = window.live2dIntegration?.core?.app || window.pixiApp;
    if (!pixiApp) {
        console.error('❌ No PIXI app found for interaction manager test');
        return;
    }
    
    console.log('🔍 PIXI app renderer:', pixiApp.renderer);
    console.log('🔍 PIXI app view (canvas):', pixiApp.view);
    
    // Check if interaction manager exists
    const interaction = pixiApp.renderer.plugins?.interaction;
    console.log('🔍 PIXI interaction manager:', interaction);
    
    if (interaction) {
        console.log('✅ PIXI interaction manager found');
        console.log('🔍 Interaction manager details:', {
            eventData: !!interaction.eventData,
            interactionDOMElement: !!interaction.interactionDOMElement,
            resolution: interaction.resolution,
            autoPreventDefault: interaction.autoPreventDefault
        });
        
        // CRITICAL FIX: Force enable interaction manager
        console.log('🔧 Force enabling PIXI interaction manager...');
        
        // Set the interaction DOM element to the canvas
        interaction.interactionDOMElement = pixiApp.view;
        
        // Enable stage interaction with comprehensive settings
        pixiApp.stage.interactive = true;
        pixiApp.stage.eventMode = 'static';
        pixiApp.stage.hitArea = pixiApp.screen;
        
        // Force the interaction manager to recognize the stage
        if (interaction.setTargetElement) {
            interaction.setTargetElement(pixiApp.view);
        }
        
        // Check if the interaction manager is processing events
        const originalOnPointerDown = interaction.onPointerDown;
        interaction.onPointerDown = function(event) {
            console.log('🎯 PIXI INTERACTION MANAGER - PointerDown received!', event);
            updateModelInfoDisplay(`🎯 PIXI Interaction Manager detected mouse down!\nInteraction system is working at PIXI level`);
            if (originalOnPointerDown) {
                return originalOnPointerDown.call(this, event);
            }
        };
        
        console.log('✅ PIXI interaction manager test hook installed');
        console.log('🔧 Stage interaction forced enabled:', {
            stageInteractive: pixiApp.stage.interactive,
            stageEventMode: pixiApp.stage.eventMode,
            hasHitArea: !!pixiApp.stage.hitArea,
            interactionDOMElement: !!interaction.interactionDOMElement
        });
    } else {
        console.error('❌ PIXI interaction manager not found');
        console.log('Available renderer plugins:', Object.keys(pixiApp.renderer.plugins || {}));
    }
}

function debugModelInteraction() {
    console.log('🔍 === TESTING MODEL MOUSE EVENTS ===');
    
    const activeModel = live2dMultiModelManager?.getActiveModel();
    if (!activeModel?.pixiModel) {
        console.error('❌ No active model with pixiModel');
        updateModelInfoDisplay('❌ No active model found');
        return;
    }
    
    const model = activeModel.pixiModel;
    console.log('🎯 Testing model:', activeModel.name);
    
    // Log current model state
    console.log('Model state:', {
        interactive: model.interactive,
        eventMode: model.eventMode,
        buttonMode: model.buttonMode,
        cursor: model.cursor,
        visible: model.visible,
        worldVisible: model.worldVisible,
        alpha: model.alpha,
        position: { x: model.x, y: model.y },
        scale: { x: model.scale.x, y: model.scale.y },
        bounds: model.getBounds()
    });
    
    // Remove existing test listeners
    model.removeAllListeners('pointerdown');
    model.removeAllListeners('pointermove');
    model.removeAllListeners('pointerup');
    
    // Add test event listeners (NO MOVE EVENTS)
    console.log('🧪 Adding test event listeners (NO MOVE EVENTS)...');
    
    model.on('pointerdown', (event) => {
        console.log('🎉 MODEL POINTERDOWN EVENT RECEIVED!', {
            x: event.data.global.x,
            y: event.data.global.y,
            button: event.data.button,
            pointerId: event.data.pointerId,
            target: event.target.constructor.name,
            currentTarget: event.currentTarget.constructor.name
        });
        updateModelInfoDisplay(`🎉 MOUSE DOWN detected!\nPosition: (${Math.round(event.data.global.x)}, ${Math.round(event.data.global.y)})\nTarget: ${event.target.constructor.name}\nModel is receiving events!`);
    });
    
    model.on('pointerup', (event) => {
        console.log('� MODEL POINTERUP EVENT RECEIVED!', {
            x: event.data.global.x,
            y: event.data.global.y,
            target: event.target.constructor.name
        });
        updateModelInfoDisplay(`🔼 MOUSE UP detected!\nModel interaction working!`);
    });
    
    // Force enable interaction
    model.interactive = true;
    model.eventMode = 'static';
    model.buttonMode = true;
    model.cursor = 'pointer';
    
    console.log('✅ Test event listeners added (NO MOVE EVENTS). Try clicking on the model!');
    updateModelInfoDisplay('🧪 Test listeners added (NO MOVE EVENTS)\nTry clicking the model\nCheck console for event logs');
}

function debugModelSystem() {
    console.log('🔍 === MODEL SYSTEM DEBUG ===');
    
    // Check global variables
    console.log('Global variables:', {
        live2dIntegration: !!window.live2dIntegration,
        live2dMultiModelManager: !!window.live2dMultiModelManager,
        uiController: !!window.uiController,
        pixiApp: !!window.pixiApp,
        currentModel: !!window.currentModel
    });
    
    // Check multi-model manager
    if (live2dMultiModelManager) {
        const allModels = live2dMultiModelManager.getAllModels();
        const activeModel = live2dMultiModelManager.getActiveModel();
        
        console.log('Multi-model manager:', {
            totalModels: allModels.length,
            hasActiveModel: !!activeModel,
            activeModelName: activeModel ? activeModel.name : 'none'
        });
        
        console.log('All models:', allModels.map(m => ({
            name: m.name,
            hasModel: !!m.model,
            visible: m.model ? m.model.visible : false,
            interactive: m.model ? m.model.interactive : false
        })));
    }
    
    // Check PIXI app
    if (pixiApp) {
        console.log('PIXI app:', {
            hasStage: !!pixiApp.stage,
            hasView: !!pixiApp.view,
            stageChildren: pixiApp.stage ? pixiApp.stage.children.length : 0,
            stageInteractive: pixiApp.stage ? pixiApp.stage.interactive : false
        });
    }
    
    console.log('=== END DEBUG ===');
    
    // Update display with debug info
    let debugInfo = 'System Debug:\n';
    debugInfo += `Manager: ${!!live2dMultiModelManager}\n`;
    debugInfo += `PIXI App: ${!!pixiApp}\n`;
    debugInfo += `Current Model: ${!!currentModel}\n`;
    
    if (live2dMultiModelManager) {
        const allModels = live2dMultiModelManager.getAllModels();
        debugInfo += `Total Models: ${allModels.length}`;
    }
    
    updateModelInfoDisplay(debugInfo);
}

// Override onModelChange to use new loading function
function onModelChange() {
    console.log('onModelChange called');
    const modelSelect = document.getElementById('modelSelect');
    const modelName = modelSelect?.value;
    
    if (!modelName) {
        console.log('No model selected');
        return;
    }
    
    // Try to load the model with mouse interaction
    const modelPath = `/static/live2d_models/${modelName}/${modelName}.model3.json`;
    loadLive2DModel(modelPath).catch(error => {
        console.error('Failed to load model:', error);
        updateModelInfoDisplay(`❌ Failed to load ${modelName}\nError: ${error.message}`);
    });
}

// People panel functionality - Update to use new loading function
function selectModelFromDialog(modelValue, modelName) {
    console.log('Selected model from dialog:', modelName, modelValue);
    
    // Close dialog first
    closeAddModelDialog();
    
    // Load the selected model with mouse interaction
    const modelPath = `/static/live2d_models/${modelValue}/${modelValue}.model3.json`;
    loadLive2DModel(modelPath).then(() => {
        console.log('Model loaded successfully from dialog:', modelName);
        
        // Update the model select dropdown
        const modelSelect = document.getElementById('modelSelect');
        if (modelSelect) {
            modelSelect.value = modelValue;
        }
        
        // Refresh people panel if using multi-model manager
        if (live2dMultiModelManager) {
            setTimeout(() => populatePeopleModels(), 100);
        }
    }).catch(error => {
        console.error('Failed to load model from dialog:', error);
        updateModelInfoDisplay(`❌ Failed to load ${modelName}\nError: ${error.message}`);
    });
}

// ...existing code...
</script>

<script>
// Global state variables for UI panels
let chatOpen = false;
let peopleOpen = false;
let settingsOpen = false;
let chatSnapped = false;
let peopleSnapped = false;
let settingsSnapped = false;

// Layout management constants
const LAYOUT_STORAGE_KEY = 'live2d_panel_layout';

// Dragging state variables
let isDragging = false;
let currentDragElement = null;
let dragOffset = { x: 0, y: 0 };

// Helper functions for layout management
function getElementPosition(elementId) {
    const element = document.getElementById(elementId);
    if (!element) return { x: 0, y: 0 };
    
    // Get computed style to check for transforms
    const computedStyle = window.getComputedStyle(element);
    const rect = element.getBoundingClientRect();
    
    // If element has been positioned manually, use the style values
    if (element.style.left && element.style.left !== '') {
        const left = parseInt(element.style.left.replace('px', ''));
        const top = parseInt(element.style.top ? element.style.top.replace('px', '') : '0');
        return { x: left, y: top };
    }
    
    // Otherwise use bounding rect, but account for potential issues
    return {
        x: Math.max(0, rect.left),
        y: Math.max(0, rect.top)
    };
}

function getElementSize(elementId) {
    const element = document.getElementById(elementId);
    if (!element) return { width: 0, height: 0 };
    
    return {
        width: element.offsetWidth,
        height: element.offsetHeight
    };
}

function applyElementLayout(element, layout) {
    // CRITICAL FIX: Reset all positioning properties to prevent cumulative drift
    element.style.left = '';
    element.style.right = '';
    element.style.top = '';
    element.style.bottom = '';
    element.style.transform = '';
    element.style.position = 'fixed';
    
    if (layout.position) {
        // Apply position with absolute values only
        if (typeof layout.position.x === 'string') {
            if (layout.position.x === 'center') {
                element.style.left = '50%';
                element.style.transform = 'translateX(-50%)';
            } else if (layout.position.x.includes('left-')) {
                element.style.left = layout.position.x.replace('left-', '') + 'px';
            } else if (layout.position.x.includes('right-')) {
                element.style.right = layout.position.x.replace('right-', '') + 'px';
            }
        } else {
            // Always use absolute pixel positioning to prevent drift
            element.style.left = Math.max(0, layout.position.x) + 'px';
        }
        
        if (typeof layout.position.y === 'string') {
            if (layout.position.y.includes('top-')) {
                element.style.top = layout.position.y.replace('top-', '') + 'px';
            } else if (layout.position.y.includes('bottom-')) {
                element.style.bottom = layout.position.y.replace('bottom-', '') + 'px';
            }
        } else {
            // Always use absolute pixel positioning to prevent drift
            element.style.top = Math.max(0, layout.position.y) + 'px';
        }
    }
    
    if (layout.size) {
        // Apply size
        if (layout.size.width !== 'auto') {
            element.style.width = layout.size.width + 'px';
        }
        if (layout.size.height !== 'auto') {
            element.style.height = layout.size.height + 'px';
        }
    }
}

function getChatSnapPosition() {
    const chatWindow = document.getElementById('chatWindow');
    if (chatWindow.classList.contains('snapped-left')) return 'left';
    if (chatWindow.classList.contains('snapped-right')) return 'right';
    if (chatWindow.classList.contains('snapped-bottom')) return 'bottom';
    return 'bottom';
}

function getPeopleSnapPosition() {
    const peoplePanel = document.getElementById('peoplePanel');
    if (peoplePanel.classList.contains('snapped-left')) return 'left';
    if (peoplePanel.classList.contains('snapped-right')) return 'right';
    return 'right';
}

function getSettingsSnapPosition() {
    const settingsPanel = document.getElementById('settingsPanel');
    if (settingsPanel.classList.contains('snapped-left')) return 'left';
    if (settingsPanel.classList.contains('snapped-right')) return 'right';
    return 'left';
}

// Clear saved layout (for debugging)
function clearSavedLayout() {
    localStorage.removeItem(LAYOUT_STORAGE_KEY);
    console.log('Saved layout cleared');
}

// Save window layout to localStorage
function saveWindowLayout() {
    try {
        const layout = {
            chat: {
                open: chatOpen,
                snapped: chatSnapped,
                position: getElementPosition('chatWindow'),
                size: getElementSize('chatWindow')
            },
            people: {
                open: peopleOpen,
                snapped: peopleSnapped,
                position: getElementPosition('peoplePanel'),
                size: getElementSize('peoplePanel')
            },
            settings: {
                open: settingsOpen,
                snapped: settingsSnapped,
                position: getElementPosition('settingsPanel'),
                size: getElementSize('settingsPanel')
            }
        };
        
        localStorage.setItem(LAYOUT_STORAGE_KEY, JSON.stringify(layout));
        console.log('Window layout saved');
    } catch (error) {
        console.warn('Failed to save layout:', error);
    }
}

// Load window layout from localStorage
function loadWindowLayout() {
    try {
        const layoutData = localStorage.getItem(LAYOUT_STORAGE_KEY);
        if (!layoutData) return;
        
        const layout = JSON.parse(layoutData);
        
        // Restore chat window
        if (layout.chat) {
            chatOpen = layout.chat.open;
            chatSnapped = layout.chat.snapped;
            const chatWindow = document.getElementById('chatWindow');
            if (chatWindow) {
                if (chatOpen) chatWindow.classList.add('open');
                if (layout.chat.position) applyElementLayout(chatWindow, layout.chat);
            }
        }
        
        // Restore people panel
        if (layout.people) {
            peopleOpen = layout.people.open;
            peopleSnapped = layout.people.snapped;
            const peoplePanel = document.getElementById('peoplePanel');
            if (peoplePanel) {
                if (peopleOpen) peoplePanel.classList.add('open');
                if (layout.people.position) applyElementLayout(peoplePanel, layout.people);
            }
        }
        
        // Restore settings panel
        if (layout.settings) {
            settingsOpen = layout.settings.open;
            settingsSnapped = layout.settings.snapped;
            const settingsPanel = document.getElementById('settingsPanel');
            if (settingsPanel) {
                if (settingsOpen) settingsPanel.classList.add('open');
                if (layout.settings.position) applyElementLayout(settingsPanel, layout.settings);
            }
        }
        
        updateNavIconStates();
        console.log('Window layout loaded');
    } catch (error) {
        console.warn('Failed to load layout:', error);
    }
}

// Reset window layout to defaults
function resetWindowLayout() {
    console.log('Resetting window layout to defaults...');
    
    // Reset state variables
    chatOpen = false;
    peopleOpen = false;
    settingsOpen = false;
    chatSnapped = false;
    peopleSnapped = false;
    settingsSnapped = false;
    
    // Reset chat window
    const chatWindow = document.getElementById('chatWindow');
    if (chatWindow) {
        chatWindow.classList.remove('open', 'pinned');
        chatWindow.style.cssText = ''; // Clear all inline styles
    }
    
    // Reset people panel
    const peoplePanel = document.getElementById('peoplePanel');
    if (peoplePanel) {
        peoplePanel.classList.remove('open', 'pinned');
        peoplePanel.style.cssText = ''; // Clear all inline styles
    }
    
    // Reset settings panel
    const settingsPanel = document.getElementById('settingsPanel');
    if (settingsPanel) {
        settingsPanel.classList.remove('open', 'pinned');
        settingsPanel.style.cssText = ''; // Clear all inline styles
    }
    
    updateNavIconStates();
    clearSavedLayout();
    console.log('Window layout reset complete');
}

// Add emergency reset functionality for off-screen windows
document.addEventListener('keydown', function(e) {
    // Ctrl+Shift+R to reset window layout
    if (e.ctrlKey && e.shiftKey && e.key === 'R') {
        e.preventDefault();
        console.log('Emergency layout reset triggered');
        resetWindowLayout();
    }
    
    // Ctrl+Shift+B to bring all windows back into view (rescue mode)
    if (e.ctrlKey && e.shiftKey && e.key === 'B') {
        e.preventDefault();
        console.log('Emergency rescue mode triggered');
        rescueOffScreenWindows();
    }
    
    // Escape key to close model selection dialog
    if (e.key === 'Escape') {
        const dialog = document.getElementById('modelSelectionDialog');
        if (dialog && dialog.style.display === 'flex') {
            closeAddModelDialog();
        }
    }
});

// Emergency function to bring off-screen windows back into view
function rescueOffScreenWindows() {
    console.log('Rescuing off-screen windows...');
    
    const windows = [
        { element: document.getElementById('chatWindow'), name: 'Chat' },
        { element: document.getElementById('peoplePanel'), name: 'People' },
        { element: document.getElementById('settingsPanel'), name: 'Settings' }
    ];
    
    windows.forEach(({ element, name }) => {
        if (!element) return;
        
        const rect = element.getBoundingClientRect();
        const isOffScreen = rect.left < 0 || rect.top < 0 || 
                           rect.right > window.innerWidth || 
                           rect.bottom > window.innerHeight;
        
        if (isOffScreen) {
            console.log(`Rescuing ${name} window from off-screen position`);
            
            // Reset positioning and place in safe area
            element.style.left = '';
            element.style.right = '';
            element.style.top = '';
            element.style.bottom = '';
            element.style.transform = '';
            element.style.position = 'fixed';
            
            // Place in center-ish safe area
            const safeX = Math.max(20, Math.min(window.innerWidth - 300, 100));
            const safeY = Math.max(20, Math.min(window.innerHeight - 200, 100));
            
            element.style.left = safeX + 'px';
            element.style.top = safeY + 'px';
            
            // Make sure it's visible
            element.classList.add('open');
            if (name === 'Chat') chatOpen = true;
            if (name === 'People') peopleOpen = true;
            if (name === 'Settings') settingsOpen = true;
        }
    });
    
    updateNavIconStates();
    saveWindowLayout(); // Save the rescued positions
    console.log('Window rescue complete');
}

// Navigation functions
function updateNavIconStates() {
    const navIcons = document.querySelectorAll('.nav-icon');
    navIcons.forEach(icon => {
        icon.classList.remove('active');
    });
    
    if (chatOpen) {
        const chatIcon = document.querySelector('.nav-icon[onclick="openChat()"]');
        if (chatIcon) chatIcon.classList.add('active');
    }
    
    if (peopleOpen) {
        const peopleIcon = document.querySelector('.nav-icon[onclick="openPeople()"]');
        if (peopleIcon) peopleIcon.classList.add('active');
    }
    
    if (settingsOpen) {
        const settingsIcon = document.querySelector('.nav-icon[onclick="openSettings()"]');
        if (settingsIcon) settingsIcon.classList.add('active');
    }
}

// Chat functions
function openChat() {
    // Toggle chat window
    chatOpen = !chatOpen;
    const chatWindow = document.getElementById('chatWindow');
    
    if (chatOpen) {
        chatWindow.classList.add('open');
    } else {
        chatWindow.classList.remove('open');
    }
    
    updateNavIconStates();
    saveWindowLayout(); // Save layout when window opens/closes
}

function showChat() {
    // Only open chat window, don't toggle
    if (!chatOpen) {
        chatOpen = true;
        const chatWindow = document.getElementById('chatWindow');
        chatWindow.classList.add('open');
        updateNavIconStates();
        saveWindowLayout();
    }
}

function closeChat() {
    chatOpen = false;
    const chatWindow = document.getElementById('chatWindow');
    chatWindow.classList.remove('open');
    updateNavIconStates();
    saveWindowLayout(); // Save layout when window closes
}

function toggleChatSnap() {
    const chatWindow = document.getElementById('chatWindow');
    const pinButton = chatWindow.querySelector('.control-btn[onclick="toggleChatSnap()"]');
    chatSnapped = !chatSnapped;
    
    if (chatSnapped) {
        // Pin the window in its current position instead of snapping to bottom
        chatWindow.style.position = 'fixed';
        chatWindow.style.transform = 'none'; // Remove any transform
        chatWindow.classList.add('pinned'); // Add visual indicator
        if (pinButton) pinButton.classList.add('pinned');
    } else {
        // Unpin the window
        chatWindow.style.position = 'fixed';
        chatWindow.classList.remove('pinned'); // Remove visual indicator
        if (pinButton) pinButton.classList.remove('pinned');
    }
    
    // Save layout when snap state changes
    saveWindowLayout();
}

// People functions
function openPeople() {
    // Toggle people panel
    peopleOpen = !peopleOpen;
    const peoplePanel = document.getElementById('peoplePanel');
    
    if (peopleOpen) {
        peoplePanel.classList.add('open');
        populatePeopleModels();
    } else {
        peoplePanel.classList.remove('open');
    }
    
    updateNavIconStates();
    saveWindowLayout(); // Save layout when window opens/closes
}

function showPeople() {
    // Only open people panel, don't toggle
    if (!peopleOpen) {
        peopleOpen = true;
        const peoplePanel = document.getElementById('peoplePanel');
        peoplePanel.classList.add('open');
        populatePeopleModels();
        updateNavIconStates();
        saveWindowLayout();
    }
}

function closePeople() {
    peopleOpen = false;
    const peoplePanel = document.getElementById('peoplePanel');
    peoplePanel.classList.remove('open');
    updateNavIconStates();
    saveWindowLayout(); // Save layout when window closes
}

function togglePeopleSnap() {
    const peoplePanel = document.getElementById('peoplePanel');
    const pinButton = peoplePanel.querySelector('.control-btn[onclick="togglePeopleSnap()"]');
    peopleSnapped = !peopleSnapped;
    
    if (peopleSnapped) {
        // Pin the window in its current position
        peoplePanel.style.position = 'fixed';
        peoplePanel.classList.add('pinned'); // Add visual indicator
        if (pinButton) pinButton.classList.add('pinned');
    } else {
        // Unpin the window
        peoplePanel.style.position = 'fixed';
        peoplePanel.classList.remove('pinned'); // Remove visual indicator
        if (pinButton) pinButton.classList.remove('pinned');
    }
    
    // Save layout when snap state changes
    saveWindowLayout();
}

// Settings functions
function openSettings() {
    // Toggle settings panel
    settingsOpen = !settingsOpen;
    const settingsPanel = document.getElementById('settingsPanel');
    
    if (settingsOpen) {
        settingsPanel.classList.add('open');
    } else {
        settingsPanel.classList.remove('open');
    }
    
    updateNavIconStates();
    saveWindowLayout(); // Save layout when window opens/closes
}

function showSettings() {
    // Only open settings panel, don't toggle
    if (!settingsOpen) {
        settingsOpen = true;
        const settingsPanel = document.getElementById('settingsPanel');
        settingsPanel.classList.add('open');
        updateNavIconStates();
        saveWindowLayout();
    }
}

function closeSettings() {
    settingsOpen = false;
    const settingsPanel = document.getElementById('settingsPanel');
    settingsPanel.classList.remove('open');
    updateNavIconStates();
    saveWindowLayout(); // Save layout when window closes
}

function toggleSettingsSnap() {
    const settingsPanel = document.getElementById('settingsPanel');
    const pinButton = settingsPanel.querySelector('.control-btn[onclick="toggleSettingsSnap()"]');
    settingsSnapped = !settingsSnapped;
    
    if (settingsSnapped) {
        // Pin the window in its current position
        settingsPanel.style.position = 'fixed';
        settingsPanel.classList.add('pinned'); // Add visual indicator
        if (pinButton) pinButton.classList.add('pinned');
    } else {
        // Unpin the window
        settingsPanel.style.position = 'fixed';
        settingsPanel.classList.remove('pinned'); // Remove visual indicator
        if (pinButton) pinButton.classList.remove('pinned');
    }
    
    // Save layout when snap state changes
    saveWindowLayout();
}

// Additional navigation functions
function toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
    }
}

function toggleHelp() {
    // Show help modal or tooltip
    console.log('Help functionality - to be implemented');
    // This could open a help panel or show keyboard shortcuts
}

// People panel functionality
function populatePeopleModels() {
    const modelsList = document.getElementById('peopleModelsList');
    
    // Clear existing models
    modelsList.innerHTML = '';
    
    // Get loaded models from multi-model manager
    if (!live2dMultiModelManager) {
        modelsList.innerHTML = '<div style="text-align: center; padding: 20px; color: #aaa;">No models loaded</div>';
        return;
    }
    
    const loadedModels = live2dMultiModelManager.getAllModels();
    
    if (loadedModels.length === 0) {
        modelsList.innerHTML = '<div style="text-align: center; padding: 20px; color: #aaa;">No models loaded</div>';
        return;
    }
    
    loadedModels.forEach(modelData => {
        const isActive = live2dMultiModelManager.activeModelId === modelData.id;
        
        const modelItem = document.createElement('div');
        modelItem.className = `people-model-item ${isActive ? 'active' : ''}`;
        modelItem.innerHTML = `
            <div class="people-model-avatar">${modelData.characterImage ? `<img src="${modelData.characterImage}" alt="${modelData.name}">` : '👤'}</div>
            <div class="people-model-info">
                <div class="people-model-name">${modelData.name}</div>
                <div class="people-model-status">${isActive ? 'Active' : 'Inactive'}</div>
            </div>
            <button class="people-model-remove" onclick="event.stopPropagation(); removeModel('${modelData.id}'); return false;">×</button>
        `;
        
        // Add click handler for model selection
        modelItem.addEventListener('click', (e) => {
            // Only handle clicks that aren't on the remove button
            if (!e.target.classList.contains('people-model-remove')) {
                console.log('🎯 Clicking model in people panel:', modelData.id, 'Current active:', live2dMultiModelManager?.activeModelId);
                
                // Only switch if it's not already the active model
                if (live2dMultiModelManager && live2dMultiModelManager.activeModelId !== modelData.id) {
                    console.log('🔄 Switching to model:', modelData.id);
                    live2dMultiModelManager.setActiveModel(modelData.id);
                    
                    // Update current model reference for mouse interaction
                    setTimeout(() => {
                        updateCurrentModelReference();
                        updateModelInfoDisplay(`Switched to model: ${modelData.name}\nTry clicking or dragging the model`);
                    }, 200);
                    
                    // Refresh the panel to update active states
                    setTimeout(() => populatePeopleModels(), 100);
                } else {
                    console.log('✅ Model already active:', modelData.id);
                    
                    // Still update the reference in case it got lost
                    updateCurrentModelReference();
                    updateModelInfoDisplay(`Model ${modelData.name} is already active\nTry clicking or dragging the model`);
                }
            }
        });
        
        modelsList.appendChild(modelItem);
    });
}

function selectModel(modelId) {
    // Update active model
    document.querySelectorAll('.people-model-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Set the clicked model as active
    event.currentTarget.classList.add('active');
    
    // Update model name in settings
    const modelSelect = document.getElementById('modelSelect');
    if (modelSelect) {
        modelSelect.value = modelId;
        onModelChange();
    }
}

function removeModel(modelId) {
    console.log('Removing model:', modelId);
    
    // Remove model from multi-model manager
    if (live2dMultiModelManager) {
        live2dMultiModelManager.removeModel(modelId);
        // Refresh the people panel after a short delay to allow cleanup
        setTimeout(() => populatePeopleModels(), 200);
    }
    
    // Prevent event bubbling
    return false;
}

function showAddModelDialog() {
    console.log('Opening add model dialog...');
    const dialog = document.getElementById('modelSelectionDialog');
    if (dialog) {
        dialog.style.display = 'flex';
        loadAvailableModelsForDialog();
    }
}

function closeAddModelDialog() {
    console.log('Closing add model dialog...');
    const dialog = document.getElementById('modelSelectionDialog');
    if (dialog) {
        dialog.style.display = 'none';
    }
}

async function loadAvailableModelsForDialog() {
    console.log('Loading available models for dialog...');
    const modelGrid = document.getElementById('modelGrid');
    
    try {
        // Use the already-loaded model list from the multi-model manager
        if (!live2dMultiModelManager || !live2dMultiModelManager.modelList || live2dMultiModelManager.modelList.length === 0) {
            // If not loaded yet, try to load
            await live2dMultiModelManager.loadAvailableModels();
        }
        
        const availableModels = live2dMultiModelManager.modelList;
        
        if (!availableModels || availableModels.length === 0) {
            modelGrid.innerHTML = '<div style="text-align: center; padding: 20px; color: #aaa;">No models available. Please check your model directory.</div>';
            return;
        }
        
        // Create model cards
        modelGrid.innerHTML = '';
        availableModels.forEach(model => {
            const modelCard = document.createElement('div');
            modelCard.className = 'model-card';
            modelCard.onclick = () => selectModelFromDialog(model.name, model.name);
            
            modelCard.innerHTML = `
                <div class="model-preview">
                    <div class="model-icon">🎭</div>
                </div>
                <div class="model-info">
                    <div class="model-name">${model.name}</div>
                    <div class="model-description">Live2D Model</div>
                </div>
            `;
            
            modelGrid.appendChild(modelCard);
        });
        
    } catch (error) {
        console.error('Error loading models for dialog:', error);
        modelGrid.innerHTML = '<div style="text-align: center; padding: 20px; color: #f44;">Error loading models. Please try again.</div>';
    }
}

function selectModelFromDialog(modelValue, modelName) {
    console.log('Selected model from dialog:', modelName, modelValue);
    
    // Add model using the multi-model manager
    if (live2dMultiModelManager) {
        live2dMultiModelManager.addModel(modelName).then(() => {
            console.log('Model added successfully:', modelName);
            // The people panel will be refreshed automatically by the multi-model manager
        }).catch(error => {
            console.error('Failed to add model:', error);
            addSystemMessage(`Failed to add model: ${error.message}`, 'error');
        });
    } else {
        console.error('Multi-model manager not available');
        addSystemMessage('Live2D system not ready', 'error');
    }
    
    // Close dialog
    closeAddModelDialog();
}

function addModelToPeoplePanel(modelValue, modelName) {
    const modelsList = document.getElementById('peopleModelsList');
    
    // Check if model already exists
    const existingModels = modelsList.querySelectorAll('.people-model-item');
    for (let model of existingModels) {
        if (model.dataset.modelValue === modelValue) {
            console.log('Model already in people panel');
            return;
        }
    }
    
    // Create new model item
    const modelItem = document.createElement('div');
    modelItem.className = 'people-model-item';
    modelItem.dataset.modelValue = modelValue;
    modelItem.onclick = () => {
        // Remove active class from all models
        const allModels = modelsList.querySelectorAll('.people-model-item');
        allModels.forEach(m => m.classList.remove('active'));
        
        // Add active class to clicked model
        modelItem.classList.add('active');
        
        // Load the model
        const modelSelect = document.getElementById('modelSelect');
        modelSelect.value = modelValue;
        onModelChange();
    };
    
    modelItem.innerHTML = `
        <div class="people-model-avatar">🎭</div>
        <div class="people-model-info">
            <div class="people-model-name">${modelName}</div>
            <div class="people-model-status">Ready</div>
        </div>
        <button class="people-model-remove" onclick="removeModelFromPeoplePanel(event, '${modelValue}')" title="Remove model">×</button>
    `;
    
    modelsList.appendChild(modelItem);
    console.log('Added model to people panel:', modelName);
}

function removeModelFromPeoplePanel(event, modelValue) {
    event.stopPropagation(); // Prevent triggering the model selection
    
    const modelsList = document.getElementById('peopleModelsList');
    const modelItem = modelsList.querySelector(`.people-model-item[data-model-value="${modelValue}"]`);
    
    if (modelItem) {
        modelItem.remove();
        console.log('Removed model from people panel:', modelValue);
    }
}

// Draggable functionality
function initializeDraggable() {
    const draggableElements = [
        { element: document.getElementById('chatWindow'), header: '.chat-header' },
        { element: document.getElementById('peoplePanel'), header: '.people-header' },
        { element: document.getElementById('settingsPanel'), header: '.settings-header' }
    ];
    
    draggableElements.forEach(({ element, header }) => {
        const headerElement = element.querySelector(header);
        if (headerElement) {
            headerElement.addEventListener('mousedown', (e) => startDrag(e, element));
        }
    });
    
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', stopDrag);
}

function startDrag(e, element) {
    // Check if the element is pinned and prevent dragging
    const pinButton = element.querySelector('.control-btn[onclick*="Snap"]');
    const isPinned = pinButton && pinButton.classList.contains('pinned');
    
    if (isPinned) {
        return; // Don't allow dragging if pinned
    }
    
    isDragging = true;
    currentDragElement = element;
    
    const rect = element.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;
    
    element.style.zIndex = '300';
    document.body.style.cursor = 'move';
}

function drag(e) {
    if (!isDragging || !currentDragElement) return;
    
    const x = e.clientX - dragOffset.x;
    const y = e.clientY - dragOffset.y;
    
    // Constrain to viewport
    const maxX = window.innerWidth - currentDragElement.offsetWidth;
    const maxY = window.innerHeight - currentDragElement.offsetHeight;
    
    const constrainedX = Math.max(0, Math.min(x, maxX));
    const constrainedY = Math.max(0, Math.min(y, maxY));
    
    currentDragElement.style.left = constrainedX + 'px';
    currentDragElement.style.top = constrainedY + 'px';
    currentDragElement.style.right = 'auto';
    currentDragElement.style.bottom = 'auto';
    currentDragElement.style.transform = 'none';
}

function stopDrag() {
    if (isDragging) {
        isDragging = false;
        if (currentDragElement) {
            currentDragElement.style.zIndex = '200';
        }
        currentDragElement = null;
        document.body.style.cursor = 'default';
        
        // Save layout when dragging stops
        saveWindowLayout();
    }
}

// Chat functionality
function handleChatKeyPress(event) {
    if (event.key === 'Enter') {
        sendMessage();
    }
}

function sendMessage() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();
    
    if (message) {
        // Add message to chat
        addMessageToChat('user', message);
        input.value = '';
        
        // Send to AI backend via SocketIO
        sendChatMessage(message);
    }
}

function addMessageToChat(sender, message) {
    const messagesContainer = document.getElementById('chatMessages');
    const messageElement = document.createElement('div');
    messageElement.className = `chat-message ${sender}`;
    messageElement.innerHTML = `
        <div class="message-content">${message}</div>
        <div class="message-time">${new Date().toLocaleTimeString()}</div>
    `;
    messagesContainer.appendChild(messageElement);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

function sendChatMessage(message) {
    // Check if socket is available
    if (typeof socket !== 'undefined' && socket.connected) {
        socket.emit('chat_message', { message: message });
    } else {
        console.warn('Socket not available, using fallback API');
        // Fallback to direct API call
        sendChatToAPI(message);
    }
}

async function sendChatToAPI(message) {
    try {
        const response = await makeApiCall('/api/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message: message })
        });
        
        if (response.ok) {
            const data = await response.json();
            if (data.response) {
                addMessageToChat('assistant', data.response);
            }
        } else {
            addMessageToChat('system', 'Error: Failed to get response from AI');
        }
    } catch (error) {
        console.error('Chat API error:', error);
        addMessageToChat('system', 'Error: Could not send message');
    }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    // Update initial status
    updateModelInfoDisplay('🔄 Loading Live2D system...\nInitializing libraries and components');
    
    // Load and apply saved window layout
    loadWindowLayout();
    
    // Initialize draggable functionality
    initializeDraggable();
    
    // Initialize navigation states
    updateNavIconStates();
    
    // Wait for all libraries to load properly
    setTimeout(async function() {
        console.log('Libraries loaded, checking availability...');
        
        // Check library availability
        if (typeof PIXI === 'undefined') {
            console.error('PIXI.js not loaded');
            updateModelInfoDisplay('❌ PIXI.js not loaded\nCheck that PIXI library loaded correctly');
            return;
        }
        
        if (typeof EventEmitter === 'undefined') {
            console.error('EventEmitter not available');
            updateModelInfoDisplay('❌ EventEmitter not available\nCheck browser compatibility');
            return;
        }
        
        // Check Live2D SDK availability
        if (typeof Live2DCubismCore === 'undefined') {
            console.error('Live2D Cubism Core SDK not loaded');
            updateModelInfoDisplay('❌ Live2D SDK not loaded\nCheck browser console for errors');
            return;
        }
        
        // Make SDK available globally for debug console
        window.LIVE2DCUBISMCORE = Live2DCubismCore;
        
        console.log('PIXI version:', PIXI.VERSION);
        console.log('EventEmitter available:', typeof EventEmitter !== 'undefined');
        console.log('Live2D SDK available:', typeof Live2DCubismCore !== 'undefined');
        
        // Initialize the Live2D system with timeout fallback
        console.log('Starting Live2D initialization...');
        
        try {
            await Promise.race([
                initializeLive2D(),
                new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Initialization timeout')), 10000)
                )
            ]);
            console.log('Live2D initialization completed!');
            
            // Update status display after initialization
            updateModelInfoDisplay('✅ Live2D system initialized\nLoad a model from People panel to test interaction');
            
            // Set up initial model reference if available
            setTimeout(() => {
                updateCurrentModelReference();
            }, 1000);
        } catch (error) {
            console.error('Live2D initialization failed:', error);
            updateModelInfoDisplay(`❌ Live2D initialization failed\n${error.message}\nCheck browser console for details`);
        }
        
        // Verify globals are available
        console.log('Global check - window.live2dIntegration:', typeof window.live2dIntegration);
        console.log('Global check - window.live2dMultiModelManager:', typeof window.live2dMultiModelManager);
        console.log('Global check - window.LIVE2DCUBISMCORE:', typeof window.LIVE2DCUBISMCORE);
    }, 1000); // Increased delay to ensure libraries are loaded
});

// Save layout on window resize and before page unload
window.addEventListener('resize', function() {
    // Debounce resize events to avoid excessive saves
    clearTimeout(window.resizeTimeout);
    window.resizeTimeout = setTimeout(saveWindowLayout, 500);
});

window.addEventListener('beforeunload', function() {
    saveWindowLayout();
});

// ===============================================================================
// ENHANCED AI COMPANION FUNCTIONALITY
// ===============================================================================

// Enhanced Chat System
function handleChatKeyPress(event) {
    if (event.key === 'Enter') {
        sendMessage();
    }
}

async function sendMessage() {
    const chatInput = document.getElementById('chatInput');
    const chatMessages = document.getElementById('chatMessages');
    const text = chatInput.value.trim();
    
    if (!text) return;
    
    // Add user message to chat
    addChatMessage('user', text);
    chatInput.value = '';
    
    try {
        // Use the same fetchWithFallback system as Live2D models
        let apiBaseUrl = window.ai2d_chat_CONFIG?.API_BASE_URL;
        let response;
        
        // Try primary API URL first
        if (apiBaseUrl) {
            try {
                response = await fetch(`${apiBaseUrl}/api/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: text })
                });
                if (response.ok) {
                    const data = await response.json();
                    
                    // Add AI response to chat
                    addChatMessage('ai', data.reply || '[No reply]');
                    
                    // Play TTS if available
                    if (data.tts_data) {
                        playEmotionalTTSAudio(data.tts_data);
                    }
                    
                    // Trigger Live2D emotion/motion if available
                    if (data.emotion && window.live2dIntegration) {
                        triggerEmotionalResponse(data.emotion, data.intensity || 0.5);
                    }
                    return;
                }
            } catch (error) {
                console.warn(`Enhanced chat API failed with primary URL ${apiBaseUrl}:`, error.message);
            }
        }
        
        // Try fallback URLs if primary failed
        const fallbackUrls = window.ai2d_chat_CONFIG?.FALLBACK_URLS || [];
        for (const fallbackUrl of fallbackUrls) {
            try {
                console.log(`Trying enhanced chat API fallback URL: ${fallbackUrl}`);
                response = await fetch(`${fallbackUrl}/api/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: text })
                });
                if (response.ok) {
                    console.log(`Enhanced chat API successful with fallback URL: ${fallbackUrl}`);
                    // Update the working URL for future requests
                    window.ai2d_chat_CONFIG.API_BASE_URL = fallbackUrl;
                    const data = await response.json();
                    
                    // Add AI response to chat
                    addChatMessage('ai', data.reply || '[No reply]');
                    
                    // Play TTS if available
                    if (data.tts_data) {
                        playEmotionalTTSAudio(data.tts_data);
                    }
                    
                    // Trigger Live2D emotion/motion if available
                    if (data.emotion && window.live2dIntegration) {
                        triggerEmotionalResponse(data.emotion, data.intensity || 0.5);
                    }
                    return;
                }
            } catch (error) {
                console.warn(`Enhanced chat API fallback failed with ${fallbackUrl}:`, error.message);
            }
        }
        
        // If all URLs failed, throw error
        throw new Error('All enhanced chat API endpoints failed');
        
    } catch (error) {
        console.error('Error sending message:', error);
        addChatMessage('system', `Failed to send message: ${error.message}`, 'error');
    }
}

function addChatMessage(sender, message, type = 'info') {
    const chatMessages = document.getElementById('chatMessages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `chat-message ${sender} ${type}`;
    
    const timestamp = new Date().toLocaleTimeString();
    messageDiv.innerHTML = `
        <div class="message-content">${escapeHtml(message)}</div>
        <div class="message-time">${timestamp}</div>
    `;
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Enhanced Debug Console
function toggleDebugConsole() {
    const debugPanel = document.getElementById('debugUIPanel');
    if (debugPanel.style.display === 'none' || !debugPanel.style.display) {
        debugPanel.style.display = 'block';
        console.log('🔍 Debug console opened');
    } else {
        debugPanel.style.display = 'none';
        console.log('🔍 Debug console closed');
    }
}

// Live2D Emotional Response Integration
function triggerEmotionalResponse(emotion, intensity = 0.5) {
    if (!window.live2dIntegration || !window.live2dIntegration.motionManager) {
        console.warn('Live2D integration not available for emotional response');
        return;
    }
    
    // Map emotions to Live2D motions
    const emotionMotionMap = {
        'happy': 'idle',
        'excited': 'head',
        'sad': 'body',
        'surprised': 'expression',
        'curious': 'special',
        'thoughtful': 'talk'
    };
    
    const motionType = emotionMotionMap[emotion] || 'idle';
    
    console.log(`🎭 Triggering emotional response: ${emotion} (${motionType})`);
    
    // Trigger motion via Live2D integration
    if (typeof window.triggerMotion === 'function') {
        window.triggerMotion(motionType);
    }
}

// SocketIO Integration
let socket = null;

function initializeSocketIO() {
    if (typeof io !== 'undefined') {
        socket = io();
        
        socket.on('connect', function() {
            console.log('🔌 Connected to server via SocketIO');
            addSystemMessage('Connected to AI live2d chat server', 'success');
        });
        
        socket.on('disconnect', function() {
            console.log('🔌 Disconnected from server');
            addSystemMessage('Disconnected from server', 'warning');
        });
        
        socket.on('ai_response', function(data) {
            console.log('📨 Received AI response via SocketIO:', data);
            addChatMessage('ai', data.message);
            
            if (data.tts_data) {
                playEmotionalTTSAudio(data.tts_data);
            }
            
            if (data.emotion) {
                triggerEmotionalResponse(data.emotion, data.intensity);
            }
        });
        
        socket.on('motion_trigger', function(data) {
            console.log('🎭 Received motion trigger:', data);
            if (data.motion_type && typeof window.triggerMotion === 'function') {
                window.triggerMotion(data.motion_type);
            }
        });
        
        console.log('🔌 SocketIO initialized');
    } else {
        console.warn('⚠️ SocketIO not available');
    }
}

// System Utility Functions
function addSystemMessage(message, type = 'info') {
    addChatMessage('system', message, type);
}

// Initialize enhanced features when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    console.log('🚀 Initializing AI Companion enhanced features...');
    
    // Initialize SocketIO after a short delay
    setTimeout(() => {
        initializeSocketIO();
    }, 2000);
    
    console.log('✅ AI Companion enhanced features initialized');
});
</script>

</body>
</html>
